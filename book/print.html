<!DOCTYPE html>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Fallback to default mdbook template -->
        
        <meta name="robots" content="noindex,follow">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta charset="utf-8">
        <title>LuaNext Documentation</title>
        <script>
            var theme = localStorage.getItem("mdbook-theme");
            if (theme === null || theme === undefined) { theme = "light"; }
            var html = document.querySelector("html");
            html.classList.remove("light");
            html.classList.add(theme);
        </script>
        <meta name="description" content="A typed superset of Lua with gradual typing, inspired by TypeScript">
        <link rel="icon" href="favicon.svg">
        <link rel="apple-touch-icon" href="apple-touch-icon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/custom.css">
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

    </head>
    <body>
        <!-- Provide the book title to JavaScript -->
        <script>
            window.book = window.book || {};
            window.book.language = "en";
        </script>

        <div id="book" class="book">
            <div class="book-inner">

            <nav role="navigation" aria-label="Table of contents" class="sidebar">
                <ol class="chapter"><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="introduction.html">Introduction</a></span></li><li class="chapter-item expanded "><li class="spacer"></li></li><li class="chapter-item expanded "><li class="part-title">Language</li></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/basics.html"><strong aria-hidden="true">1.</strong> Basics</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/control-flow.html"><strong aria-hidden="true">2.</strong> Control Flow</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/functions.html"><strong aria-hidden="true">3.</strong> Functions</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/type-system.html"><strong aria-hidden="true">4.</strong> Type System</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/classes.html"><strong aria-hidden="true">5.</strong> Classes</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/interfaces.html"><strong aria-hidden="true">6.</strong> Interfaces</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/enums.html"><strong aria-hidden="true">7.</strong> Enums</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/modules.html"><strong aria-hidden="true">8.</strong> Modules</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/pattern-matching.html"><strong aria-hidden="true">10.</strong> Pattern Matching</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/decorators.html"><strong aria-hidden="true">11.</strong> Decorators</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/advanced-types.html"><strong aria-hidden="true">12.</strong> Advanced Types</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="language/operators.html"><strong aria-hidden="true">13.</strong> Operators</a></span></li><li class="chapter-item expanded "><li class="spacer"></li></li><li class="chapter-item expanded "><li class="part-title">Guides</li></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="guides/migrating-from-lua.html"><strong aria-hidden="true">14.</strong> Migrating from Lua</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="guides/lua-targets.html"><strong aria-hidden="true">15.</strong> Lua Targets</a></span></li><li class="chapter-item expanded "><li class="spacer"></li></li><li class="chapter-item expanded "><li class="part-title">Reference</li></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="reference/cli.html"><strong aria-hidden="true">16.</strong> CLI</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="reference/configuration.html"><strong aria-hidden="true">17.</strong> Configuration</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="reference/standard-library.html"><strong aria-hidden="true">18.</strong> Standard Library</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="reference/utility-types.html"><strong aria-hidden="true">19.</strong> Utility Types</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="reference/reflection.html"><strong aria-hidden="true">20.</strong> Reflection API</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="reference/error-codes.html"><strong aria-hidden="true">21.</strong> Error Codes</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="reference/grammar.html"><strong aria-hidden="true">22.</strong> Grammar</a></span></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="reference/keywords.html"><strong aria-hidden="true">23.</strong> Keywords</a></span></li><li class="chapter-item expanded "><li class="spacer"></li></li><li class="chapter-item expanded "><li class="part-title">Contributing</li></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="contributing/setup.html"><strong aria-hidden="true">24.</strong> Getting Started</a></span></li><li class="chapter-item expanded "><li class="spacer"></li></li><li class="chapter-item expanded "><li class="part-title">API Reference</li></li><li class="chapter-item expanded "><span class="chapter-link-wrapper"><a href="api/index.html"><strong aria-hidden="true">25.</strong> Rust API Docs</a></span></li></ol>
            </nav>

            <div id="page-wrapper" class="page-wrapper">

                <div class="page-inner">

                <section class="normal" id="main">
                    <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>LuaNext is a typed superset of Lua with gradual typing, inspired by TypeScript’s approach to JavaScript. It brings static type checking to Lua while maintaining its simplicity and allowing gradual adoption. Write type-safe Lua code that compiles to plain Lua, with zero runtime overhead.</p>
<h2 id="what-is-luanext"><a class="header" href="#what-is-luanext">What is LuaNext?</a></h2>
<p>LuaNext extends Lua with optional type annotations, interfaces, generics, and modern language features. The type system is erased at compile time, producing clean, readable Lua code that runs on any Lua 5.1–5.4 interpreter.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Gradual Typing</strong> — Add types at your own pace, from none to full coverage</li>
<li><strong>Zero Runtime Cost</strong> — Types are erased at compile time</li>
<li><strong>Lua Compatibility</strong> — Compiles to clean, readable Lua (5.1-5.4)</li>
<li><strong>Rich Type System</strong> — Interfaces, unions, generics, conditional types, and more</li>
<li><strong>Optional Features</strong> — Enable OOP, functional programming, or decorators as needed</li>
<li><strong>LSP Support</strong> — Full language server with autocomplete, diagnostics, and more</li>
<li><strong>Multi-File Compilation</strong> — Compile entire projects with automatic dependency ordering</li>
<li><strong>Circular Dependency Detection</strong> — Catch import cycles before compilation</li>
<li><strong>Incremental Compilation</strong> — Fast rebuilds with intelligent caching</li>
<li><strong>Source Maps</strong> — Debug compiled Lua with original LuaNext source</li>
<li><strong>Optional Optimizations</strong> — Enable performance optimizations like constant folding, dead code elimination, and tail call optimization</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>LuaNext code:</p>
<pre><code class="language-lua">-- Variable declarations with types
const PI: number = 3.14159
local radius: number = 5

-- Interfaces for table shapes
interface Point {
    x: number,
    y: number
}

-- Functions with type signatures
function calculateArea(r: number): number
    return PI * r * r
end

-- Type inference
const area = calculateArea(radius)  -- inferred as number

print("Area:", area)
</code></pre>
<p>Compiles to clean Lua:</p>
<pre><code class="language-lua">local PI = 3.14159
local radius = 5

local function calculateArea(r)
    return PI * r * r
end

local area = calculateArea(radius)

print("Area:", area)
</code></pre>
<h2 id="why-luanext"><a class="header" href="#why-luanext">Why LuaNext?</a></h2>
<p><strong>Catch bugs before runtime</strong> — The type checker finds type errors, nil access, and mismatched function signatures before your code runs.</p>
<p><strong>Better IDE support</strong> — Autocomplete, go-to-definition, inline documentation, and refactoring powered by the LSP.</p>
<p><strong>Gradual adoption</strong> — Start with plain Lua and add types incrementally. No need to rewrite everything at once.</p>
<p><strong>No runtime cost</strong> — Types are stripped during compilation. Your Lua code runs exactly as fast as hand-written Lua.</p>
<p><strong>Modern language features</strong> — Classes, interfaces, enums, pattern matching, decorators, generics, and more.</p>
<h2 id="optional-optimizations"><a class="header" href="#optional-optimizations">Optional Optimizations</a></h2>
<p>LuaNext includes optional compiler optimizations that can improve runtime performance while maintaining correctness. These are disabled by default but can be enabled per-project:</p>
<p><strong>Constant Folding &amp; Propagation</strong> — Evaluate constant expressions at compile time and propagate known values through the code.</p>
<p><strong>Dead Code Elimination</strong> — Remove unreachable code, unused variables, and redundant operations.</p>
<p><strong>Tail Call Optimization</strong> — Transform tail-recursive calls into loops to prevent stack overflow.</p>
<p><strong>Table Preallocation</strong> — Pre-size tables when the number of elements is known at compile time.</p>
<p><strong>Rich Enum Optimization</strong> — Optimize enum value representations and eliminate unnecessary type checks.</p>
<p><strong>Function Inlining</strong> — Inline small functions to reduce call overhead (configurable threshold).</p>
<p>These optimizations are carefully designed to preserve your code’s semantics while improving performance. Enable them with the <code>--optimize</code> flag or configure individual passes in your project settings.</p>
<h2 id="the-luanext-ecosystem"><a class="header" href="#the-luanext-ecosystem">The LuaNext Ecosystem</a></h2>
<p>LuaNext is part of a broader ecosystem of Lua/LuaNext developer tools. Each tool works standalone on plain Lua but gains capabilities when used together.</p>
<h3 id="developer-tools"><a class="header" href="#developer-tools">Developer Tools</a></h3>
<p><strong><a href="https://github.com/forge18/depot">Depot</a></strong> — Lua Package Manager</p>
<ul>
<li>Local, project-scoped dependency management (like npm/cargo for Lua)</li>
<li>Lua version manager (manage 5.1, 5.3, 5.4 installs)</li>
<li>Lockfile support for reproducible builds</li>
<li>SemVer version resolution</li>
<li>LuaRocks compatible upstream package source</li>
<li>Supply chain security (BLAKE3 checksums, sandboxed builds)</li>
<li>Watch mode for automatic rebuilds on file changes</li>
</ul>
<p><strong><a href="https://github.com/forge18/lintomatic">Lintomatic</a></strong> — Linter for Lua and LuaNext</p>
<ul>
<li>100+ built-in rules across 8 categories</li>
<li>Rust backend for performance</li>
<li>Lua plugin API for custom rules</li>
<li>Type-aware linting when used with LuaNext</li>
<li>Auto-fix support</li>
<li>Works with both plain Lua and LuaNext</li>
</ul>
<p><strong><a href="https://github.com/forge18/canary">Canary</a></strong> — Test Framework</p>
<ul>
<li>Rust-powered test runner with Vitest-inspired API</li>
<li>Built-in mocking and spying</li>
<li>Snapshot testing</li>
<li>Coverage collection</li>
<li>Parallel test execution</li>
<li>Works with both plain Lua and LuaNext</li>
</ul>
<p><strong><a href="https://github.com/forge18/wayfinder">Wayfinder</a></strong> — Debugger (DAP)</p>
<ul>
<li>Debug Adapter Protocol implementation for Lua</li>
<li>Works with PUC Lua 5.1-5.4 and LuaNext</li>
<li>Source map support for LuaNext debugging</li>
<li>Breakpoints, stepping, stack inspection, variable watches</li>
<li>IDE integration (VS Code, Neovim, JetBrains)</li>
<li>Works with both plain Lua and LuaNext</li>
</ul>
<h3 id="core-libraries"><a class="header" href="#core-libraries">Core Libraries</a></h3>
<p>These standalone crates are available for building ecosystem tools:</p>
<p><strong><a href="https://github.com/forge18/luanext-parser">luanext-parser</a></strong> — Parser Library</p>
<ul>
<li>Lexer and parser for LuaNext (.luax) files</li>
<li>Arena-allocated AST (<code>bumpalo::Bump</code>)</li>
<li>String interner for efficient symbol handling</li>
<li>Full error recovery and span tracking</li>
</ul>
<p><strong><a href="https://github.com/forge18/luanext-typechecker">luanext-typechecker</a></strong> — Type Checker Library</p>
<ul>
<li>Complete type checking for LuaNext</li>
<li>Type inference, generics, conditional types</li>
<li>Diagnostic reporting</li>
<li>Module resolution and dependency tracking</li>
</ul>
<p><strong><a href="https://github.com/forge18/luanext-sourcemap">luanext-sourcemap</a></strong> — Source Map Library</p>
<ul>
<li>Source map generation and consumption</li>
<li>Maps compiled Lua positions back to LuaNext source</li>
<li>Used by Wayfinder for debug source mapping</li>
</ul>
<p><strong><a href="https://github.com/forge18/luanext-lsp">luanext-lsp</a></strong> — Language Server Protocol</p>
<ul>
<li>Full LSP implementation for LuaNext</li>
<li>Completion, hover, go-to-definition, references, rename, formatting, diagnostics</li>
<li>Semantic tokens, inlay hints, code actions</li>
<li>Powers the VS Code extension</li>
</ul>
<p>These crates are published separately so ecosystem tools can depend on them without pulling in the full compiler.</p>
<h2 id="project-status"><a class="header" href="#project-status">Project Status</a></h2>
<p><strong>Current Status: Beta</strong></p>
<p>The compiler is feature-complete and ready for testing. All core features are implemented and functional.</p>
<p><strong>Next Steps: v1.0 Release</strong></p>
<ul>
<li>Performance optimization and profiling</li>
<li>Documentation improvements</li>
<li>Community feedback and testing</li>
</ul>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<ul>
<li><strong>GitHub:</strong> <a href="https://github.com/forge18/luanext">github.com/forge18/luanext</a></li>
<li><strong>Issues:</strong> <a href="https://github.com/forge18/luanext/issues">Report bugs and feature requests</a></li>
<li><strong>Discussions:</strong> <a href="https://github.com/forge18/luanext/discussions">Ask questions and share ideas</a></li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>LuaNext is open source software released under the MIT License.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>LuaNext extends Lua with type annotations while preserving Lua’s simplicity. This guide covers variables, primitive types, and basic syntax.</p>
<h2 id="variable-declarations"><a class="header" href="#variable-declarations">Variable Declarations</a></h2>
<p>LuaNext provides two keywords for variable declarations: <code>const</code> for immutable variables and <code>local</code> for mutable variables.</p>
<h3 id="const--immutable-variables"><a class="header" href="#const--immutable-variables"><code>const</code> — Immutable Variables</a></h3>
<p>Variables declared with <code>const</code> cannot be reassigned after initialization:</p>
<pre><code class="language-lua">const PI: number = 3.14159
const status: string = "active"

-- Error: Cannot reassign const variable
PI = 3.14  -- ❌ Type error
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local PI = 3.14159
local status = "active"
</code></pre>
<h3 id="local--mutable-variables"><a class="header" href="#local--mutable-variables"><code>local</code> — Mutable Variables</a></h3>
<p>Variables declared with <code>local</code> can be reassigned:</p>
<pre><code class="language-lua">local count: number = 0
local name: string = "Alice"

count = 5        -- ✅ OK
name = "Bob"     -- ✅ OK
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local count = 0
local name = "Alice"

count = 5
name = "Bob"
</code></pre>
<h3 id="why-both"><a class="header" href="#why-both">Why Both?</a></h3>
<ul>
<li><strong>Type Safety</strong> — Immutability checking catches bugs at compile time</li>
<li><strong>Clear Intent</strong> — Code readers know which values change</li>
<li><strong>Better Inference</strong> — Immutable values enable more precise type inference</li>
<li><strong>Zero Cost</strong> — Both compile to <code>local</code>, no runtime overhead</li>
</ul>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>LuaNext includes all Lua primitive types plus additional type safety primitives.</p>
<h3 id="nil"><a class="header" href="#nil"><code>nil</code></a></h3>
<p>Represents the absence of a value:</p>
<pre><code class="language-lua">const x: nil = nil
local optional: string | nil = nil
</code></pre>
<h3 id="boolean"><a class="header" href="#boolean"><code>boolean</code></a></h3>
<p>True or false values:</p>
<pre><code class="language-lua">const isActive: boolean = true
const hasPermission: boolean = false
</code></pre>
<h3 id="number"><a class="header" href="#number"><code>number</code></a></h3>
<p>Lua’s numeric type (double-precision float):</p>
<pre><code class="language-lua">const pi: number = 3.14159
const count: number = 42
const negative: number = -10.5
</code></pre>
<h3 id="integer"><a class="header" href="#integer"><code>integer</code></a></h3>
<p>Subset of <code>number</code> for whole numbers (useful for Lua 5.3+ and array indices):</p>
<pre><code class="language-lua">const index: integer = 1
const count: integer = 100

-- Error: Not an integer
const wrong: integer = 3.14  -- ❌ Type error
</code></pre>
<p>In Lua 5.3+, integers are stored more efficiently than floats. In earlier versions, <code>integer</code> is type-checked but compiles to <code>number</code>.</p>
<h3 id="string"><a class="header" href="#string"><code>string</code></a></h3>
<p>Text values:</p>
<pre><code class="language-lua">const name: string = "Alice"
const message: string = 'Hello, World!'
const multiline: string = [[
  This is a
  multiline string
]]
</code></pre>
<h3 id="table"><a class="header" href="#table"><code>table</code></a></h3>
<p>Generic table type (base for all tables/objects):</p>
<pre><code class="language-lua">const data: table = {x = 1, y = 2}
const array: table = {1, 2, 3, 4}
</code></pre>
<p>Use interfaces for typed table shapes (see <a href="#interfaces">Interfaces</a>).</p>
<h3 id="coroutine--thread"><a class="header" href="#coroutine--thread"><code>coroutine</code> / <code>thread</code></a></h3>
<p>Lua coroutines:</p>
<pre><code class="language-lua">const co: coroutine = coroutine.create(function()
    print("Hello from coroutine")
end)
</code></pre>
<p>Both <code>coroutine</code> and <code>thread</code> are synonyms for the same type.</p>
<h2 id="special-types"><a class="header" href="#special-types">Special Types</a></h2>
<h3 id="unknown"><a class="header" href="#unknown"><code>unknown</code></a></h3>
<p>Type-safe unknown value. Must be narrowed before use:</p>
<pre><code class="language-lua">const data: unknown = getExternalData()

-- Error: Cannot use unknown value directly
print(data.name)  -- ❌ Type error

-- Narrow with type guards
if type(data) == "table" then
    -- data is now table
    print(data.name)  -- ✅ OK
end
</code></pre>
<p>Unlike TypeScript’s <code>any</code>, <code>unknown</code> is strict and requires type narrowing.</p>
<h3 id="never"><a class="header" href="#never"><code>never</code></a></h3>
<p>Bottom type representing impossible values. Used for exhaustiveness checking:</p>
<pre><code class="language-lua">type Status = "active" | "inactive" | "pending"

function handleStatus(status: Status): void
    if status == "active" then
        print("Active")
    elseif status == "inactive" then
        print("Inactive")
    elseif status == "pending" then
        print("Pending")
    else
        -- status is never here (exhaustive check)
        const _exhaustive: never = status
    end
end
</code></pre>
<h3 id="void"><a class="header" href="#void"><code>void</code></a></h3>
<p>Indicates functions that return nothing:</p>
<pre><code class="language-lua">function log(message: string): void
    print(message)
end
</code></pre>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>Use <code>:</code> to annotate types (same as TypeScript):</p>
<pre><code class="language-lua">-- Variables
const name: string = "Alice"
local count: number = 0

-- Function parameters and return type
function greet(name: string): string
    return "Hello, " .. name
end

-- Inline table types
const point: {x: number, y: number} = {x = 1, y = 2}
</code></pre>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>LuaNext infers types when not explicitly provided:</p>
<pre><code class="language-lua">-- Inferred as number
const x = 42

-- Inferred as string
const message = "Hello"

-- Inferred as (number, number) -&gt; number
function add(a, b)
    return a + b
end

-- Inferred as number
const sum = add(5, 10)
</code></pre>
<p>Type inference works for:</p>
<ul>
<li>Literals (<code>const x = 42</code> → <code>number</code>)</li>
<li>Function return types (from return expressions)</li>
<li>Variable assignments (from RHS type)</li>
</ul>
<p>For complex types, explicit annotations improve readability.</p>
<h2 id="string-templates"><a class="header" href="#string-templates">String Templates</a></h2>
<p>LuaNext supports template strings with embedded expressions:</p>
<pre><code class="language-lua">const name: string = "Alice"
const age: number = 30

const message: string = `Hello, ${name}! You are ${age} years old.`
print(message)  -- Hello, Alice! You are 30 years old.
</code></pre>
<p>Compiles to string concatenation:</p>
<pre><code class="language-lua">local name = "Alice"
local age = 30

local message = "Hello, " .. tostring(name) .. "! You are " .. tostring(age) .. " years old."
print(message)
</code></pre>
<p>Multi-line template strings:</p>
<pre><code class="language-lua">const user: string = "Alice"
const html: string = `
    &lt;div&gt;
        &lt;h1&gt;Welcome, ${user}!&lt;/h1&gt;
        &lt;p&gt;This is a multi-line template.&lt;/p&gt;
    &lt;/div&gt;
`
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>LuaNext supports Lua’s comment syntax:</p>
<pre><code class="language-lua">-- Single-line comment

--[[
  Multi-line
  comment
]]

---
--- Triple-dash comments are used for documentation
--- @param name The user's name
---
function greet(name: string): void
    print("Hello, " .. name)
end
</code></pre>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p>Use <code>do ... end</code> to create scoped blocks:</p>
<pre><code class="language-lua">do
    const x: number = 10
    print(x)  -- 10
end

-- Error: x is not in scope
print(x)  -- ❌ Not defined
</code></pre>
<h2 id="type-assertions"><a class="header" href="#type-assertions">Type Assertions</a></h2>
<p>Use <code>as</code> to assert a type:</p>
<pre><code class="language-lua">const data: unknown = getData()
const user = data as {name: string, age: number}

print(user.name)  -- ✅ OK
</code></pre>
<p>Use with caution — type assertions bypass type checking.</p>
<h2 id="nullable-types"><a class="header" href="#nullable-types">Nullable Types</a></h2>
<p>Use <code>| nil</code> for nullable values:</p>
<pre><code class="language-lua">const optional: string | nil = nil
local name: string | nil = "Alice"

name = nil  -- ✅ OK
</code></pre>
<p>Check for nil before use:</p>
<pre><code class="language-lua">if name ~= nil then
    print(name)  -- name is string here
end
</code></pre>
<h2 id="literal-types"><a class="header" href="#literal-types">Literal Types</a></h2>
<p>Values can be types:</p>
<pre><code class="language-lua">type Status = "active" | "inactive"

const status: Status = "active"  -- ✅ OK
const wrong: Status = "pending"  -- ❌ Type error
</code></pre>
<p>Number and boolean literals:</p>
<pre><code class="language-lua">type One = 1
type Zero = 0
type True = true

const x: One = 1       -- ✅ OK
const y: Zero = 0      -- ✅ OK
const z: True = true   -- ✅ OK
</code></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Two syntaxes for array types:</p>
<pre><code class="language-lua">-- Preferred syntax
const numbers: number[] = {1, 2, 3, 4, 5}

-- Generic syntax (equivalent)
const strings: Array&lt;string&gt; = {"a", "b", "c"}
</code></pre>
<p>Both compile to plain Lua tables:</p>
<pre><code class="language-lua">local numbers = {1, 2, 3, 4, 5}
local strings = {"a", "b", "c"}
</code></pre>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Fixed-length arrays with per-element types:</p>
<pre><code class="language-lua">-- [type1, type2, ...]
const pair: [string, number] = {"Alice", 30}
const triple: [boolean, string, number] = {true, "test", 42}

-- Access by index
const name: string = pair[1]   -- "Alice"
const age: number = pair[2]    -- 30
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#control-flow">Control Flow</a> — if, while, for, match</li>
<li><a href="#functions">Functions</a> — Function declarations and types</li>
<li><a href="#type-system">Type System</a> — Advanced type features</li>
<li><a href="#interfaces">Interfaces</a> — Defining table shapes</li>
</ul>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#type-system">Type System</a> — Union, intersection, generics</li>
<li><a href="#standard-library-reference">Standard Library</a> — Global functions and namespaces</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>LuaNext supports all Lua control flow constructs plus additional features like <code>continue</code>.</p>
<h2 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h2>
<h3 id="basic-if"><a class="header" href="#basic-if">Basic If</a></h3>
<pre><code class="language-lua">const age: number = 25

if age &gt;= 18 then
    print("Adult")
end
</code></pre>
<h3 id="if-else"><a class="header" href="#if-else">If-Else</a></h3>
<pre><code class="language-lua">const score: number = 85

if score &gt;= 90 then
    print("A")
else
    print("B or lower")
end
</code></pre>
<h3 id="if-elseif-else"><a class="header" href="#if-elseif-else">If-Elseif-Else</a></h3>
<pre><code class="language-lua">const score: number = 85

if score &gt;= 90 then
    print("A")
elseif score &gt;= 80 then
    print("B")
elseif score &gt;= 70 then
    print("C")
else
    print("F")
end
</code></pre>
<h3 id="type-narrowing"><a class="header" href="#type-narrowing">Type Narrowing</a></h3>
<p>LuaNext narrows types within conditional branches:</p>
<pre><code class="language-lua">const value: string | number = getValue()

if type(value) == "string" then
    -- value is string here
    print(value:upper())
elseif type(value) == "number" then
    -- value is number here
    print(value * 2)
end
</code></pre>
<h2 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h2>
<p>Execute block while condition is true:</p>
<pre><code class="language-lua">local count: number = 0

while count &lt; 5 do
    print(count)
    count = count + 1
end
</code></pre>
<h2 id="repeat-until-loops"><a class="header" href="#repeat-until-loops">Repeat-Until Loops</a></h2>
<p>Execute block at least once, until condition becomes true:</p>
<pre><code class="language-lua">local count: number = 0

repeat
    print(count)
    count = count + 1
until count &gt;= 5
</code></pre>
<h2 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h2>
<h3 id="numeric-for"><a class="header" href="#numeric-for">Numeric For</a></h3>
<pre><code class="language-lua">-- for var = start, end, step do
for i = 1, 10, 1 do
    print(i)
end

-- step defaults to 1
for i = 1, 10 do
    print(i)
end

-- Counting down
for i = 10, 1, -1 do
    print(i)
end
</code></pre>
<p>Type annotation on loop variable:</p>
<pre><code class="language-lua">for i: integer = 1, 100 do
    print(i)
end
</code></pre>
<h3 id="generic-for"><a class="header" href="#generic-for">Generic For</a></h3>
<p>Iterate over tables, arrays, iterators:</p>
<pre><code class="language-lua">-- Arrays
const numbers: number[] = {10, 20, 30, 40}

for i, value in ipairs(numbers) do
    print(i, value)
end

-- Tables
const user = {name = "Alice", age = 30}

for key, value in pairs(user) do
    print(key, value)
end

-- Custom iterators
for line in io.lines("file.txt") do
    print(line)
end
</code></pre>
<p>Type annotations:</p>
<pre><code class="language-lua">for i: integer, value: number in ipairs(numbers) do
    print(i, value)
end
</code></pre>
<h2 id="break"><a class="header" href="#break">Break</a></h2>
<p>Exit loop early:</p>
<pre><code class="language-lua">for i = 1, 100 do
    if i == 50 then
        break
    end
    print(i)
end
</code></pre>
<h2 id="continue"><a class="header" href="#continue">Continue</a></h2>
<p>Skip to next iteration (LuaNext extension):</p>
<pre><code class="language-lua">for i = 1, 10 do
    if i % 2 == 0 then
        continue  -- Skip even numbers
    end
    print(i)  -- Only prints odd numbers
end
</code></pre>
<p>Compiles to a <code>goto</code> statement:</p>
<pre><code class="language-lua">for i = 1, 10 do
    if i % 2 == 0 then
        goto continue_1
    end
    print(i)
    ::continue_1::
end
</code></pre>
<h2 id="labels-and-goto"><a class="header" href="#labels-and-goto">Labels and Goto</a></h2>
<p>Jump to labeled positions:</p>
<pre><code class="language-lua">local i: number = 0

::start::
print(i)
i = i + 1

if i &lt; 5 then
    goto start
end

print("Done")
</code></pre>
<p><strong>Restrictions:</strong></p>
<ul>
<li>Cannot jump into a block from outside</li>
<li>Cannot jump out of a function</li>
<li>Labels must be defined in the same scope</li>
</ul>
<h2 id="do-blocks"><a class="header" href="#do-blocks">Do Blocks</a></h2>
<p>Create scoped blocks:</p>
<pre><code class="language-lua">do
    const x: number = 10
    print(x)
end

-- x is not in scope here
</code></pre>
<p>Useful for limiting variable scope:</p>
<pre><code class="language-lua">local result: number = 0

do
    const temp: number = calculate()
    const adjusted: number = temp * 2
    result = adjusted
end

-- temp and adjusted are not in scope
print(result)
</code></pre>
<h2 id="ternary-operator"><a class="header" href="#ternary-operator">Ternary Operator</a></h2>
<p>Concise conditional expressions:</p>
<pre><code class="language-lua">const age: number = 20
const status: string = age &gt;= 18 ? "adult" : "minor"
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local age = 20
local status = (age &gt;= 18) and "adult" or "minor"
</code></pre>
<p><strong>Note:</strong> Beware of falsy values. Use full <code>if</code> statement when middle value could be <code>false</code> or <code>nil</code>.</p>
<h2 id="short-circuit-evaluation"><a class="header" href="#short-circuit-evaluation">Short-Circuit Evaluation</a></h2>
<h3 id="and-and"><a class="header" href="#and-and">And (<code>and</code>)</a></h3>
<p>Returns first falsy value or last value:</p>
<pre><code class="language-lua">const a: boolean = true
const b: boolean = false

const result = a and b  -- false
</code></pre>
<h3 id="or-or"><a class="header" href="#or-or">Or (<code>or</code>)</a></h3>
<p>Returns first truthy value or last value:</p>
<pre><code class="language-lua">const name: string | nil = getName()
const displayName: string = name or "Guest"
</code></pre>
<h2 id="null-coalescing-operator"><a class="header" href="#null-coalescing-operator">Null Coalescing Operator</a></h2>
<p>Returns right-hand side if left is <code>nil</code> (unlike <code>or</code>, which checks for all falsy values):</p>
<pre><code class="language-lua">const value: number | nil = 0
const result: number = value ?? 10  -- 0 (not 10, because 0 is not nil)

const none: number | nil = nil
const fallback: number = none ?? 10  -- 10
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local value = 0
local result = (value ~= nil) and value or 10

local none = nil
local fallback = (none ~= nil) and none or 10
</code></pre>
<h2 id="optional-chaining"><a class="header" href="#optional-chaining">Optional Chaining</a></h2>
<p>Safely access nested properties that might be nil:</p>
<pre><code class="language-lua">interface User {
    profile?: {
        address?: {
            city?: string
        }
    }
}

const user: User = getUser()

-- Safe access with optional chaining
const city: string | nil = user.profile?.address?.city

-- Without optional chaining (verbose)
local city: string | nil = nil
if user.profile ~= nil and user.profile.address ~= nil then
    city = user.profile.address.city
end
</code></pre>
<p>Method calls:</p>
<pre><code class="language-lua">const result: any = obj?.method?.(arg1, arg2)
</code></pre>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>Match expressions for complex conditionals (see <a href="#pattern-matching-1">Pattern Matching</a> for details):</p>
<pre><code class="language-lua">type Result = {ok: true, value: number} | {ok: false, error: string}

const result: Result = processData()

match result {
    {ok: true, value} =&gt; print("Success:", value),
    {ok: false, error} =&gt; print("Error:", error)
}
</code></pre>
<h2 id="type-guards"><a class="header" href="#type-guards">Type Guards</a></h2>
<p>Functions that narrow types:</p>
<pre><code class="language-lua">function isString(value: unknown): value is string
    return type(value) == "string"
end

const data: unknown = getData()

if isString(data) then
    -- data is string here
    print(data:upper())
end
</code></pre>
<h2 id="exhaustiveness-checking"><a class="header" href="#exhaustiveness-checking">Exhaustiveness Checking</a></h2>
<p>Ensure all cases are handled:</p>
<pre><code class="language-lua">type Status = "active" | "inactive" | "pending"

function handleStatus(status: Status): void
    if status == "active" then
        print("Active")
    elseif status == "inactive" then
        print("Inactive")
    elseif status == "pending" then
        print("Pending")
    else
        -- Exhaustive check: status is never here
        const _exhaustive: never = status
    end
end
</code></pre>
<p>If you add a new status value and forget to handle it, the compiler will catch the error.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="#functions">Functions</a> — Function declarations and types</li>
<li><a href="#pattern-matching-1">Pattern Matching</a> — Advanced pattern matching</li>
<li><a href="#type-system">Type System</a> — Type narrowing and guards</li>
</ul>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="#operators">Operators</a> — Complete operator reference</li>
<li><a href="#basics">Basics</a> — Variable declarations and types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions in LuaNext support type annotations, generics, default parameters, rest parameters, and more.</p>
<h2 id="function-declarations"><a class="header" href="#function-declarations">Function Declarations</a></h2>
<h3 id="basic-function"><a class="header" href="#basic-function">Basic Function</a></h3>
<pre><code class="language-lua">function greet(name: string): string
    return "Hello, " .. name
end

const message: string = greet("Alice")
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local function greet(name)
    return "Hello, " .. name
end

local message = greet("Alice")
</code></pre>
<h3 id="without-return-type"><a class="header" href="#without-return-type">Without Return Type</a></h3>
<p>Return type can be inferred:</p>
<pre><code class="language-lua">function add(a: number, b: number)
    return a + b  -- Return type inferred as number
end
</code></pre>
<h3 id="void-functions"><a class="header" href="#void-functions">Void Functions</a></h3>
<p>Functions that don’t return a value:</p>
<pre><code class="language-lua">function log(message: string): void
    print(message)
end
</code></pre>
<h2 id="arrow-functions"><a class="header" href="#arrow-functions">Arrow Functions</a></h2>
<p>Concise function syntax:</p>
<pre><code class="language-lua">const add = (a: number, b: number): number =&gt; a + b

const greet = (name: string): string =&gt; {
    return "Hello, " .. name
}
</code></pre>
<p>Single-expression arrows don’t need braces or <code>return</code>:</p>
<pre><code class="language-lua">const double = (x: number): number =&gt; x * 2
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local add = function(a, b)
    return a + b
end

local double = function(x)
    return x * 2
end
</code></pre>
<h2 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h2>
<h3 id="required-parameters"><a class="header" href="#required-parameters">Required Parameters</a></h3>
<pre><code class="language-lua">function greet(first: string, last: string): string
    return "Hello, " .. first .. " " .. last
end
</code></pre>
<h3 id="optional-parameters"><a class="header" href="#optional-parameters">Optional Parameters</a></h3>
<p>Use <code>?</code> for optional parameters:</p>
<pre><code class="language-lua">function greet(name: string, title?: string): string
    if title then
        return title .. " " .. name
    else
        return name
    end
end

greet("Alice")              -- OK
greet("Alice", "Dr.")       -- OK
</code></pre>
<p>Optional parameters must come after required parameters.</p>
<h3 id="default-parameters"><a class="header" href="#default-parameters">Default Parameters</a></h3>
<p>Provide default values:</p>
<pre><code class="language-lua">function greet(name: string, greeting: string = "Hello"): string
    return greeting .. ", " .. name
end

greet("Alice")              -- "Hello, Alice"
greet("Bob", "Hi")          -- "Hi, Bob"
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local function greet(name, greeting)
    if greeting == nil then
        greeting = "Hello"
    end
    return greeting .. ", " .. name
end
</code></pre>
<h3 id="rest-parameters"><a class="header" href="#rest-parameters">Rest Parameters</a></h3>
<p>Collect remaining arguments into an array:</p>
<pre><code class="language-lua">function sum(...numbers: number[]): number
    local total: number = 0
    for i, n in ipairs(numbers) do
        total = total + n
    end
    return total
end

sum(1, 2, 3, 4, 5)  -- 15
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local function sum(...)
    local numbers = {...}
    local total = 0
    for i, n in ipairs(numbers) do
        total = total + n
    end
    return total
end
</code></pre>
<h2 id="multiple-return-values"><a class="header" href="#multiple-return-values">Multiple Return Values</a></h2>
<p>Functions can return multiple values:</p>
<pre><code class="language-lua">function divmod(a: number, b: number): [number, number]
    return math.floor(a / b), a % b
end

const quotient, remainder = divmod(17, 5)  -- 3, 2
</code></pre>
<p>Named return values (documentation only):</p>
<pre><code class="language-lua">function process(data: string): [result: boolean, error: string | nil]
    if data == "" then
        return false, "Empty data"
    end
    return true, nil
end
</code></pre>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Type-safe generic functions:</p>
<pre><code class="language-lua">function identity&lt;T&gt;(value: T): T
    return value
end

const num: number = identity(42)
const str: string = identity("hello")
</code></pre>
<p>Multiple type parameters:</p>
<pre><code class="language-lua">function pair&lt;T, U&gt;(first: T, second: U): [T, U]
    return first, second
end

const result = pair("Alice", 30)  -- [string, number]
</code></pre>
<h3 id="generic-constraints"><a class="header" href="#generic-constraints">Generic Constraints</a></h3>
<p>Restrict type parameters:</p>
<pre><code class="language-lua">interface HasLength {
    length: number
}

function getLength&lt;T extends HasLength&gt;(value: T): number
    return value.length
end

getLength("hello")      -- OK (string has length)
getLength({1, 2, 3})    -- OK (array has length)
getLength(42)           -- Error: number doesn't have length
</code></pre>
<h3 id="generic-defaults"><a class="header" href="#generic-defaults">Generic Defaults</a></h3>
<p>Provide default types:</p>
<pre><code class="language-lua">function createArray&lt;T = string&gt;(size: number): T[]
    const arr: T[] = {}
    return arr
end

const strings = createArray(10)        -- string[] (default)
const numbers = createArray&lt;number&gt;(5) -- number[]
</code></pre>
<h2 id="function-types"><a class="header" href="#function-types">Function Types</a></h2>
<p>Define function signatures as types:</p>
<pre><code class="language-lua">type BinaryOp = (a: number, b: number) -&gt; number

const add: BinaryOp = (a, b) =&gt; a + b
const multiply: BinaryOp = (a, b) =&gt; a * b
</code></pre>
<p>With generics:</p>
<pre><code class="language-lua">type Mapper&lt;T, U&gt; = (value: T) -&gt; U

const toString: Mapper&lt;number, string&gt; = (n) =&gt; tostring(n)
</code></pre>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h2>
<p>Functions that take or return functions:</p>
<pre><code class="language-lua">function map&lt;T, U&gt;(array: T[], fn: (value: T) -&gt; U): U[]
    const result: U[] = {}
    for i, value in ipairs(array) do
        result[i] = fn(value)
    end
    return result
end

const numbers: number[] = {1, 2, 3, 4}
const doubled: number[] = map(numbers, (x) =&gt; x * 2)  -- {2, 4, 6, 8}
</code></pre>
<h2 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h2>
<p>Call methods with <code>:</code> (same as Lua):</p>
<pre><code class="language-lua">interface Counter {
    count: number,
    increment: (self: Counter) -&gt; void
}

const counter: Counter = {
    count = 0,
    increment = function(self)
        self.count = self.count + 1
    end
}

-- Method call syntax
counter:increment()

-- Equivalent to
counter.increment(counter)
</code></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>Functions can capture variables from outer scope:</p>
<pre><code class="language-lua">function makeCounter(): () -&gt; number
    local count: number = 0

    return function(): number
        count = count + 1
        return count
    end
end

const counter = makeCounter()
print(counter())  -- 1
print(counter())  -- 2
print(counter())  -- 3
</code></pre>
<h2 id="recursive-functions"><a class="header" href="#recursive-functions">Recursive Functions</a></h2>
<p>Functions can call themselves:</p>
<pre><code class="language-lua">function factorial(n: number): number
    if n &lt;= 1 then
        return 1
    end
    return n * factorial(n - 1)
end
</code></pre>
<p>Mutual recursion:</p>
<pre><code class="language-lua">function isEven(n: number): boolean
    if n == 0 then
        return true
    end
    return isOdd(n - 1)
end

function isOdd(n: number): boolean
    if n == 0 then
        return false
    end
    return isEven(n - 1)
end
</code></pre>
<h2 id="tail-call-optimization"><a class="header" href="#tail-call-optimization">Tail Call Optimization</a></h2>
<p>Lua optimizes tail calls. LuaNext preserves this:</p>
<pre><code class="language-lua">function factorial(n: number, acc: number = 1): number
    if n &lt;= 1 then
        return acc
    end
    return factorial(n - 1, n * acc)  -- Tail call
end
</code></pre>
<h2 id="function-overloading-type-only"><a class="header" href="#function-overloading-type-only">Function Overloading (Type-Only)</a></h2>
<p>Multiple signatures for documentation:</p>
<pre><code class="language-lua">-- Type declarations
declare function process(value: string): string
declare function process(value: number): number

-- Implementation
function process(value: string | number): string | number
    if type(value) == "string" then
        return value:upper()
    else
        return value * 2
    end
end
</code></pre>
<h2 id="throws-clause"><a class="header" href="#throws-clause">Throws Clause</a></h2>
<p>Document error types (informational):</p>
<pre><code class="language-lua">function readFile(path: string): string throws Error
    const file = io.open(path, "r")
    if not file then
        throw {message = "File not found"}
    end
    const content: string = file:read("*a")
    file:close()
    return content
end
</code></pre>
<p>The <code>throws</code> clause documents potential errors but doesn’t enforce them at compile time.</p>
<h2 id="variadic-return-types"><a class="header" href="#variadic-return-types">Variadic Return Types</a></h2>
<p>Functions with variable return values:</p>
<pre><code class="language-lua">function find&lt;T&gt;(array: T[], predicate: (value: T) -&gt; boolean): ...T | nil
    for i, value in ipairs(array) do
        if predicate(value) then
            return value, i  -- Returns T, number
        end
    end
    return nil
end
</code></pre>
<h2 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous Functions</a></h2>
<p>Functions without names:</p>
<pre><code class="language-lua">const numbers: number[] = {1, 2, 3, 4, 5}

const doubled = map(numbers, function(x: number): number
    return x * 2
end)
</code></pre>
<h2 id="immediately-invoked-function-expressions-iife"><a class="header" href="#immediately-invoked-function-expressions-iife">Immediately Invoked Function Expressions (IIFE)</a></h2>
<pre><code class="language-lua">const result: number = (function(): number
    const temp: number = calculate()
    return temp * 2
end)()
</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="#type-system">Type System</a> — Generics, unions, advanced types</li>
<li><a href="#classes">Classes</a> — Methods and constructors</li>
<li><a href="#error-handling">Error Handling</a> — Try-catch and error types</li>
</ul>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="#basics">Basics</a> — Variable declarations</li>
<li><a href="#advanced-types">Advanced Types</a> — Function type utilities</li>
<li><a href="#operators">Operators</a> — Function call operators</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-system"><a class="header" href="#type-system">Type System</a></h1>
<p>LuaNext provides a rich type system inspired by TypeScript, with unions, intersections, generics, and advanced type features.</p>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>Create named types with <code>type</code>:</p>
<pre><code class="language-lua">type UserId = number
type Status = "active" | "inactive" | "pending"
type Point = {x: number, y: number}  -- Error: use interface for table shapes

const id: UserId = 123
const status: Status = "active"
</code></pre>
<p><strong>Important:</strong> Type aliases cannot define table shapes. Use <code>interface</code> instead.</p>
<h2 id="union-types"><a class="header" href="#union-types">Union Types</a></h2>
<p>A value can be one of several types:</p>
<pre><code class="language-lua">type Result = number | string | nil

const value: Result = 42        -- OK
const text: Result = "hello"    -- OK
const none: Result = nil        -- OK
</code></pre>
<h3 id="type-narrowing-1"><a class="header" href="#type-narrowing-1">Type Narrowing</a></h3>
<p>Use conditionals to narrow union types:</p>
<pre><code class="language-lua">function process(value: string | number): void
    if type(value) == "string" then
        -- value is string here
        print(value:upper())
    else
        -- value is number here
        print(value * 2)
    end
end
</code></pre>
<p>Common type guards:</p>
<ul>
<li><code>type(x) == "string"</code> — Narrows to string</li>
<li><code>type(x) == "number"</code> — Narrows to number</li>
<li><code>type(x) == "table"</code> — Narrows to table</li>
<li><code>x ~= nil</code> — Removes nil from union</li>
</ul>
<h3 id="discriminated-unions"><a class="header" href="#discriminated-unions">Discriminated Unions</a></h3>
<p>Use a common field to discriminate:</p>
<pre><code class="language-lua">type Shape =
    | {kind: "circle", radius: number}
    | {kind: "rectangle", width: number, height: number}

function area(shape: Shape): number
    if shape.kind == "circle" then
        return math.pi * shape.radius * shape.radius
    else
        return shape.width * shape.height
    end
end
</code></pre>
<h2 id="intersection-types"><a class="header" href="#intersection-types">Intersection Types</a></h2>
<p>Combine multiple types:</p>
<pre><code class="language-lua">interface Named {
    name: string
}

interface Aged {
    age: number
}

type Person = Named &amp; Aged

const person: Person = {
    name = "Alice",
    age = 30
}
</code></pre>
<p><strong>Note:</strong> Intersections work for combining interfaces. Type aliases cannot use <code>&amp;</code> directly.</p>
<h2 id="literal-types-1"><a class="header" href="#literal-types-1">Literal Types</a></h2>
<p>Values as types:</p>
<pre><code class="language-lua">type Direction = "north" | "south" | "east" | "west"
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6
type Enabled = true

const dir: Direction = "north"  -- OK
const roll: DiceRoll = 3        -- OK
const flag: Enabled = true      -- OK
</code></pre>
<h2 id="nullable-types-1"><a class="header" href="#nullable-types-1">Nullable Types</a></h2>
<p>Explicitly allow nil:</p>
<pre><code class="language-lua">type MaybeString = string | nil

const value: MaybeString = "hello"
const none: MaybeString = nil
</code></pre>
<p>Shorthand (if available):</p>
<pre><code class="language-lua">type MaybeString = string?
</code></pre>
<h2 id="generics-1"><a class="header" href="#generics-1">Generics</a></h2>
<p>Type-safe parameterized types:</p>
<pre><code class="language-lua">type Box&lt;T&gt; = {
    value: T,
    get: () -&gt; T,
    set: (value: T) -&gt; void
}

const numberBox: Box&lt;number&gt; = {
    value = 42,
    get = function() return 42 end,
    set = function(v) end
}
</code></pre>
<h3 id="generic-constraints-1"><a class="header" href="#generic-constraints-1">Generic Constraints</a></h3>
<p>Restrict type parameters:</p>
<pre><code class="language-lua">interface HasLength {
    length: number
}

type LengthGetter&lt;T extends HasLength&gt; = (value: T) -&gt; number

const getLength: LengthGetter&lt;string&gt; = (s) =&gt; s.length
</code></pre>
<h3 id="multiple-type-parameters"><a class="header" href="#multiple-type-parameters">Multiple Type Parameters</a></h3>
<pre><code class="language-lua">type Pair&lt;K, V&gt; = {
    key: K,
    value: V
}

const entry: Pair&lt;string, number&gt; = {
    key = "count",
    value = 10
}
</code></pre>
<h3 id="generic-defaults-1"><a class="header" href="#generic-defaults-1">Generic Defaults</a></h3>
<pre><code class="language-lua">type Result&lt;T = string, E = Error&gt; =
    | {ok: true, value: T}
    | {ok: false, error: E}

const success: Result = {ok = true, value = "done"}  -- Uses defaults
const failure: Result&lt;number&gt; = {ok = false, error = {message = "failed"}}
</code></pre>
<h2 id="type-inference-1"><a class="header" href="#type-inference-1">Type Inference</a></h2>
<p>LuaNext infers types in many contexts:</p>
<pre><code class="language-lua">-- Variable initialization
const x = 42               -- number
const name = "Alice"       -- string
const items = {1, 2, 3}    -- number[]

-- Function returns
function double(x: number)
    return x * 2  -- Return type inferred as number
end

-- Generic instantiation
function identity&lt;T&gt;(x: T): T
    return x
end

const num = identity(42)  -- T inferred as number
</code></pre>
<h2 id="type-assertions-1"><a class="header" href="#type-assertions-1">Type Assertions</a></h2>
<p>Override type inference with <code>as</code>:</p>
<pre><code class="language-lua">const data: unknown = getData()
const user = data as {name: string, age: number}

print(user.name)  -- OK (assumes data is the right shape)
</code></pre>
<p><strong>Warning:</strong> Type assertions bypass type checking. Use with caution.</p>
<h2 id="type-queries"><a class="header" href="#type-queries">Type Queries</a></h2>
<p>Get the type of a value with <code>typeof</code>:</p>
<pre><code class="language-lua">const config = {
    host = "localhost",
    port = 8080
}

type Config = typeof config  -- {host: string, port: number}
</code></pre>
<h2 id="index-access-types"><a class="header" href="#index-access-types">Index Access Types</a></h2>
<p>Extract property types:</p>
<pre><code class="language-lua">interface User {
    id: number,
    name: string,
    email: string
}

type UserId = User["id"]        -- number
type UserField = User["name" | "email"]  -- string
</code></pre>
<h2 id="keyof-types"><a class="header" href="#keyof-types">Keyof Types</a></h2>
<p>Get all keys as a union:</p>
<pre><code class="language-lua">interface User {
    id: number,
    name: string,
    email: string
}

type UserKey = keyof User  -- "id" | "name" | "email"
</code></pre>
<h2 id="conditional-types"><a class="header" href="#conditional-types">Conditional Types</a></h2>
<p>Types that depend on conditions:</p>
<pre><code class="language-lua">type IsString&lt;T&gt; = T extends string ? true : false

type A = IsString&lt;string&gt;  -- true
type B = IsString&lt;number&gt;  -- false
</code></pre>
<p>More practical example:</p>
<pre><code class="language-lua">type Awaited&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T

type Value = Awaited&lt;Promise&lt;number&gt;&gt;  -- number
</code></pre>
<h2 id="mapped-types"><a class="header" href="#mapped-types">Mapped Types</a></h2>
<p>Transform object types:</p>
<pre><code class="language-lua">type Readonly&lt;T&gt; = {
    readonly [K in keyof T]: T[K]
}

interface User {
    name: string,
    age: number
}

type ReadonlyUser = Readonly&lt;User&gt;
-- {readonly name: string, readonly age: number}
</code></pre>
<p>Add or remove modifiers:</p>
<pre><code class="language-lua">type Mutable&lt;T&gt; = {
    -readonly [K in keyof T]: T[K]
}

type Optional&lt;T&gt; = {
    [K in keyof T]?: T[K]
}

type Required&lt;T&gt; = {
    [K in keyof T]-?: T[K]
}
</code></pre>
<h2 id="template-literal-types"><a class="header" href="#template-literal-types">Template Literal Types</a></h2>
<p>String types with interpolation:</p>
<pre><code class="language-lua">type EventName = "click" | "focus" | "blur"
type Handler = `on${Capitalize&lt;EventName&gt;}`  -- "onClick" | "onFocus" | "onBlur"
</code></pre>
<h2 id="type-predicates"><a class="header" href="#type-predicates">Type Predicates</a></h2>
<p>Functions that narrow types:</p>
<pre><code class="language-lua">function isString(value: unknown): value is string
    return type(value) == "string"
end

const data: unknown = getData()

if isString(data) then
    -- data is string here
    print(data:upper())
end
</code></pre>
<h2 id="variadic-types"><a class="header" href="#variadic-types">Variadic Types</a></h2>
<p>Rest elements in tuples:</p>
<pre><code class="language-lua">type Nums = [number, ...number[]]  -- At least one number

const valid: Nums = {1, 2, 3, 4}   -- OK
const invalid: Nums = {}           -- Error: needs at least one
</code></pre>
<h2 id="infer-keyword"><a class="header" href="#infer-keyword">Infer Keyword</a></h2>
<p>Extract types in conditional types:</p>
<pre><code class="language-lua">type ReturnType&lt;T&gt; = T extends (...args: any[]) -&gt; infer R ? R : never

function getUser(): {name: string, age: number}
    return {name = "Alice", age = 30}
end

type User = ReturnType&lt;typeof getUser&gt;  -- {name: string, age: number}
</code></pre>
<h2 id="never-type"><a class="header" href="#never-type">Never Type</a></h2>
<p>Type for impossible values:</p>
<pre><code class="language-lua">type Result = "success" | "error"

function handle(result: Result): void
    if result == "success" then
        print("OK")
    elseif result == "error" then
        print("Failed")
    else
        -- result is never here
        const _exhaustive: never = result
    end
end
</code></pre>
<h2 id="unknown-type"><a class="header" href="#unknown-type">Unknown Type</a></h2>
<p>Type-safe alternative to <code>any</code>:</p>
<pre><code class="language-lua">const data: unknown = getExternalData()

-- Error: Cannot use unknown directly
print(data.name)  -- ❌

-- OK: Narrow the type first
if type(data) == "table" then
    print(data.name)  -- ✅
end
</code></pre>
<h2 id="type-compatibility"><a class="header" href="#type-compatibility">Type Compatibility</a></h2>
<p>LuaNext uses structural typing:</p>
<pre><code class="language-lua">interface Point {
    x: number,
    y: number
}

interface Vector {
    x: number,
    y: number
}

const p: Point = {x = 1, y = 2}
const v: Vector = p  -- OK: shapes match
</code></pre>
<p>Excess properties are allowed in assignments:</p>
<pre><code class="language-lua">interface User {
    name: string
}

const user: User = {
    name = "Alice",
    age = 30  -- OK: excess property ignored
}
</code></pre>
<h2 id="type-narrowing-patterns"><a class="header" href="#type-narrowing-patterns">Type Narrowing Patterns</a></h2>
<h3 id="truthiness"><a class="header" href="#truthiness">Truthiness</a></h3>
<pre><code class="language-lua">function process(value: string | nil): void
    if value then
        -- value is string here
        print(value:upper())
    end
end
</code></pre>
<h3 id="equality"><a class="header" href="#equality">Equality</a></h3>
<pre><code class="language-lua">function compare(x: string | number, y: string | number): void
    if x == y then
        -- Both have the same type here (string | number, narrowed to intersection)
    end
end
</code></pre>
<h3 id="instanceof"><a class="header" href="#instanceof"><code>instanceof</code></a></h3>
<pre><code class="language-lua">class Animal {}
class Dog extends Animal {}

function handle(animal: Animal): void
    if animal instanceof Dog then
        -- animal is Dog here
    end
end
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><a href="#interfaces">Interfaces</a> — Define table shapes</li>
<li><a href="#advanced-types">Advanced Types</a> — Conditional, mapped, template literal types</li>
<li><a href="#utility-types-reference">Utility Types</a> — Built-in type helpers</li>
</ul>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="#basics">Basics</a> — Primitive types</li>
<li><a href="#functions">Functions</a> — Generic functions</li>
<li><a href="#classes">Classes</a> — Generic classes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>LuaNext provides object-oriented programming features through classes with full type safety. Classes support inheritance, interfaces, access modifiers, operator overloading, and more.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<pre><code class="language-lua">[abstract | final] class ClassName[&lt;TypeParams&gt;][(ConstructorParams)] [extends ParentClass] [implements Interface1, Interface2]
    -- Properties
    [access] [static] [readonly] propertyName: Type [= initializer]

    -- Constructor
    constructor(parameters)
        -- initialization
    end

    -- Methods
    [access] [static] [abstract | final] [override] function methodName(parameters): ReturnType
        -- body
    end

    -- Getters and Setters
    [access] [static] get propertyName(): Type
        -- body
    end

    [access] [static] set propertyName(value: Type)
        -- body
    end

    -- Operator Overloading
    operator [+|-|*|/|etc](parameters): ReturnType
        -- body
    end
end
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="basic-class"><a class="header" href="#basic-class">Basic Class</a></h3>
<pre><code class="language-lua">class Person
    name: string
    age: number

    constructor(name: string, age: number)
        self.name = name
        self.age = age
    end

    function greet(): string
        return `Hello, I'm ${self.name} and I'm ${self.age} years old.`
    end
end

const alice = Person.new("Alice", 30)
print(alice:greet())  -- Hello, I'm Alice and I'm 30 years old.
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local Person = {}
Person.__index = Person

function Person.new(name, age)
    local self = setmetatable({}, Person)
    self.name = name
    self.age = age
    return self
end

function Person:greet()
    return "Hello, I'm " .. tostring(self.name) .. " and I'm " .. tostring(self.age) .. " years old."
end

local alice = Person.new("Alice", 30)
print(alice:greet())
</code></pre>
<h3 id="primary-constructor"><a class="header" href="#primary-constructor">Primary Constructor</a></h3>
<p>Primary constructors provide a compact syntax for declaring properties:</p>
<pre><code class="language-lua">class Point(public x: number, public y: number)
    function distance(): number
        return math.sqrt(self.x * self.x + self.y * self.y)
    end
end

const p = Point.new(3, 4)
print(p:distance())  -- 5.0
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local Point = {}
Point.__index = Point

function Point.new(x, y)
    local self = setmetatable({}, Point)
    self.x = x
    self.y = y
    return self
end

function Point:distance()
    return math.sqrt(self.x * self.x + self.y * self.y)
end

local p = Point.new(3, 4)
print(p:distance())
</code></pre>
<h3 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h3>
<p>LuaNext supports three access modifiers:</p>
<ul>
<li><code>public</code> — Accessible everywhere (default)</li>
<li><code>private</code> — Accessible only within the class</li>
<li><code>protected</code> — Accessible within the class and subclasses</li>
</ul>
<pre><code class="language-lua">class BankAccount(private balance: number)
    public function deposit(amount: number): void
        self.balance = self.balance + amount
    end

    public function getBalance(): number
        return self.balance
    end

    private function validateAmount(amount: number): boolean
        return amount &gt; 0
    end
end

const account = BankAccount.new(100)
account:deposit(50)
print(account:getBalance())  -- 150

-- Error: Cannot access private member
-- print(account.balance)  -- ❌ Type error
</code></pre>
<h3 id="static-members"><a class="header" href="#static-members">Static Members</a></h3>
<p>Static members belong to the class itself, not instances:</p>
<pre><code class="language-lua">class MathUtils
    static PI: number = 3.14159

    static function square(x: number): number
        return x * x
    end

    static function circleArea(radius: number): number
        return MathUtils.PI * radius * radius
    end
end

print(MathUtils.square(5))          -- 25
print(MathUtils.circleArea(10))     -- 314.159
</code></pre>
<h3 id="readonly-properties"><a class="header" href="#readonly-properties">Readonly Properties</a></h3>
<p>Readonly properties can only be assigned in the constructor:</p>
<pre><code class="language-lua">class User(public readonly id: string, public name: string)
    constructor(id: string, name: string)
        self.id = id
        self.name = name
    end

    function rename(newName: string): void
        self.name = newName  -- ✅ OK

        -- Error: Cannot assign to readonly property
        -- self.id = "new-id"  -- ❌ Type error
    end
end
</code></pre>
<h3 id="getters-and-setters"><a class="header" href="#getters-and-setters">Getters and Setters</a></h3>
<p>Computed properties with custom logic:</p>
<pre><code class="language-lua">class Temperature
    private celsius: number

    constructor(celsius: number)
        self.celsius = celsius
    end

    get fahrenheit(): number
        return self.celsius * 9 / 5 + 32
    end

    set fahrenheit(value: number)
        self.celsius = (value - 32) * 5 / 9
    end
end

const temp = Temperature.new(0)
print(temp.fahrenheit)  -- 32
temp.fahrenheit = 100
print(temp.celsius)     -- 37.777...
</code></pre>
<h3 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h3>
<p>Classes can extend other classes:</p>
<pre><code class="language-lua">class Animal(public name: string)
    function speak(): string
        return `${self.name} makes a sound`
    end
end

class Dog extends Animal(name)
    private breed: string

    constructor(name: string, breed: string)
        super(name)  -- Call parent constructor
        self.breed = breed
    end

    override function speak(): string
        return `${self.name} barks`
    end

    function getBreed(): string
        return self.breed
    end
end

const dog = Dog.new("Rex", "Labrador")
print(dog:speak())      -- Rex barks
print(dog:getBreed())   -- Labrador
</code></pre>
<h3 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h3>
<p>Abstract classes cannot be instantiated directly:</p>
<pre><code class="language-lua">abstract class Shape
    abstract function area(): number
    abstract function perimeter(): number

    function describe(): string
        return `Area: ${self:area()}, Perimeter: ${self:perimeter()}`
    end
end

class Circle extends Shape(private radius: number)
    override function area(): number
        return 3.14159 * self.radius * self.radius
    end

    override function perimeter(): number
        return 2 * 3.14159 * self.radius
    end
end

-- Error: Cannot instantiate abstract class
-- const shape = Shape.new()  -- ❌ Type error

const circle = Circle.new(5)
print(circle:describe())  -- Area: 78.53975, Perimeter: 31.4159
</code></pre>
<h3 id="final-classes-and-methods"><a class="header" href="#final-classes-and-methods">Final Classes and Methods</a></h3>
<p>Final classes cannot be extended, final methods cannot be overridden:</p>
<pre><code class="language-lua">final class String
    -- Cannot be extended
end

class Base
    final function important(): void
        print("Important logic")
    end
end

class Derived extends Base
    -- Error: Cannot override final method
    -- override function important(): void  -- ❌ Type error
    --     print("Modified")
    -- end
end
</code></pre>
<h3 id="implementing-interfaces"><a class="header" href="#implementing-interfaces">Implementing Interfaces</a></h3>
<p>Classes can implement one or more interfaces:</p>
<pre><code class="language-lua">interface Serializable
    function serialize(): string
end

interface Comparable&lt;T&gt;
    function compareTo(other: T): number
end

class User implements Serializable, Comparable&lt;User&gt;
    name: string
    age: number

    constructor(name: string, age: number)
        self.name = name
        self.age = age
    end

    function serialize(): string
        return `{"name":"${self.name}","age":${self.age}}`
    end

    function compareTo(other: User): number
        return self.age - other.age
    end
end
</code></pre>
<h3 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h3>
<p>LuaNext supports overloading 24 operators:</p>
<p><strong>Arithmetic:</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code>, <code>//</code> (floor divide)</p>
<p><strong>Comparison:</strong> <code>==</code>, <code>~=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></p>
<p><strong>Bitwise:</strong> <code>&amp;</code>, <code>|</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></p>
<p><strong>Special:</strong> <code>..</code> (concat), <code>#</code> (length), <code>[]</code> (index), <code>[]=</code> (newindex), <code>()</code> (call)</p>
<p><strong>Unary:</strong> <code>-</code> (negate)</p>
<pre><code class="language-lua">class Vector(public x: number, public y: number)
    operator +(other: Vector): Vector
        return Vector.new(self.x + other.x, self.y + other.y)
    end

    operator *(scalar: number): Vector
        return Vector.new(self.x * scalar, self.y * scalar)
    end

    operator ==(other: Vector): boolean
        return self.x == other.x and self.y == other.y
    end

    operator #(): number
        return math.sqrt(self.x * self.x + self.y * self.y)
    end

    operator ...(other: Vector): string
        return `(${self.x}, ${self.y}) + (${other.x}, ${other.y})`
    end
end

const v1 = Vector.new(1, 2)
const v2 = Vector.new(3, 4)
const v3 = v1 + v2              -- Vector(4, 6)
const v4 = v1 * 2               -- Vector(2, 4)
const equal = v1 == v2          -- false
const length = #v1              -- 2.236...
const str = v1 .. v2            -- "(1, 2) + (3, 4)"
</code></pre>
<h3 id="generics-2"><a class="header" href="#generics-2">Generics</a></h3>
<p>Classes can be generic over type parameters:</p>
<pre><code class="language-lua">class Box&lt;T&gt;
    private value: T

    constructor(value: T)
        self.value = value
    end

    function get(): T
        return self.value
    end

    function set(value: T): void
        self.value = value
    end
end

const numberBox = Box&lt;number&gt;.new(42)
const stringBox = Box&lt;string&gt;.new("hello")

print(numberBox:get())  -- 42
print(stringBox:get())  -- hello
</code></pre>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<h3 id="constructor-behavior"><a class="header" href="#constructor-behavior">Constructor Behavior</a></h3>
<ul>
<li>Classes have an implicit <code>new</code> static method that creates instances</li>
<li>The <code>constructor</code> method is called after the instance is created</li>
<li>Primary constructor parameters automatically become properties</li>
<li>Parent constructors must be called with <code>super()</code> in derived classes</li>
</ul>
<h3 id="access-modifier-enforcement"><a class="header" href="#access-modifier-enforcement">Access Modifier Enforcement</a></h3>
<p>Access modifiers are enforced at compile time:</p>
<ul>
<li><code>private</code> members are not accessible outside the class definition</li>
<li><code>protected</code> members are accessible in derived classes</li>
<li><code>public</code> members are accessible everywhere</li>
</ul>
<p>At runtime, all members are public (Lua limitation), but the type checker prevents incorrect access.</p>
<h3 id="method-resolution"><a class="header" href="#method-resolution">Method Resolution</a></h3>
<ul>
<li>Methods are stored in the class’s metatable (<code>__index</code>)</li>
<li>Static methods are stored directly on the class table</li>
<li>Method calls use <code>:</code> syntax (<code>obj:method()</code>) for automatic <code>self</code> passing</li>
</ul>
<h3 id="operator-overloading-mapping"><a class="header" href="#operator-overloading-mapping">Operator Overloading Mapping</a></h3>
<p>LuaNext operators map to Lua metamethods:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>LuaNext</th><th>Lua Metamethod</th></tr>
</thead>
<tbody>
<tr><td><code>+</code></td><td><code>__add</code></td></tr>
<tr><td><code>-</code></td><td><code>__sub</code></td></tr>
<tr><td><code>*</code></td><td><code>__mul</code></td></tr>
<tr><td><code>/</code></td><td><code>__div</code></td></tr>
<tr><td><code>%</code></td><td><code>__mod</code></td></tr>
<tr><td><code>^</code></td><td><code>__pow</code></td></tr>
<tr><td><code>//</code></td><td><code>__idiv</code></td></tr>
<tr><td><code>==</code></td><td><code>__eq</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>__lt</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>__le</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>__band</code></td></tr>
<tr><td>`</td><td>`</td></tr>
<tr><td><code>~</code></td><td><code>__bxor</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>__shl</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>__shr</code></td></tr>
<tr><td><code>..</code></td><td><code>__concat</code></td></tr>
<tr><td><code>#</code></td><td><code>__len</code></td></tr>
<tr><td><code>[]</code></td><td><code>__index</code></td></tr>
<tr><td><code>[]=</code></td><td><code>__newindex</code></td></tr>
<tr><td><code>()</code></td><td><code>__call</code></td></tr>
<tr><td><code>-</code> (unary)</td><td><code>__unm</code></td></tr>
</tbody>
</table>
</div>
<h3 id="abstract-class-checks"><a class="header" href="#abstract-class-checks">Abstract Class Checks</a></h3>
<p>Abstract classes and methods are checked at compile time:</p>
<ul>
<li>Cannot instantiate abstract classes</li>
<li>Must implement all abstract methods in concrete subclasses</li>
<li>Abstract methods cannot have bodies</li>
</ul>
<h3 id="multiple-inheritance"><a class="header" href="#multiple-inheritance">Multiple Inheritance</a></h3>
<p>LuaNext does not support multiple inheritance (extending multiple classes), but supports implementing multiple interfaces.</p>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="#interfaces">Interfaces</a> — Defining contracts for classes</li>
<li><a href="#enums">Enums</a> — Rich enums with fields and methods</li>
<li><a href="#type-system">Type System</a> — Generics and constraints</li>
<li><a href="#decorators">Decorators</a> — Annotating classes and members</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>Interfaces define the shape of objects without providing implementation. They enable structural typing, contracts for classes, and reusable type definitions.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<pre><code class="language-lua">interface InterfaceName[&lt;TypeParams&gt;] [extends Interface1, Interface2]
    -- Property signatures
    [readonly] propertyName[?]: Type

    -- Method signatures
    methodName[&lt;TypeParams&gt;](parameters): ReturnType

    -- Index signatures
    [key: string | number]: ValueType
end
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="basic-interface"><a class="header" href="#basic-interface">Basic Interface</a></h3>
<pre><code class="language-lua">interface Point
    x: number
    y: number
end

function distance(p1: Point, p2: Point): number
    const dx = p2.x - p1.x
    const dy = p2.y - p1.y
    return math.sqrt(dx * dx + dy * dy)
end

const p1: Point = {x = 0, y = 0}
const p2: Point = {x = 3, y = 4}
print(distance(p1, p2))  -- 5.0
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local function distance(p1, p2)
    local dx = p2.x - p1.x
    local dy = p2.y - p1.y
    return math.sqrt(dx * dx + dy * dy)
end

local p1 = {x = 0, y = 0}
local p2 = {x = 3, y = 4}
print(distance(p1, p2))
</code></pre>
<h3 id="method-signatures"><a class="header" href="#method-signatures">Method Signatures</a></h3>
<p>Interfaces can declare method signatures:</p>
<pre><code class="language-lua">interface Logger
    function log(message: string): void
    function warn(message: string): void
    function error(message: string): void
end

function setupLogging(logger: Logger): void
    logger:log("System started")
    logger:warn("Low memory")
    logger:error("Fatal error")
end

-- Implementing with a table
const consoleLogger: Logger = {
    log = function(self, message)
        print("[LOG] " .. message)
    end,
    warn = function(self, message)
        print("[WARN] " .. message)
    end,
    error = function(self, message)
        print("[ERROR] " .. message)
    end
}

setupLogging(consoleLogger)
</code></pre>
<h3 id="optional-properties"><a class="header" href="#optional-properties">Optional Properties</a></h3>
<p>Properties marked with <code>?</code> are optional:</p>
<pre><code class="language-lua">interface Config
    host: string
    port: number
    ssl?: boolean
    timeout?: number
end

const config1: Config = {
    host = "localhost",
    port = 8080
}

const config2: Config = {
    host = "example.com",
    port = 443,
    ssl = true,
    timeout = 5000
}
</code></pre>
<h3 id="readonly-properties-1"><a class="header" href="#readonly-properties-1">Readonly Properties</a></h3>
<p>Readonly properties cannot be reassigned:</p>
<pre><code class="language-lua">interface User
    readonly id: string
    name: string
    email: string
end

const user: User = {
    id = "user-123",
    name = "Alice",
    email = "alice@example.com"
}

user.name = "Bob"  -- ✅ OK

-- Error: Cannot assign to readonly property
-- user.id = "user-456"  -- ❌ Type error
</code></pre>
<h3 id="index-signatures"><a class="header" href="#index-signatures">Index Signatures</a></h3>
<p>Index signatures allow dynamic property access:</p>
<pre><code class="language-lua">interface Dictionary
    [key: string]: number
end

const scores: Dictionary = {
    alice = 95,
    bob = 87,
    charlie = 92
}

print(scores.alice)       -- 95
print(scores["bob"])      -- 87
scores.diana = 89         -- ✅ OK
</code></pre>
<p>Array-like interfaces use number index:</p>
<pre><code class="language-lua">interface NumberArray
    [index: number]: number
    length: number
end

const numbers: NumberArray = {1, 2, 3, 4, 5, length = 5}
print(numbers[1])  -- 1
print(numbers.length)  -- 5
</code></pre>
<h3 id="extending-interfaces"><a class="header" href="#extending-interfaces">Extending Interfaces</a></h3>
<p>Interfaces can extend other interfaces:</p>
<pre><code class="language-lua">interface Named
    name: string
end

interface Aged
    age: number
end

interface Person extends Named, Aged
    email: string
end

const person: Person = {
    name = "Alice",
    age = 30,
    email = "alice@example.com"
}
</code></pre>
<h3 id="generic-interfaces"><a class="header" href="#generic-interfaces">Generic Interfaces</a></h3>
<p>Interfaces can be parameterized with type variables:</p>
<pre><code class="language-lua">interface Box&lt;T&gt;
    value: T
    function get(): T
    function set(value: T): void
end

const numberBox: Box&lt;number&gt; = {
    value = 42,
    get = function(self)
        return self.value
    end,
    set = function(self, value)
        self.value = value
    end
}

const stringBox: Box&lt;string&gt; = {
    value = "hello",
    get = function(self)
        return self.value
    end,
    set = function(self, value)
        self.value = value
    end
}
</code></pre>
<h3 id="implementing-interfaces-in-classes"><a class="header" href="#implementing-interfaces-in-classes">Implementing Interfaces in Classes</a></h3>
<p>Classes can implement interfaces:</p>
<pre><code class="language-lua">interface Drawable
    function draw(): void
end

interface Resizable
    function resize(width: number, height: number): void
end

class Rectangle implements Drawable, Resizable
    private width: number
    private height: number

    constructor(width: number, height: number)
        self.width = width
        self.height = height
    end

    function draw(): void
        print(`Drawing rectangle: ${self.width}x${self.height}`)
    end

    function resize(width: number, height: number): void
        self.width = width
        self.height = height
    end
end

const rect = Rectangle.new(100, 50)
rect:draw()           -- Drawing rectangle: 100x50
rect:resize(200, 100)
rect:draw()           -- Drawing rectangle: 200x100
</code></pre>
<h3 id="function-types-in-interfaces"><a class="header" href="#function-types-in-interfaces">Function Types in Interfaces</a></h3>
<p>Interfaces can define function types:</p>
<pre><code class="language-lua">interface Comparator&lt;T&gt;
    compare: (a: T, b: T) =&gt; number
end

const numberComparator: Comparator&lt;number&gt; = {
    compare = function(a, b)
        return a - b
    end
}

function sort&lt;T&gt;(array: T[], comparator: Comparator&lt;T&gt;): T[]
    -- Sort implementation
    return array
end

const numbers: number[] = {5, 2, 8, 1, 9}
sort(numbers, numberComparator)
</code></pre>
<h3 id="default-implementations"><a class="header" href="#default-implementations">Default Implementations</a></h3>
<p>Interfaces can provide default method implementations:</p>
<pre><code class="language-lua">interface Logger
    function log(message: string): void
        print("[LOG] " .. message)
    end

    function warn(message: string): void
        print("[WARN] " .. message)
    end

    function error(message: string): void
        self:log("ERROR: " .. message)
    end
end

-- Use default implementations
const logger: Logger = {}
logger:log("Hello")        -- [LOG] Hello
logger:warn("Warning")     -- [WARN] Warning
logger:error("Failed")     -- [LOG] ERROR: Failed

-- Override specific methods
const customLogger: Logger = {
    log = function(self, message)
        print("[CUSTOM] " .. message)
    end
}
customLogger:log("Test")    -- [CUSTOM] Test
customLogger:error("Fail")  -- [CUSTOM] ERROR: Fail
</code></pre>
<h3 id="hybrid-types"><a class="header" href="#hybrid-types">Hybrid Types</a></h3>
<p>Interfaces can be both callable and have properties:</p>
<pre><code class="language-lua">interface Counter
    count: number
    function increment(): void
    () =&gt; number  -- Call signature
end

const counter: Counter = setmetatable({
    count = 0,
    increment = function(self)
        self.count = self.count + 1
    end
}, {
    __call = function(self)
        return self.count
    end
})

counter:increment()
counter:increment()
print(counter())  -- 2 (callable)
print(counter.count)  -- 2 (property access)
</code></pre>
<h3 id="structural-typing"><a class="header" href="#structural-typing">Structural Typing</a></h3>
<p>LuaNext uses structural typing—any object matching the interface shape is compatible:</p>
<pre><code class="language-lua">interface Point
    x: number
    y: number
end

function printPoint(p: Point): void
    print(`(${p.x}, ${p.y})`)
end

-- All of these work (structural compatibility)
printPoint({x = 1, y = 2})
printPoint({x = 3, y = 4, z = 5})  -- Extra property OK
</code></pre>
<h3 id="intersection-types-1"><a class="header" href="#intersection-types-1">Intersection Types</a></h3>
<p>Combine multiple interfaces using <code>&amp;</code>:</p>
<pre><code class="language-lua">interface Named
    name: string
end

interface Aged
    age: number
end

type Person = Named &amp; Aged

const person: Person = {
    name = "Alice",
    age = 30
}
</code></pre>
<h3 id="excess-property-checking"><a class="header" href="#excess-property-checking">Excess Property Checking</a></h3>
<p>Direct object literals are strictly checked:</p>
<pre><code class="language-lua">interface Point
    x: number
    y: number
end

-- Error: Object literal may only specify known properties
-- const p: Point = {x = 1, y = 2, z = 3}  -- ❌ Type error

-- But this works (assigned to variable first)
const obj = {x = 1, y = 2, z = 3}
const p: Point = obj  -- ✅ OK (structural typing)
</code></pre>
<h2 id="details-1"><a class="header" href="#details-1">Details</a></h2>
<h3 id="interface-merging"><a class="header" href="#interface-merging">Interface Merging</a></h3>
<p>Multiple interface declarations with the same name merge:</p>
<pre><code class="language-lua">interface User
    name: string
end

interface User
    email: string
end

-- Merged: User has both name and email
const user: User = {
    name = "Alice",
    email = "alice@example.com"
}
</code></pre>
<h3 id="method-vs-function-property"><a class="header" href="#method-vs-function-property">Method vs Function Property</a></h3>
<p>Two syntaxes for methods:</p>
<pre><code class="language-lua">interface Example
    -- Method signature (preferred for methods)
    function greet(name: string): string

    -- Function property signature (preferred for callbacks)
    onComplete: (result: string) =&gt; void
end
</code></pre>
<p>Both are functionally equivalent, but the convention is:</p>
<ul>
<li>Use <code>function</code> for object methods called with <code>:</code></li>
<li>Use <code>=&gt;</code> for function properties/callbacks</li>
</ul>
<h3 id="index-signature-restrictions"><a class="header" href="#index-signature-restrictions">Index Signature Restrictions</a></h3>
<ul>
<li>Only <code>string</code> and <code>number</code> are valid index key types</li>
<li>Cannot have both string and number index signatures with different value types</li>
<li>Named properties must be compatible with index signature:</li>
</ul>
<pre><code class="language-lua">interface StringMap
    [key: string]: string
    count: number  -- ❌ Error: 'number' not assignable to 'string'
end
</code></pre>
<h3 id="generic-constraints-2"><a class="header" href="#generic-constraints-2">Generic Constraints</a></h3>
<p>Generic interfaces can have type constraints:</p>
<pre><code class="language-lua">interface Comparable&lt;T extends {id: number}&gt;
    function compareTo(other: T): number
end

interface User
    id: number
    name: string
end

const userComparator: Comparable&lt;User&gt; = {
    compareTo = function(self, other)
        return self.id - other.id
    end
}
</code></pre>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="#classes">Classes</a> — Implementing interfaces with classes</li>
<li><a href="#type-system">Type System</a> — Advanced type features</li>
<li><a href="#advanced-types">Advanced Types</a> — Conditional and mapped types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>LuaNext provides rich enums that go beyond simple value sets. Enums can have string or number values, fields, constructors, methods, and can implement interfaces.</p>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<pre><code class="language-lua">enum EnumName [implements Interface1, Interface2]
    -- Simple members
    Member1,
    Member2 = value,

    -- Fields (shared across all members)
    fieldName: Type,

    -- Constructor
    constructor(parameters)
        -- initialization logic for fields
    end

    -- Methods
    function methodName(parameters): ReturnType
        -- body
    end
end
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="basic-enum"><a class="header" href="#basic-enum">Basic Enum</a></h3>
<p>Simple enums without explicit values:</p>
<pre><code class="language-lua">enum Status
    Pending,
    Active,
    Inactive
end

const currentStatus: Status = Status.Active

if currentStatus == Status.Active then
    print("System is active")
end
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local Status = {
    Pending = "Pending",
    Active = "Active",
    Inactive = "Inactive"
}

local currentStatus = Status.Active

if currentStatus == Status.Active then
    print("System is active")
end
</code></pre>
<h3 id="string-enums"><a class="header" href="#string-enums">String Enums</a></h3>
<p>Enums with explicit string values:</p>
<pre><code class="language-lua">enum Color
    Red = "red",
    Green = "green",
    Blue = "blue"
end

const primary: Color = Color.Red
print(primary)  -- "red"
</code></pre>
<p>###Number Enums</p>
<p>Enums with explicit number values:</p>
<pre><code class="language-lua">enum HttpStatus
    OK = 200,
    NotFound = 404,
    InternalError = 500
end

function handleResponse(status: HttpStatus): string
    if status == HttpStatus.OK then
        return "Success"
    elseif status == HttpStatus.NotFound then
        return "Not found"
    else
        return "Error"
    end
end
</code></pre>
<p>Auto-incrementing number enums:</p>
<pre><code class="language-lua">enum Priority
    Low = 1,
    Medium,   -- 2
    High,     -- 3
    Critical  -- 4
end
</code></pre>
<h3 id="rich-enums-with-fields"><a class="header" href="#rich-enums-with-fields">Rich Enums with Fields</a></h3>
<p>Enums can have fields shared across all members:</p>
<pre><code class="language-lua">enum Direction
    North,
    East,
    South,
    West,

    -- Fields
    angle: number,

    -- Constructor initializes fields based on enum value
    constructor()
        if self == Direction.North then
            self.angle = 0
        elseif self == Direction.East then
            self.angle = 90
        elseif self == Direction.South then
            self.angle = 180
        elseif self == Direction.West then
            self.angle = 270
        end
    end
end

const dir = Direction.East
print(dir.angle)  -- 90
</code></pre>
<h3 id="enums-with-methods"><a class="header" href="#enums-with-methods">Enums with Methods</a></h3>
<p>Enums can have methods:</p>
<pre><code class="language-lua">enum Status
    Pending,
    Active,
    Completed,

    function isActive(): boolean
        return self == Status.Active
    end

    function canTransitionTo(other: Status): boolean
        if self == Status.Pending then
            return other == Status.Active
        elseif self == Status.Active then
            return other == Status.Completed
        else
            return false
        end
    end
end

const status = Status.Pending
print(status:isActive())  -- false
print(status:canTransitionTo(Status.Active))  -- true
print(status:canTransitionTo(Status.Completed))  -- false
</code></pre>
<h3 id="rich-enums-with-fields-and-methods"><a class="header" href="#rich-enums-with-fields-and-methods">Rich Enums with Fields and Methods</a></h3>
<p>Combining fields, constructors, and methods:</p>
<pre><code class="language-lua">enum Planet
    Mercury,
    Venus,
    Earth,
    Mars,

    -- Fields
    mass: number,           -- in kg
    radius: number,         -- in meters

    -- Constructor
    constructor()
        if self == Planet.Mercury then
            self.mass = 3.303e23
            self.radius = 2.4397e6
        elseif self == Planet.Venus then
            self.mass = 4.869e24
            self.radius = 6.0518e6
        elseif self == Planet.Earth then
            self.mass = 5.976e24
            self.radius = 6.37814e6
        elseif self == Planet.Mars then
            self.mass = 6.421e23
            self.radius = 3.3972e6
        end
    end

    -- Methods
    function surfaceGravity(): number
        const G = 6.67430e-11  -- gravitational constant
        return G * self.mass / (self.radius * self.radius)
    end

    function surfaceWeight(mass: number): number
        return mass * self:surfaceGravity()
    end
end

const earth = Planet.Earth
const earthMass = 70  -- kg

print(`Mass on Earth: ${earthMass} kg`)
print(`Weight on Earth: ${earth:surfaceWeight(earthMass)} N`)

const mars = Planet.Mars
print(`Weight on Mars: ${mars:surfaceWeight(earthMass)} N`)
</code></pre>
<h3 id="enums-with-constructor-arguments"><a class="header" href="#enums-with-constructor-arguments">Enums with Constructor Arguments</a></h3>
<p>Rich enums can accept constructor arguments per member:</p>
<pre><code class="language-lua">enum LogLevel
    Debug(color = "gray"),
    Info(color = "blue"),
    Warn(color = "yellow"),
    Error(color = "red"),

    -- Fields
    color: string,
    severity: number,

    -- Constructor accepts arguments
    constructor(color: string)
        self.color = color

        -- Set severity based on enum value
        if self == LogLevel.Debug then
            self.severity = 0
        elseif self == LogLevel.Info then
            self.severity = 1
        elseif self == LogLevel.Warn then
            self.severity = 2
        elseif self == LogLevel.Error then
            self.severity = 3
        end
    end

    function format(message: string): string
        return `[${self.color}] ${message}`
    end
end

const level = LogLevel.Warn
print(level:format("Low memory"))  -- [yellow] Low memory
print(level.severity)               -- 2
</code></pre>
<h3 id="implementing-interfaces-1"><a class="header" href="#implementing-interfaces-1">Implementing Interfaces</a></h3>
<p>Enums can implement interfaces:</p>
<pre><code class="language-lua">interface Describable
    function describe(): string
end

enum Animal implements Describable
    Dog,
    Cat,
    Bird,

    -- Fields
    sound: string,

    constructor()
        if self == Animal.Dog then
            self.sound = "bark"
        elseif self == Animal.Cat then
            self.sound = "meow"
        elseif self == Animal.Bird then
            self.sound = "chirp"
        end
    end

    -- Implement interface method
    function describe(): string
        return `A ${tostring(self)} that ${self.sound}s`
    end
end

const dog: Describable = Animal.Dog
print(dog:describe())  -- A Dog that barks
</code></pre>
<h3 id="pattern-matching-with-enums"><a class="header" href="#pattern-matching-with-enums">Pattern Matching with Enums</a></h3>
<p>Enums work well with pattern matching:</p>
<pre><code class="language-lua">enum Result&lt;T, E&gt;
    Ok(value: T),
    Err(error: E),

    value: T | E,

    constructor(val: T | E)
        self.value = val
    end
end

function divide(a: number, b: number): Result&lt;number, string&gt;
    if b == 0 then
        return Result.Err("Division by zero")
    else
        return Result.Ok(a / b)
    end
end

const result = divide(10, 2)

match result
    | Result.Ok -&gt; print(`Success: ${result.value}`)
    | Result.Err -&gt; print(`Error: ${result.value}`)
end
</code></pre>
<h3 id="mixed-enum-values"><a class="header" href="#mixed-enum-values">Mixed Enum Values</a></h3>
<p>Enums can mix string and number values:</p>
<pre><code class="language-lua">enum MixedEnum
    First = "first",
    Second = 2,
    Third = "third",
    Fourth = 4
end
</code></pre>
<p>However, this is generally discouraged—prefer consistent value types.</p>
<h2 id="details-2"><a class="header" href="#details-2">Details</a></h2>
<h3 id="enum-value-types"><a class="header" href="#enum-value-types">Enum Value Types</a></h3>
<p>Enums can have three types of values:</p>
<ol>
<li><strong>Auto string</strong> — Default, member name as string</li>
<li><strong>Explicit string</strong> — Custom string values</li>
<li><strong>Explicit number</strong> — Numeric values (can auto-increment)</li>
</ol>
<h3 id="enum-member-access"><a class="header" href="#enum-member-access">Enum Member Access</a></h3>
<p>Enum members are accessed via the enum name:</p>
<pre><code class="language-lua">const status = Status.Active
const color = Color.Red
</code></pre>
<h3 id="enum-comparison"><a class="header" href="#enum-comparison">Enum Comparison</a></h3>
<p>Enums can be compared with <code>==</code> and <code>~=</code>:</p>
<pre><code class="language-lua">if currentStatus == Status.Active then
    print("Active")
end
</code></pre>
<h3 id="type-safety"><a class="header" href="#type-safety">Type Safety</a></h3>
<p>Enums provide compile-time type safety:</p>
<pre><code class="language-lua">enum Status
    Active,
    Inactive
end

const status: Status = Status.Active  -- ✅ OK

-- Error: Type mismatch
-- const wrong: Status = "Active"  -- ❌ Type error
-- const wrong2: Status = Status.Unknown  -- ❌ Type error
</code></pre>
<h3 id="enum-methods-and-self"><a class="header" href="#enum-methods-and-self">Enum Methods and <code>self</code></a></h3>
<p>In enum methods, <code>self</code> refers to the enum value:</p>
<pre><code class="language-lua">enum Status
    Active,
    Inactive,

    function isActive(): boolean
        return self == Status.Active  -- self is the enum value
    end
end
</code></pre>
<h3 id="fields-vs-methods"><a class="header" href="#fields-vs-methods">Fields vs Methods</a></h3>
<ul>
<li><strong>Fields</strong> — Data associated with each enum value (initialized in constructor)</li>
<li><strong>Methods</strong> — Behavior shared across all enum values (can access fields via <code>self</code>)</li>
</ul>
<h3 id="constructor-behavior-1"><a class="header" href="#constructor-behavior-1">Constructor Behavior</a></h3>
<p>The constructor is called once per enum value when the enum is defined:</p>
<pre><code class="language-lua">enum Counter
    A,
    B,
    C,

    count: number,

    constructor()
        print(`Creating ${tostring(self)}`)
        self.count = 1
    end
end

-- Prints:
-- Creating A
-- Creating B
-- Creating C
</code></pre>
<h3 id="enum-reflection"><a class="header" href="#enum-reflection">Enum Reflection</a></h3>
<p>Get enum member name as string:</p>
<pre><code class="language-lua">const status = Status.Active
const name = tostring(status)  -- "Active"
</code></pre>
<p>Get all enum values:</p>
<pre><code class="language-lua">enum Color
    Red,
    Green,
    Blue
end

-- Iterate over enum values (implementation-specific)
for name, value in pairs(Color) do
    print(name, value)
end
</code></pre>
<h3 id="exhaustiveness-checking-1"><a class="header" href="#exhaustiveness-checking-1">Exhaustiveness Checking</a></h3>
<p>Use pattern matching or if-else chains with <code>never</code> for exhaustiveness:</p>
<pre><code class="language-lua">enum Status
    Pending,
    Active,
    Completed
end

function handleStatus(status: Status): void
    if status == Status.Pending then
        print("Pending")
    elseif status == Status.Active then
        print("Active")
    elseif status == Status.Completed then
        print("Completed")
    else
        -- This branch is unreachable if all cases are handled
        const _exhaustive: never = status
    end
end
</code></pre>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See Also</a></h2>
<ul>
<li><a href="#classes">Classes</a> — Object-oriented programming</li>
<li><a href="#interfaces">Interfaces</a> — Implementing interfaces with enums</li>
<li><a href="#pattern-matching-1">Pattern Matching</a> — Matching enum values</li>
<li><a href="#type-system">Type System</a> — Union types and type narrowing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>LuaNext provides a modern module system with ES6-style imports and exports. Each file is a module, and you can import/export values, types, and declarations between files.</p>
<h2 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h2>
<h3 id="imports"><a class="header" href="#imports">Imports</a></h3>
<pre><code class="language-lua">-- Default import
import defaultExport from "./module"

-- Named imports
import {export1, export2} from "./module"

-- Renamed imports
import {export1 as alias1, export2 as alias2} from "./module"

-- Namespace import
import * as name from "./module"

-- Type-only imports
import type {Type1, Type2} from "./module"

-- Mixed import
import defaultExport, {named1, named2} from "./module"
</code></pre>
<h3 id="exports"><a class="header" href="#exports">Exports</a></h3>
<pre><code class="language-lua">-- Export declaration
export const x: number = 42
export function greet(name: string): string
    return "Hello, " .. name
end
export class User
    -- ...
end

-- Named exports
const x = 10
const y = 20
export {x, y}

-- Renamed exports
export {x as publicX, y as publicY}

-- Default export
export default function main(): void
    print("Main function")
end

-- Re-exports
export {foo, bar} from "./other"
export * from "./other"
</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="basic-module"><a class="header" href="#basic-module">Basic Module</a></h3>
<p><strong>math.luax:</strong></p>
<pre><code class="language-lua">export function add(a: number, b: number): number
    return a + b
end

export function subtract(a: number, b: number): number
    return a - b
end

export const PI: number = 3.14159
</code></pre>
<p><strong>main.luax:</strong></p>
<pre><code class="language-lua">import {add, subtract, PI} from "./math"

print(add(5, 3))        -- 8
print(subtract(10, 4))  -- 6
print(PI)               -- 3.14159
</code></pre>
<p>Compiles to:</p>
<p><strong>math.lua:</strong></p>
<pre><code class="language-lua">local M = {}

function M.add(a, b)
    return a + b
end

function M.subtract(a, b)
    return a - b
end

M.PI = 3.14159

return M
</code></pre>
<p><strong>main.lua:</strong></p>
<pre><code class="language-lua">local math = require("./math")

print(math.add(5, 3))
print(math.subtract(10, 4))
print(math.PI)
</code></pre>
<h3 id="default-export"><a class="header" href="#default-export">Default Export</a></h3>
<p><strong>logger.luax:</strong></p>
<pre><code class="language-lua">class Logger
    function log(message: string): void
        print("[LOG] " .. message)
    end

    function error(message: string): void
        print("[ERROR] " .. message)
    end
end

export default Logger
</code></pre>
<p><strong>main.luax:</strong></p>
<pre><code class="language-lua">import Logger from "./logger"

const logger = Logger.new()
logger:log("Application started")
</code></pre>
<h3 id="named-exports"><a class="header" href="#named-exports">Named Exports</a></h3>
<p><strong>config.luax:</strong></p>
<pre><code class="language-lua">export const API_URL: string = "https://api.example.com"
export const TIMEOUT: number = 5000
export const MAX_RETRIES: number = 3

export function getConfig(): {url: string, timeout: number}
    return {
        url = API_URL,
        timeout = TIMEOUT
    }
end
</code></pre>
<p><strong>main.luax:</strong></p>
<pre><code class="language-lua">import {API_URL, TIMEOUT, getConfig} from "./config"

print(API_URL)     -- https://api.example.com
print(TIMEOUT)     -- 5000

const config = getConfig()
</code></pre>
<h3 id="renamed-imports"><a class="header" href="#renamed-imports">Renamed Imports</a></h3>
<pre><code class="language-lua">import {add as sum, subtract as diff} from "./math"

print(sum(5, 3))   -- 8
print(diff(10, 4)) -- 6
</code></pre>
<h3 id="namespace-import"><a class="header" href="#namespace-import">Namespace Import</a></h3>
<p>Import all exports under a single namespace:</p>
<pre><code class="language-lua">import * as math from "./math"

print(math.add(5, 3))
print(math.subtract(10, 4))
print(math.PI)
</code></pre>
<h3 id="type-only-imports"><a class="header" href="#type-only-imports">Type-Only Imports</a></h3>
<p>Import only types (no runtime code generated):</p>
<p><strong>types.luax:</strong></p>
<pre><code class="language-lua">export interface User
    id: string
    name: string
    email: string
end

export type Status = "active" | "inactive"

export const DEFAULT_STATUS: Status = "active"
</code></pre>
<p><strong>main.luax:</strong></p>
<pre><code class="language-lua">import type {User, Status} from "./types"
import {DEFAULT_STATUS} from "./types"

const user: User = {
    id = "user-123",
    name = "Alice",
    email = "alice@example.com"
}

const status: Status = DEFAULT_STATUS
</code></pre>
<p>Compiles to (type imports are erased):</p>
<pre><code class="language-lua">local types = require("./types")

local user = {
    id = "user-123",
    name = "Alice",
    email = "alice@example.com"
}

local status = types.DEFAULT_STATUS
</code></pre>
<h3 id="mixed-imports"><a class="header" href="#mixed-imports">Mixed Imports</a></h3>
<p>Combine default and named imports:</p>
<p><strong>utils.luax:</strong></p>
<pre><code class="language-lua">export function helper1(): void
    print("Helper 1")
end

export function helper2(): void
    print("Helper 2")
end

export default function main(): void
    print("Main utility")
end
</code></pre>
<p><strong>main.luax:</strong></p>
<pre><code class="language-lua">import mainUtil, {helper1, helper2} from "./utils"

mainUtil()    -- Main utility
helper1()     -- Helper 1
helper2()     -- Helper 2
</code></pre>
<h3 id="re-exports"><a class="header" href="#re-exports">Re-Exports</a></h3>
<p>Re-export from another module:</p>
<p><strong>api/users.luax:</strong></p>
<pre><code class="language-lua">export function getUser(id: string): User
    -- ...
end

export function createUser(data: UserData): User
    -- ...
end
</code></pre>
<p><strong>api/posts.luax:</strong></p>
<pre><code class="language-lua">export function getPost(id: string): Post
    -- ...
end
</code></pre>
<p><strong>api/index.luax:</strong></p>
<pre><code class="language-lua">-- Re-export everything from users and posts
export * from "./users"
export * from "./posts"

-- Or re-export specific items
export {getUser, createUser} from "./users"
export {getPost} from "./posts"
</code></pre>
<p><strong>main.luax:</strong></p>
<pre><code class="language-lua">import {getUser, getPost} from "./api"

const user = getUser("user-123")
const post = getPost("post-456")
</code></pre>
<h3 id="exporting-types"><a class="header" href="#exporting-types">Exporting Types</a></h3>
<p>Export type declarations:</p>
<p><strong>types.luax:</strong></p>
<pre><code class="language-lua">export interface Point
    x: number
    y: number
end

export type Vector = Point

export type Result&lt;T&gt; = {success: true, value: T} | {success: false, error: string}
</code></pre>
<p><strong>main.luax:</strong></p>
<pre><code class="language-lua">import type {Point, Vector, Result} from "./types"

const p: Point = {x = 1, y = 2}
const v: Vector = {x = 3, y = 4}
const result: Result&lt;number&gt; = {success = true, value = 42}
</code></pre>
<h3 id="file-namespaces"><a class="header" href="#file-namespaces">File Namespaces</a></h3>
<p>Declare a namespace for the entire file:</p>
<p><strong>math.luax:</strong></p>
<pre><code class="language-lua">namespace Math

export function add(a: number, b: number): number
    return a + b
end

export function subtract(a: number, b: number): number
    return a - b
end

export const PI: number = 3.14159
</code></pre>
<p><strong>main.luax:</strong></p>
<pre><code class="language-lua">import {add, PI} from "./math"

-- Or use namespace import
import * as Math from "./math"

print(Math.add(5, 3))
print(Math.PI)
</code></pre>
<h3 id="circular-dependencies"><a class="header" href="#circular-dependencies">Circular Dependencies</a></h3>
<p>LuaNext detects circular dependencies at compile time:</p>
<p><strong>a.luax:</strong></p>
<pre><code class="language-lua">import {foo} from "./b"

export function bar(): void
    print("bar")
    foo()
end
</code></pre>
<p><strong>b.luax:</strong></p>
<pre><code class="language-lua">import {bar} from "./a"

export function foo(): void
    print("foo")
    bar()
end
</code></pre>
<pre><code>Error: Circular dependency detected:
  a.luax -&gt; b.luax -&gt; a.luax
</code></pre>
<h4 id="breaking-circular-dependencies-with-type-only-imports"><a class="header" href="#breaking-circular-dependencies-with-type-only-imports">Breaking Circular Dependencies with Type-Only Imports</a></h4>
<p>Type-only imports don’t create runtime dependencies:</p>
<p><strong>a.luax:</strong></p>
<pre><code class="language-lua">import type {BType} from "./b"
import {bFunction} from "./b"

export interface AType
    value: number
end

export function aFunction(b: BType): void
    print(b.name)
end
</code></pre>
<p><strong>b.luax:</strong></p>
<pre><code class="language-lua">import type {AType} from "./a"  -- Type-only, no circular dependency

export interface BType
    name: string
end

export function bFunction(a: AType): void
    print(a.value)
end
</code></pre>
<p>This works because type-only imports are erased at runtime.</p>
<h2 id="details-3"><a class="header" href="#details-3">Details</a></h2>
<h3 id="module-resolution"><a class="header" href="#module-resolution">Module Resolution</a></h3>
<p>LuaNext resolves modules using the following rules:</p>
<ol>
<li>
<p><strong>Relative paths</strong> — Start with <code>./</code> or <code>../</code></p>
<ul>
<li><code>./module</code> → same directory</li>
<li><code>../module</code> → parent directory</li>
<li><code>../../module</code> → grandparent directory</li>
</ul>
</li>
<li>
<p><strong>Absolute paths</strong> — Resolved from project root or node_modules</p>
</li>
<li>
<p><strong>File extensions</strong> — <code>.luax</code> is implicit</p>
<ul>
<li><code>import {x} from "./module"</code> → looks for <code>module.luax</code></li>
</ul>
</li>
</ol>
<h3 id="export-restrictions"><a class="header" href="#export-restrictions">Export Restrictions</a></h3>
<ul>
<li>Each file can have at most one default export</li>
<li>Cannot export the same name twice</li>
<li>Cannot re-export and locally export the same name</li>
</ul>
<pre><code class="language-lua">-- Error: Duplicate export
export const x = 1
export const x = 2  -- ❌ Error

-- Error: Duplicate default export
export default function foo() end
export default function bar() end  -- ❌ Error
</code></pre>
<h3 id="import-restrictions"><a class="header" href="#import-restrictions">Import Restrictions</a></h3>
<ul>
<li>Cannot import from a module that doesn’t export the name</li>
<li>Cannot import the same name twice in one import statement</li>
</ul>
<pre><code class="language-lua">-- Error: Module doesn't export 'unknownExport'
import {unknownExport} from "./module"  -- ❌ Error

-- Error: Duplicate import
import {x, x} from "./module"  -- ❌ Error
</code></pre>
<h3 id="type-only-imports-1"><a class="header" href="#type-only-imports-1">Type-Only Imports</a></h3>
<p>Type-only imports:</p>
<ul>
<li>Import types, interfaces, and type aliases</li>
<li>Generate no runtime code</li>
<li>Help break circular dependencies</li>
<li>Clearly separate type and value imports</li>
</ul>
<pre><code class="language-lua">-- Type-only: no require() generated
import type {User} from "./types"

-- Regular import: generates require()
import {createUser} from "./api"
</code></pre>
<h3 id="export-all"><a class="header" href="#export-all">Export All</a></h3>
<p><code>export * from "./module"</code> re-exports everything except:</p>
<ul>
<li>Default exports (must be explicitly re-exported)</li>
<li>Type-only exports (unless using <code>export type * from</code>)</li>
</ul>
<pre><code class="language-lua">-- Re-export all values
export * from "./module"

-- Re-export all types
export type * from "./types"

-- Re-export specific default
export {default as MyDefault} from "./module"
</code></pre>
<h3 id="module-compilation-modes"><a class="header" href="#module-compilation-modes">Module Compilation Modes</a></h3>
<p>LuaNext supports two module compilation modes:</p>
<p><strong>1. Require Mode (default)</strong></p>
<p>Each module compiles to a file with <code>return M</code>:</p>
<pre><code class="language-lua">local M = {}
M.foo = ...
return M
</code></pre>
<p>Imported with <code>require()</code>:</p>
<pre><code class="language-lua">local module = require("./module")
</code></pre>
<p><strong>2. Bundle Mode</strong></p>
<p>All modules bundled into a single file with inline module definitions.</p>
<p>Configure in <code>luanext.config.yaml</code>:</p>
<pre><code class="language-yaml">module:
  mode: "require"  # or "bundle"
</code></pre>
<h3 id="module-scope"><a class="header" href="#module-scope">Module Scope</a></h3>
<p>Each module has its own scope:</p>
<ul>
<li>Top-level variables are local to the module</li>
<li>Only exported values are accessible from other modules</li>
<li>Imports are available throughout the module</li>
</ul>
<pre><code class="language-lua">-- Private to this module
const PRIVATE_CONSTANT = 42

function privateHelper(): void
    -- Only accessible within this file
end

-- Public (exported)
export function publicAPI(): void
    privateHelper()  -- Can use private functions
end
</code></pre>
<h3 id="module-initialization"><a class="header" href="#module-initialization">Module Initialization</a></h3>
<p>Modules are initialized once on first import:</p>
<p><strong>counter.luax:</strong></p>
<pre><code class="language-lua">print("Initializing counter module")

const count = 0

export function increment(): void
    count = count + 1
end

export function getCount(): number
    return count
end
</code></pre>
<p><strong>main.luax:</strong></p>
<pre><code class="language-lua">import {increment, getCount} from "./counter"  -- Prints "Initializing counter module"
import {increment as inc} from "./counter"     -- Does NOT print again

increment()
print(getCount())  -- 1
inc()
print(getCount())  -- 2
</code></pre>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See Also</a></h2>
<ul>
<li><a href="#basics">Basics</a> — Variable declarations and types</li>
<li><a href="#classes">Classes</a> — Exporting classes</li>
<li><a href="#interfaces">Interfaces</a> — Exporting type definitions</li>
<li><a href="#namespaces">Namespaces</a> — File namespaces</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>LuaNext provides structured exception handling with try/catch/finally blocks, typed error handling, error chaining, and try expressions. This goes beyond Lua’s traditional <code>pcall</code>/<code>xpcall</code> approach.</p>
<h2 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h2>
<pre><code class="language-lua">-- Try/catch/finally statement
try
    -- code that might throw
catch [pattern: Type]
    -- error handling
[finally
    -- cleanup code]
end

-- Throw statement
throw expression

-- Rethrow
rethrow

-- Try expression
try expression catch error =&gt; fallback

-- Error chain operator
expression1 !! expression2

-- Throws clause
function name(params): ReturnType throws ErrorType1, ErrorType2
    -- function body
end
</code></pre>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="basic-trycatch"><a class="header" href="#basic-trycatch">Basic Try/Catch</a></h3>
<pre><code class="language-lua">function divide(a: number, b: number): number
    if b == 0 then
        throw "Division by zero"
    end
    return a / b
end

try
    const result = divide(10, 0)
    print(result)
catch error
    print("Error: " .. error)
end
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local function divide(a, b)
    if b == 0 then
        error("Division by zero")
    end
    return a / b
end

local success, result = pcall(function()
    local result = divide(10, 0)
    print(result)
end)

if not success then
    local error = result
    print("Error: " .. error)
end
</code></pre>
<h3 id="typed-catch-clauses"><a class="header" href="#typed-catch-clauses">Typed Catch Clauses</a></h3>
<p>Catch specific error types:</p>
<pre><code class="language-lua">class ValidationError
    message: string

    constructor(message: string)
        self.message = message
    end
end

class NetworkError
    message: string
    code: number

    constructor(message: string, code: number)
        self.message = message
        self.code = code
    end
end

function processRequest(data: string): void
    if data == "" then
        throw ValidationError.new("Data cannot be empty")
    end

    if not networkAvailable() then
        throw NetworkError.new("Network unavailable", 503)
    end

    -- Process data...
end

try
    processRequest("")
catch error: ValidationError
    print(`Validation error: ${error.message}`)
catch error: NetworkError
    print(`Network error (${error.code}): ${error.message}`)
catch error
    print(`Unknown error: ${error}`)
end
</code></pre>
<h3 id="multi-typed-catch"><a class="header" href="#multi-typed-catch">Multi-Typed Catch</a></h3>
<p>Catch multiple error types in one clause:</p>
<pre><code class="language-lua">try
    riskyOperation()
catch error: ValidationError | NetworkError
    print(`Known error: ${error.message}`)
catch error
    print(`Unknown error: ${error}`)
end
</code></pre>
<h3 id="finally-block"><a class="header" href="#finally-block">Finally Block</a></h3>
<p>Code that always executes, whether an error occurred or not:</p>
<pre><code class="language-lua">const file = openFile("data.txt")

try
    processFile(file)
catch error
    print(`Error processing file: ${error}`)
finally
    closeFile(file)  -- Always executed
end
</code></pre>
<h3 id="throw-statement"><a class="header" href="#throw-statement">Throw Statement</a></h3>
<p>Throw any value as an error:</p>
<pre><code class="language-lua">-- Throw string
throw "Something went wrong"

-- Throw number
throw 404

-- Throw object
throw {message = "Error", code = 500}

-- Throw custom error class
throw ValidationError.new("Invalid input")
</code></pre>
<h3 id="rethrow"><a class="header" href="#rethrow">Rethrow</a></h3>
<p>Rethrow the current error in a catch block:</p>
<pre><code class="language-lua">try
    performOperation()
catch error
    logError(error)
    rethrow  -- Re-throw the same error
end
</code></pre>
<h3 id="try-expression"><a class="header" href="#try-expression">Try Expression</a></h3>
<p>Compact error handling for expressions:</p>
<pre><code class="language-lua">-- Basic try expression
const result: number = try parseNumber(input) catch _ =&gt; 0

-- With error variable
const result: string = try readFile("config.json") catch error =&gt; "default config"

-- Nested try expressions
const value: number = try parseInt(try readFile("num.txt") catch _ =&gt; "0") catch _ =&gt; 0
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local result
local success, value = pcall(function() return parseNumber(input) end)
if success then
    result = value
else
    result = 0
end
</code></pre>
<h3 id="error-chain-operator"><a class="header" href="#error-chain-operator">Error Chain Operator</a></h3>
<p>The error chain operator <code>!!</code> provides a shorthand for try expressions:</p>
<pre><code class="language-lua">-- Error chain (try expression shorthand)
const result = riskyOperation() !! fallbackValue

-- Equivalent to:
const result = try riskyOperation() catch _ =&gt; fallbackValue

-- Chaining multiple operations
const value = operation1() !! operation2() !! defaultValue
</code></pre>
<h3 id="throws-clause-1"><a class="header" href="#throws-clause-1">Throws Clause</a></h3>
<p>Document which errors a function can throw:</p>
<pre><code class="language-lua">function readFile(path: string): string throws FileNotFoundError, PermissionError
    if not fileExists(path) then
        throw FileNotFoundError.new(path)
    end

    if not hasPermission(path) then
        throw PermissionError.new(path)
    end

    return loadFile(path)
end

function processFile(path: string): void throws FileNotFoundError, PermissionError
    const content = readFile(path)  -- Can propagate throws
    print(content)
end
</code></pre>
<p>The <code>throws</code> clause is documentation—it doesn’t enforce catching at compile time, but helps with:</p>
<ul>
<li>Documentation and intent</li>
<li>IDE autocomplete and warnings</li>
<li>Static analysis tools</li>
</ul>
<h3 id="multiple-catch-clauses"><a class="header" href="#multiple-catch-clauses">Multiple Catch Clauses</a></h3>
<p>Handle different error types differently:</p>
<pre><code class="language-lua">try
    complexOperation()
catch error: ValidationError
    print("Validation failed: " .. error.message)
    return false
catch error: NetworkError
    print("Network issue: " .. error.message)
    retryLater()
catch error: DatabaseError
    print("Database error: " .. error.message)
    rollbackTransaction()
catch error
    print("Unexpected error: " .. tostring(error))
    logToFile(error)
end
</code></pre>
<h3 id="nested-trycatch"><a class="header" href="#nested-trycatch">Nested Try/Catch</a></h3>
<p>Try blocks can be nested:</p>
<pre><code class="language-lua">try
    const data = fetchData()

    try
        validateData(data)
    catch error: ValidationError
        print("Validation failed, using defaults")
        data = getDefaultData()
    end

    processData(data)
catch error: NetworkError
    print("Network error: " .. error.message)
catch error
    print("Unexpected error: " .. tostring(error))
end
</code></pre>
<h3 id="error-with-context"><a class="header" href="#error-with-context">Error with Context</a></h3>
<p>Custom error classes with context:</p>
<pre><code class="language-lua">class HttpError
    statusCode: number
    message: string
    url: string

    constructor(statusCode: number, message: string, url: string)
        self.statusCode = statusCode
        self.message = message
        self.url = url
    end

    function toString(): string
        return `HTTP ${self.statusCode} at ${self.url}: ${self.message}`
    end
end

function fetchAPI(url: string): string throws HttpError
    const response = httpGet(url)

    if response.statusCode ~= 200 then
        throw HttpError.new(response.statusCode, response.body, url)
    end

    return response.body
end

try
    const data = fetchAPI("https://api.example.com/data")
    print(data)
catch error: HttpError
    print(error:toString())
    if error.statusCode == 404 then
        print("Resource not found")
    elseif error.statusCode &gt;= 500 then
        print("Server error, retrying...")
    end
end
</code></pre>
<h3 id="error-propagation"><a class="header" href="#error-propagation">Error Propagation</a></h3>
<p>Errors automatically propagate up the call stack:</p>
<pre><code class="language-lua">function innerFunction(): void
    throw "Inner error"
end

function middleFunction(): void
    innerFunction()  -- Error propagates
end

function outerFunction(): void
    try
        middleFunction()
    catch error
        print("Caught error from inner: " .. error)
    end
end

outerFunction()  -- Prints: Caught error from inner: Inner error
</code></pre>
<h3 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h3>
<p>Use error handling for graceful degradation:</p>
<pre><code class="language-lua">function loadConfig(): Config
    -- Try primary config
    const primary = try readFile("config.json") catch _ =&gt; nil

    if primary ~= nil then
        return parseConfig(primary)
    end

    -- Try fallback config
    const fallback = try readFile("config.default.json") catch _ =&gt; nil

    if fallback ~= nil then
        return parseConfig(fallback)
    end

    -- Use hardcoded defaults
    return getDefaultConfig()
end
</code></pre>
<h3 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h3>
<p>Ensure resources are cleaned up with finally:</p>
<pre><code class="language-lua">function processDatabase(query: string): void
    const connection = openConnection()

    try
        const result = connection:execute(query)
        processResult(result)
    catch error: DatabaseError
        print("Database error: " .. error.message)
        rollback(connection)
    finally
        closeConnection(connection)  -- Always executed
    end
end
</code></pre>
<h3 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h3>
<p>Recover from errors and continue:</p>
<pre><code class="language-lua">function processBatch(items: string[]): void
    const errors: string[] = {}

    for i, item in ipairs(items) do
        try
            processItem(item)
        catch error
            table.insert(errors, `Item ${i}: ${error}`)
        end
    end

    if #errors &gt; 0 then
        print("Encountered errors:")
        for _, error in ipairs(errors) do
            print(error)
        end
    end
end
</code></pre>
<h2 id="details-4"><a class="header" href="#details-4">Details</a></h2>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<p>LuaNext can throw any value:</p>
<ul>
<li>Strings: <code>throw "error message"</code></li>
<li>Numbers: <code>throw 404</code></li>
<li>Tables: <code>throw {code = 500, message = "Error"}</code></li>
<li>Custom classes: <code>throw CustomError.new()</code></li>
</ul>
<h3 id="catch-pattern-matching"><a class="header" href="#catch-pattern-matching">Catch Pattern Matching</a></h3>
<p>Catch clauses use pattern matching:</p>
<ul>
<li><code>catch error</code> — Catch any error</li>
<li><code>catch error: Type</code> — Catch specific type</li>
<li><code>catch error: Type1 | Type2</code> — Catch multiple types</li>
</ul>
<h3 id="finally-execution-order"><a class="header" href="#finally-execution-order">Finally Execution Order</a></h3>
<p>The finally block executes:</p>
<ol>
<li>After try block completes successfully</li>
<li>After catch block handles an error</li>
<li>Before control flow exits (return, break, continue)</li>
</ol>
<pre><code class="language-lua">function example(): string
    try
        return "success"
    finally
        print("Cleanup")  -- Executes before return
    end
end

example()  -- Prints "Cleanup", then returns "success"
</code></pre>
<h3 id="error-chain-precedence"><a class="header" href="#error-chain-precedence">Error Chain Precedence</a></h3>
<p>The error chain operator <code>!!</code> has low precedence:</p>
<pre><code class="language-lua">-- These are equivalent:
const x = a + b !! c + d
const x = (a + b) !! (c + d)

-- Parentheses for clarity:
const x = (a + b) !! c  -- Error chain after addition
</code></pre>
<h3 id="try-expression-vs-error-chain"><a class="header" href="#try-expression-vs-error-chain">Try Expression vs Error Chain</a></h3>
<p>Try expression and error chain are equivalent:</p>
<pre><code class="language-lua">-- Try expression (explicit)
const x = try f() catch _ =&gt; 0

-- Error chain (concise)
const x = f() !! 0
</code></pre>
<p>Use try expression when you need the error variable:</p>
<pre><code class="language-lua">const x = try f() catch error =&gt; log(error) or 0
</code></pre>
<p>Use error chain for simple fallbacks:</p>
<pre><code class="language-lua">const x = f() !! 0
</code></pre>
<h3 id="throws-clause-benefits"><a class="header" href="#throws-clause-benefits">Throws Clause Benefits</a></h3>
<p>While not enforced, the <code>throws</code> clause provides:</p>
<ul>
<li><strong>Documentation</strong> — Clear indication of possible errors</li>
<li><strong>IDE support</strong> — Warnings and autocomplete</li>
<li><strong>Static analysis</strong> — Tools can check error handling</li>
<li><strong>Call graph</strong> — Understand error propagation</li>
</ul>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<p>Exception handling uses Lua’s <code>pcall</code>/<code>xpcall</code>:</p>
<ul>
<li>Try blocks have minimal overhead when no error occurs</li>
<li>Error throwing and catching is slower than normal control flow</li>
<li>Use for exceptional cases, not normal flow control</li>
</ul>
<h3 id="error-vs-return"><a class="header" href="#error-vs-return">Error vs Return</a></h3>
<p>Prefer errors for exceptional conditions:</p>
<pre><code class="language-lua">-- Good: Error for exceptional condition
function divide(a: number, b: number): number
    if b == 0 then
        throw "Division by zero"
    end
    return a / b
end

-- Also good: Return optional for expected missing values
function findUser(id: string): User | nil
    return users[id]  -- nil is expected, not exceptional
end
</code></pre>
<h3 id="stack-traces"><a class="header" href="#stack-traces">Stack Traces</a></h3>
<p>LuaNext preserves Lua’s error stack traces:</p>
<pre><code class="language-lua">function a(): void
    b()
end

function b(): void
    c()
end

function c(): void
    throw "Error in c"
end

try
    a()
catch error
    print(debug.traceback(error))
    -- Shows: c -&gt; b -&gt; a call chain
end
</code></pre>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See Also</a></h2>
<ul>
<li><a href="#functions">Functions</a> — Throws clause in function signatures</li>
<li><a href="#classes">Classes</a> — Custom error classes</li>
<li><a href="#type-system">Type System</a> — Union types for error types</li>
<li><a href="#pattern-matching-1">Pattern Matching</a> — Pattern matching in catch clauses</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h1>
<p>Pattern matching provides a powerful way to destructure and test values. LuaNext supports match expressions with identifier, literal, array, object, wildcard, and or patterns, along with guards for conditional matching.</p>
<h2 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h2>
<pre><code class="language-lua">match expression
    | pattern [if guard] -&gt; expression
    | pattern [if guard] -&gt; expression
    | pattern [if guard] -&gt;
        -- block
    end
end
</code></pre>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="basic-pattern-matching"><a class="header" href="#basic-pattern-matching">Basic Pattern Matching</a></h3>
<p>Match against literal values:</p>
<pre><code class="language-lua">function getStatusMessage(code: number): string
    return match code
        | 200 -&gt; "OK"
        | 404 -&gt; "Not Found"
        | 500 -&gt; "Internal Server Error"
        | _ -&gt; "Unknown Status"
    end
end

print(getStatusMessage(200))  -- OK
print(getStatusMessage(999))  -- Unknown Status
</code></pre>
<p>Compiles to:</p>
<pre><code class="language-lua">local function getStatusMessage(code)
    local _match = code
    if _match == 200 then
        return "OK"
    elseif _match == 404 then
        return "Not Found"
    elseif _match == 500 then
        return "Internal Server Error"
    else
        return "Unknown Status"
    end
end

print(getStatusMessage(200))
print(getStatusMessage(999))
</code></pre>
<h3 id="identifier-pattern"><a class="header" href="#identifier-pattern">Identifier Pattern</a></h3>
<p>Bind values to identifiers:</p>
<pre><code class="language-lua">const value = 42

const result = match value
    | x -&gt; x * 2
end

print(result)  -- 84
</code></pre>
<h3 id="wildcard-pattern"><a class="header" href="#wildcard-pattern">Wildcard Pattern</a></h3>
<p>The wildcard pattern <code>_</code> matches any value without binding:</p>
<pre><code class="language-lua">function isPositive(x: number): boolean
    return match x
        | 0 -&gt; false
        | _ if x &gt; 0 -&gt; true
        | _ -&gt; false
    end
end
</code></pre>
<h3 id="array-patterns"><a class="header" href="#array-patterns">Array Patterns</a></h3>
<p>Destructure arrays with pattern matching:</p>
<pre><code class="language-lua">function describeArray(arr: number[]): string
    return match arr
        | [] -&gt; "Empty array"
        | [x] -&gt; `Single element: ${x}`
        | [x, y] -&gt; `Two elements: ${x}, ${y}`
        | [x, y, z] -&gt; `Three elements: ${x}, ${y}, ${z}`
        | _ -&gt; "More than three elements"
    end
end

print(describeArray({}))         -- Empty array
print(describeArray({1}))        -- Single element: 1
print(describeArray({1, 2}))     -- Two elements: 1, 2
print(describeArray({1, 2, 3}))  -- Three elements: 1, 2, 3
print(describeArray({1, 2, 3, 4}))  -- More than three elements
</code></pre>
<h3 id="rest-pattern"><a class="header" href="#rest-pattern">Rest Pattern</a></h3>
<p>Capture remaining array elements:</p>
<pre><code class="language-lua">function getFirstAndRest(arr: number[]): {first: number, rest: number[]}
    return match arr
        | [] -&gt; {first = 0, rest = {}}
        | [first, ...rest] -&gt; {first = first, rest = rest}
    end
end

const result = getFirstAndRest({1, 2, 3, 4})
print(result.first)        -- 1
print(#result.rest)        -- 3
print(result.rest[1])      -- 2
</code></pre>
<h3 id="object-patterns"><a class="header" href="#object-patterns">Object Patterns</a></h3>
<p>Destructure objects/tables:</p>
<pre><code class="language-lua">interface Point
    x: number
    y: number
end

function describePoint(p: Point): string
    return match p
        | {x = 0, y = 0} -&gt; "Origin"
        | {x = 0, y} -&gt; `On Y axis at ${y}`
        | {x, y = 0} -&gt; `On X axis at ${x}`
        | {x, y} -&gt; `Point at (${x}, ${y})`
    end
end

print(describePoint({x = 0, y = 0}))   -- Origin
print(describePoint({x = 0, y = 5}))   -- On Y axis at 5
print(describePoint({x = 3, y = 0}))   -- On X axis at 3
print(describePoint({x = 3, y = 4}))   -- Point at (3, 4)
</code></pre>
<h3 id="guards"><a class="header" href="#guards">Guards</a></h3>
<p>Add conditional checks to patterns:</p>
<pre><code class="language-lua">function classifyNumber(x: number): string
    return match x
        | 0 -&gt; "Zero"
        | n if n &gt; 0 and n &lt; 10 -&gt; "Small positive"
        | n if n &gt;= 10 and n &lt; 100 -&gt; "Medium positive"
        | n if n &gt;= 100 -&gt; "Large positive"
        | n if n &lt; 0 -&gt; "Negative"
        | _ -&gt; "Unknown"
    end
end

print(classifyNumber(0))    -- Zero
print(classifyNumber(5))    -- Small positive
print(classifyNumber(50))   -- Medium positive
print(classifyNumber(150))  -- Large positive
print(classifyNumber(-5))   -- Negative
</code></pre>
<h3 id="or-patterns"><a class="header" href="#or-patterns">Or Patterns</a></h3>
<p>Match multiple patterns in one arm:</p>
<pre><code class="language-lua">function isWeekend(day: string): boolean
    return match day
        | "Saturday" | "Sunday" -&gt; true
        | _ -&gt; false
    end
end

print(isWeekend("Saturday"))  -- true
print(isWeekend("Monday"))    -- false
</code></pre>
<h3 id="nested-patterns"><a class="header" href="#nested-patterns">Nested Patterns</a></h3>
<p>Patterns can be nested:</p>
<pre><code class="language-lua">interface User
    name: string
    address: {city: string, zip: string}
end

function getCityFromUser(user: User): string
    return match user
        | {address = {city}} -&gt; city
        | _ -&gt; "Unknown city"
    end
end

const user: User = {
    name = "Alice",
    address = {city = "New York", zip = "10001"}
}

print(getCityFromUser(user))  -- New York
</code></pre>
<h3 id="matching-enums"><a class="header" href="#matching-enums">Matching Enums</a></h3>
<p>Pattern matching works excellently with enums:</p>
<pre><code class="language-lua">enum Status
    Pending,
    Active,
    Completed,
    Failed
end

function getColor(status: Status): string
    return match status
        | Status.Pending -&gt; "yellow"
        | Status.Active -&gt; "green"
        | Status.Completed -&gt; "blue"
        | Status.Failed -&gt; "red"
    end
end

const status = Status.Active
print(getColor(status))  -- green
</code></pre>
<h3 id="block-bodies"><a class="header" href="#block-bodies">Block Bodies</a></h3>
<p>Match arms can have block bodies:</p>
<pre><code class="language-lua">function processValue(x: number): number
    return match x
        | 0 -&gt;
            print("Zero detected")
            return 1
        end
        | n if n &lt; 0 -&gt;
            print("Negative number")
            return -n
        end
        | n -&gt;
            print("Positive number")
            return n * 2
        end
    end
end
</code></pre>
<h3 id="exhaustiveness-checking-2"><a class="header" href="#exhaustiveness-checking-2">Exhaustiveness Checking</a></h3>
<p>The compiler warns if not all cases are handled:</p>
<pre><code class="language-lua">enum Color
    Red,
    Green,
    Blue
end

function getName(color: Color): string
    return match color
        | Color.Red -&gt; "red"
        | Color.Green -&gt; "green"
        -- Missing Color.Blue!
        -- Warning: Non-exhaustive match
    end
end

-- Use wildcard to ensure exhaustiveness:
function getName2(color: Color): string
    return match color
        | Color.Red -&gt; "red"
        | Color.Green -&gt; "green"
        | _ -&gt; "other"
    end
end
</code></pre>
<h3 id="matching-complex-types"><a class="header" href="#matching-complex-types">Matching Complex Types</a></h3>
<p>Match against complex union types:</p>
<pre><code class="language-lua">type Result&lt;T, E&gt; = {success: true, value: T} | {success: false, error: E}

function handleResult&lt;T&gt;(result: Result&lt;T, string&gt;): T | nil
    return match result
        | {success = true, value} -&gt; value
        | {success = false, error} -&gt;
            print(`Error: ${error}`)
            return nil
        end
    end
end

const result1: Result&lt;number, string&gt; = {success = true, value = 42}
const result2: Result&lt;number, string&gt; = {success = false, error = "Failed"}

print(handleResult(result1))  -- 42
print(handleResult(result2))  -- nil (prints "Error: Failed")
</code></pre>
<h3 id="matching-optional-values"><a class="header" href="#matching-optional-values">Matching Optional Values</a></h3>
<p>Handle nullable values:</p>
<pre><code class="language-lua">function getLength(str: string | nil): number
    return match str
        | nil -&gt; 0
        | s -&gt; #s
    end
end

print(getLength(nil))      -- 0
print(getLength("hello"))  -- 5
</code></pre>
<h3 id="pattern-matching-in-variable-declarations"><a class="header" href="#pattern-matching-in-variable-declarations">Pattern Matching in Variable Declarations</a></h3>
<p>Destructure in variable declarations:</p>
<pre><code class="language-lua">const [x, y, z] = {1, 2, 3}
print(x, y, z)  -- 1 2 3

const {name, age} = {name = "Alice", age = 30}
print(name, age)  -- Alice 30

-- With rest pattern
const [first, ...rest] = {1, 2, 3, 4, 5}
print(first)     -- 1
print(#rest)     -- 4
</code></pre>
<h3 id="pattern-matching-in-function-parameters"><a class="header" href="#pattern-matching-in-function-parameters">Pattern Matching in Function Parameters</a></h3>
<p>Destructure function parameters:</p>
<pre><code class="language-lua">function distance(p1: {x: number, y: number}, p2: {x: number, y: number}): number
    return math.sqrt((p2.x - p1.x) ^ 2 + (p2.y - p1.y) ^ 2)
end

-- With destructuring:
function distance2({x = x1, y = y1}: {x: number, y: number}, {x = x2, y = y2}: {x: number, y: number}): number
    return math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)
end
</code></pre>
<h3 id="matching-multiple-values"><a class="header" href="#matching-multiple-values">Matching Multiple Values</a></h3>
<p>Match against tuples:</p>
<pre><code class="language-lua">function classifyPoint(x: number, y: number): string
    return match {x, y}
        | {0, 0} -&gt; "Origin"
        | {0, _} -&gt; "Y axis"
        | {_, 0} -&gt; "X axis"
        | {x, y} if x == y -&gt; "Diagonal"
        | _ -&gt; "Other"
    end
end

print(classifyPoint(0, 0))  -- Origin
print(classifyPoint(0, 5))  -- Y axis
print(classifyPoint(3, 0))  -- X axis
print(classifyPoint(5, 5))  -- Diagonal
print(classifyPoint(3, 4))  -- Other
</code></pre>
<h2 id="details-5"><a class="header" href="#details-5">Details</a></h2>
<h3 id="pattern-types"><a class="header" href="#pattern-types">Pattern Types</a></h3>
<p>LuaNext supports six pattern types:</p>
<ol>
<li><strong>Identifier</strong> — <code>x</code>, <code>name</code>, <code>value</code> (binds to variable)</li>
<li><strong>Literal</strong> — <code>42</code>, <code>"hello"</code>, <code>true</code>, <code>nil</code> (exact match)</li>
<li><strong>Array</strong> — <code>[x, y, z]</code>, <code>[first, ...rest]</code> (array destructuring)</li>
<li><strong>Object</strong> — <code>{x, y}</code>, <code>{name = n, age}</code> (object destructuring)</li>
<li><strong>Wildcard</strong> — <code>_</code> (matches anything, no binding)</li>
<li><strong>Or</strong> — <code>Red | Green | Blue</code> (match any alternative)</li>
</ol>
<h3 id="guard-evaluation"><a class="header" href="#guard-evaluation">Guard Evaluation</a></h3>
<p>Guards are evaluated left to right:</p>
<pre><code class="language-lua">match x
    | n if n &gt; 10 -&gt; "large"   -- Checked first
    | n if n &gt; 5 -&gt; "medium"   -- Checked if first guard fails
    | _ -&gt; "small"              -- Fallback
end
</code></pre>
<h3 id="pattern-precedence"><a class="header" href="#pattern-precedence">Pattern Precedence</a></h3>
<p>Patterns are matched in order:</p>
<pre><code class="language-lua">match x
    | _ -&gt; "first"   -- Always matches, later patterns unreachable
    | 42 -&gt; "second" -- Warning: Unreachable pattern
end
</code></pre>
<p>Put more specific patterns before general ones:</p>
<pre><code class="language-lua">match x
    | 42 -&gt; "forty-two"
    | _ -&gt; "other"
end
</code></pre>
<h3 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h3>
<p>Match expressions must handle all cases:</p>
<ul>
<li>Use wildcard <code>_</code> as catch-all</li>
<li>Or handle all enum variants explicitly</li>
<li>Compiler warns on non-exhaustive matches</li>
</ul>
<h3 id="array-pattern-constraints"><a class="header" href="#array-pattern-constraints">Array Pattern Constraints</a></h3>
<ul>
<li>Rest pattern <code>...rest</code> must be last</li>
<li>Can have at most one rest pattern</li>
<li>Holes <code>_</code> skip elements: <code>[x, _, z]</code></li>
</ul>
<h3 id="object-pattern-constraints"><a class="header" href="#object-pattern-constraints">Object Pattern Constraints</a></h3>
<ul>
<li>Properties can be bound or matched</li>
<li><code>{x}</code> is shorthand for <code>{x = x}</code></li>
<li><code>{x = value}</code> binds <code>x</code> to <code>value</code></li>
</ul>
<h3 id="match-expression-return-types"><a class="header" href="#match-expression-return-types">Match Expression Return Types</a></h3>
<p>All arms must return the same type:</p>
<pre><code class="language-lua">const result: string = match x
    | 0 -&gt; "zero"
    | 1 -&gt; "one"
    | _ -&gt; "many"
end
</code></pre>
<p>Different return types cause type error:</p>
<pre><code class="language-lua">-- Error: Type mismatch
const result = match x
    | 0 -&gt; "zero"   -- string
    | 1 -&gt; 1        -- number (error!)
end
</code></pre>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>Pattern matching compiles to efficient if-else chains:</p>
<ul>
<li>Literal comparisons use <code>==</code></li>
<li>Array/object patterns check structure</li>
<li>Guards evaluated only when pattern matches</li>
<li>No runtime overhead for exhaustiveness checking</li>
</ul>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See Also</a></h2>
<ul>
<li><a href="#enums">Enums</a> — Pattern matching with enums</li>
<li><a href="#type-system">Type System</a> — Union types and narrowing</li>
<li><a href="#functions">Functions</a> — Destructuring parameters</li>
<li><a href="#basics">Basics</a> — Destructuring variable declarations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="decorators"><a class="header" href="#decorators">Decorators</a></h1>
<p>Decorators provide a way to annotate and modify classes and their members. They enable meta-programming patterns like logging, validation, dependency injection, and more.</p>
<h2 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h2>
<pre><code class="language-lua">@decoratorName
@decoratorWithArgs(arg1, arg2)

-- On classes
@decorator
class ClassName
    -- ...
end

-- On class members
class ClassName
    @decorator
    property: Type

    @decorator
    function method(): void
        -- ...
    end

    @decorator
    get property(): Type
        -- ...
    end

    @decorator
    set property(value: Type)
        -- ...
    end

    @decorator
    operator +(other: Type): Type
        -- ...
    end
end
</code></pre>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="basic-decorator"><a class="header" href="#basic-decorator">Basic Decorator</a></h3>
<p>Simple decorator without arguments:</p>
<pre><code class="language-lua">function readonly(target: any, key: string): void
    -- Mark property as readonly
    print(`Marking ${key} as readonly on ${target}`)
end

class User
    @readonly
    id: string

    name: string

    constructor(id: string, name: string)
        self.id = id
        self.name = name
    end
end

const user = User.new("user-123", "Alice")
user.name = "Bob"  -- ✅ OK
-- user.id = "new-id"  -- ❌ Error: Cannot assign to readonly property
</code></pre>
<h3 id="decorator-with-arguments"><a class="header" href="#decorator-with-arguments">Decorator with Arguments</a></h3>
<p>Decorators can accept arguments:</p>
<pre><code class="language-lua">function deprecated(message: string): (target: any, key: string) =&gt; void
    return function(target, key)
        print(`Warning: ${key} is deprecated: ${message}`)
    end
end

class OldAPI
    @deprecated("Use newMethod() instead")
    function oldMethod(): void
        print("Old method")
    end

    function newMethod(): void
        print("New method")
    end
end

const api = OldAPI.new()
api:oldMethod()  -- Warning: oldMethod is deprecated: Use newMethod() instead
</code></pre>
<h3 id="class-decorator"><a class="header" href="#class-decorator">Class Decorator</a></h3>
<p>Decorate entire classes:</p>
<pre><code class="language-lua">function sealed(constructor: any): void
    -- Prevent class extension
    constructor.__sealed = true
end

@sealed
class FinalClass
    value: number

    constructor(value: number)
        self.value = value
    end
end

-- Error: Cannot extend sealed class
-- class Extended extends FinalClass
-- end
</code></pre>
<h3 id="method-decorator"><a class="header" href="#method-decorator">Method Decorator</a></h3>
<p>Add behavior to methods:</p>
<pre><code class="language-lua">function log(target: any, key: string, descriptor: any): void
    const originalMethod = descriptor.value

    descriptor.value = function(...)
        print(`Calling ${key} with arguments:`, ...)
        const result = originalMethod(...)
        print(`${key} returned:`, result)
        return result
    end
end

class Calculator
    @log
    function add(a: number, b: number): number
        return a + b
    end

    @log
    function multiply(a: number, b: number): number
        return a * b
    end
end

const calc = Calculator.new()
calc:add(5, 3)       -- Logs: Calling add with arguments: 5, 3
                      --       add returned: 8
calc:multiply(4, 2)  -- Logs: Calling multiply with arguments: 4, 2
                      --       multiply returned: 8
</code></pre>
<h3 id="property-decorator"><a class="header" href="#property-decorator">Property Decorator</a></h3>
<p>Modify property behavior:</p>
<pre><code class="language-lua">function validate(validator: (value: any) =&gt; boolean): (target: any, key: string) =&gt; void
    return function(target, key)
        const privateKey = "_" .. key

        -- Create getter
        target[`get_${key}`] = function(self)
            return self[privateKey]
        end

        -- Create setter with validation
        target[`set_${key}`] = function(self, value)
            if not validator(value) then
                error(`Invalid value for ${key}: ${value}`)
            end
            self[privateKey] = value
        end
    end
end

class User
    @validate(function(value) return #value &gt;= 3 end)
    name: string

    @validate(function(value) return value &gt;= 18 end)
    age: number

    constructor(name: string, age: number)
        self.name = name
        self.age = age
    end
end

const user = User.new("Alice", 30)
-- user.name = "AB"  -- ❌ Error: Invalid value for name: AB
-- user.age = 10     -- ❌ Error: Invalid value for age: 10
</code></pre>
<h3 id="multiple-decorators"><a class="header" href="#multiple-decorators">Multiple Decorators</a></h3>
<p>Apply multiple decorators (executed bottom-to-top):</p>
<pre><code class="language-lua">@decorator1
@decorator2
@decorator3
class MyClass
    -- Execution order: decorator3, decorator2, decorator1
end

class Example
    @log
    @validate(someValidator)
    @readonly
    property: string
    -- Applied in order: readonly, validate, log
end
</code></pre>
<h3 id="gettersetter-decorators"><a class="header" href="#gettersetter-decorators">Getter/Setter Decorators</a></h3>
<p>Decorate getters and setters:</p>
<pre><code class="language-lua">function memoize(target: any, key: string, descriptor: any): void
    const cache = {}

    const originalGetter = descriptor.get

    descriptor.get = function(self)
        if cache[self] == nil then
            cache[self] = originalGetter(self)
        end
        return cache[self]
    end
end

class ExpensiveCalculator
    private data: number[]

    constructor(data: number[])
        self.data = data
    end

    @memoize
    get sum(): number
        print("Computing sum...")
        local total = 0
        for _, value in ipairs(self.data) do
            total = total + value
        end
        return total
    end
end

const calc = ExpensiveCalculator.new({1, 2, 3, 4, 5})
print(calc.sum)  -- Computing sum... 15
print(calc.sum)  -- 15 (cached, no recomputation)
</code></pre>
<h3 id="operator-decorator"><a class="header" href="#operator-decorator">Operator Decorator</a></h3>
<p>Decorate operator overloads:</p>
<pre><code class="language-lua">function commutative(target: any, key: string, descriptor: any): void
    const originalOp = descriptor.value

    descriptor.value = function(self, other)
        -- Try both orders
        const result = originalOp(self, other) or originalOp(other, self)
        return result
    end
end

class Value
    private value: number

    constructor(value: number)
        self.value = value
    end

    @commutative
    operator +(other: Value): Value
        return Value.new(self.value + other.value)
    end
end
</code></pre>
<h3 id="built-in-decorators"><a class="header" href="#built-in-decorators">Built-in Decorators</a></h3>
<p>LuaNext provides several built-in decorators:</p>
<h4 id="readonly"><a class="header" href="#readonly">@readonly</a></h4>
<p>Mark properties as read-only:</p>
<pre><code class="language-lua">class Config
    @readonly
    version: string

    constructor(version: string)
        self.version = version
    end
end

const config = Config.new("1.0.0")
-- config.version = "2.0.0"  -- ❌ Error
</code></pre>
<h4 id="sealed"><a class="header" href="#sealed">@sealed</a></h4>
<p>Prevent class extension:</p>
<pre><code class="language-lua">@sealed
class FinalClass
    -- Cannot be extended
end
</code></pre>
<h4 id="deprecated"><a class="header" href="#deprecated">@deprecated</a></h4>
<p>Mark members as deprecated:</p>
<pre><code class="language-lua">class API
    @deprecated
    function oldMethod(): void
        print("Old method")
    end

    @deprecated("Use newMethod2() instead")
    function newMethod(): void
        print("New method")
    end
end
</code></pre>
<h3 id="decorator-factory-pattern"><a class="header" href="#decorator-factory-pattern">Decorator Factory Pattern</a></h3>
<p>Create configurable decorators:</p>
<pre><code class="language-lua">function retry(maxAttempts: number, delay: number): (target: any, key: string, descriptor: any) =&gt; void
    return function(target, key, descriptor)
        const originalMethod = descriptor.value

        descriptor.value = function(self, ...)
            local attempts = 0

            while attempts &lt; maxAttempts do
                attempts = attempts + 1

                const success, result = pcall(function()
                    return originalMethod(self, ...)
                end)

                if success then
                    return result
                end

                if attempts &lt; maxAttempts then
                    print(`Retry ${attempts}/${maxAttempts} after ${delay}ms`)
                    sleep(delay)
                end
            end

            error(`Failed after ${maxAttempts} attempts`)
        end
    end
end

class NetworkClient
    @retry(3, 1000)
    function fetchData(url: string): string
        -- May fail, will retry up to 3 times
        return httpGet(url)
    end
end
</code></pre>
<h3 id="type-safe-decorators"><a class="header" href="#type-safe-decorators">Type-Safe Decorators</a></h3>
<p>Decorators with proper typing:</p>
<pre><code class="language-lua">type PropertyDecorator = (target: any, propertyKey: string) =&gt; void
type MethodDecorator = (target: any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; void
type ClassDecorator = (constructor: any) =&gt; void

function enumerable(value: boolean): PropertyDecorator
    return function(target, propertyKey)
        -- Set enumerable property
        target.__enumerable = target.__enumerable or {}
        target.__enumerable[propertyKey] = value
    end
end

class Example
    @enumerable(false)
    private secret: string

    @enumerable(true)
    public data: string
end
</code></pre>
<h3 id="decorator-composition"><a class="header" href="#decorator-composition">Decorator Composition</a></h3>
<p>Combine decorators for complex behavior:</p>
<pre><code class="language-lua">function compose(...decorators: ((target: any, key: string, descriptor: any) =&gt; void)[]): (target: any, key: string, descriptor: any) =&gt; void
    return function(target, key, descriptor)
        for i = #decorators, 1, -1 do
            decorators[i](target, key, descriptor)
        end
    end
end

const logAndValidate = compose(log, validate(someValidator))

class Service
    @logAndValidate
    function process(data: string): void
        -- Both logging and validation applied
    end
end
</code></pre>
<h2 id="details-6"><a class="header" href="#details-6">Details</a></h2>
<h3 id="decorator-targets"><a class="header" href="#decorator-targets">Decorator Targets</a></h3>
<p>Decorators can be applied to:</p>
<ol>
<li><strong>Classes</strong> — Modify class constructors</li>
<li><strong>Properties</strong> — Modify property descriptors</li>
<li><strong>Methods</strong> — Modify method descriptors</li>
<li><strong>Getters</strong> — Modify getter descriptors</li>
<li><strong>Setters</strong> — Modify setter descriptors</li>
<li><strong>Operators</strong> — Modify operator overload descriptors</li>
</ol>
<h3 id="decorator-signatures"><a class="header" href="#decorator-signatures">Decorator Signatures</a></h3>
<p>Different decorator types have different signatures:</p>
<pre><code class="language-lua">-- Class decorator
type ClassDecorator = (constructor: any) =&gt; void

-- Property decorator
type PropertyDecorator = (target: any, propertyKey: string) =&gt; void

-- Method decorator
type MethodDecorator = (target: any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; void
</code></pre>
<h3 id="execution-order"><a class="header" href="#execution-order">Execution Order</a></h3>
<p>When multiple decorators are applied:</p>
<ol>
<li><strong>Decorators are evaluated</strong> top-to-bottom</li>
<li><strong>Decorators are executed</strong> bottom-to-top</li>
</ol>
<pre><code class="language-lua">@first   -- Evaluated 1st, executed 3rd
@second  -- Evaluated 2nd, executed 2nd
@third   -- Evaluated 3rd, executed 1st
class MyClass
end
</code></pre>
<h3 id="propertydescriptor"><a class="header" href="#propertydescriptor">PropertyDescriptor</a></h3>
<p>Method decorators receive a PropertyDescriptor:</p>
<pre><code class="language-lua">interface PropertyDescriptor
    value: any          -- The method function
    writable: boolean   -- Can be reassigned
    enumerable: boolean -- Appears in iteration
    configurable: boolean -- Can be deleted or reconfigured
end
</code></pre>
<h3 id="decorator-metadata"><a class="header" href="#decorator-metadata">Decorator Metadata</a></h3>
<p>Store metadata on decorated members:</p>
<pre><code class="language-lua">function metadata(key: string, value: any): (target: any, propertyKey: string) =&gt; void
    return function(target, propertyKey)
        target.__metadata = target.__metadata or {}
        target.__metadata[propertyKey] = target.__metadata[propertyKey] or {}
        target.__metadata[propertyKey][key] = value
    end
end

class User
    @metadata("required", true)
    @metadata("minLength", 3)
    name: string
end

-- Access metadata
const nameMetadata = User.__metadata.name
print(nameMetadata.required)   -- true
print(nameMetadata.minLength)  -- 3
</code></pre>
<h3 id="compile-time-vs-runtime"><a class="header" href="#compile-time-vs-runtime">Compile-Time vs Runtime</a></h3>
<p>Decorators are:</p>
<ul>
<li><strong>Evaluated at compile time</strong> — Decorator expressions are resolved during compilation</li>
<li><strong>Executed at runtime</strong> — Decorator functions run when the class is defined</li>
</ul>
<h3 id="decorator-limitations"><a class="header" href="#decorator-limitations">Decorator Limitations</a></h3>
<ul>
<li>Cannot add new properties to classes (Lua limitation)</li>
<li>Cannot change property types</li>
<li>Limited reflection capabilities</li>
</ul>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<ol>
<li><strong>Keep decorators pure</strong> — Avoid side effects</li>
<li><strong>Document behavior</strong> — Clearly describe what decorators do</li>
<li><strong>Use type annotations</strong> — Provide proper types for decorator functions</li>
<li><strong>Compose carefully</strong> — Be mindful of decorator interaction</li>
<li><strong>Test thoroughly</strong> — Decorators modify behavior in non-obvious ways</li>
</ol>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See Also</a></h2>
<ul>
<li><a href="#classes">Classes</a> — Class and member declarations</li>
<li><a href="#advanced-types">Advanced Types</a> — Type utilities for decorators</li>
<li><a href="#reflection-api-reference">Reflection</a> — Runtime reflection API</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h1>
<p>LuaNext provides advanced type system features inspired by TypeScript, including conditional types, mapped types, template literal types, type predicates, and more.</p>
<h2 id="conditional-types-1"><a class="header" href="#conditional-types-1">Conditional Types</a></h2>
<p>Conditional types select one of two types based on a condition.</p>
<h3 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h3>
<pre><code class="language-lua">T extends U ? X : Y
</code></pre>
<p>If <code>T</code> extends <code>U</code>, the type resolves to <code>X</code>, otherwise <code>Y</code>.</p>
<h3 id="examples-7"><a class="header" href="#examples-7">Examples</a></h3>
<h4 id="basic-conditional-type"><a class="header" href="#basic-conditional-type">Basic Conditional Type</a></h4>
<pre><code class="language-lua">type IsString&lt;T&gt; = T extends string ? true : false

type A = IsString&lt;string&gt;  -- true
type B = IsString&lt;number&gt;  -- false
</code></pre>
<h4 id="extracting-return-type"><a class="header" href="#extracting-return-type">Extracting Return Type</a></h4>
<pre><code class="language-lua">type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : never

type Func = (x: number) =&gt; string
type Result = ReturnType&lt;Func&gt;  -- string
</code></pre>
<h4 id="distributive-conditional-types"><a class="header" href="#distributive-conditional-types">Distributive Conditional Types</a></h4>
<p>Conditional types distribute over unions:</p>
<pre><code class="language-lua">type ToArray&lt;T&gt; = T extends any ? T[] : never

type Result = ToArray&lt;string | number&gt;
-- Expands to: (string extends any ? string[] : never) | (number extends any ? number[] : never)
-- Result: string[] | number[]
</code></pre>
<h4 id="non-nullable-type"><a class="header" href="#non-nullable-type">Non-Nullable Type</a></h4>
<pre><code class="language-lua">type NonNilable&lt;T&gt; = T extends nil ? never : T

type A = NonNilable&lt;string | nil&gt;  -- string
type B = NonNilable&lt;number | nil&gt;  -- number
</code></pre>
<h2 id="mapped-types-1"><a class="header" href="#mapped-types-1">Mapped Types</a></h2>
<p>Mapped types transform properties of an existing type.</p>
<h3 id="syntax-1-1"><a class="header" href="#syntax-1-1">Syntax</a></h3>
<pre><code class="language-lua">{[K in keyof T]: NewType}
{[K in keyof T]?: NewType}      -- Optional
{readonly [K in keyof T]: NewType}  -- Readonly
</code></pre>
<h3 id="examples-1-1"><a class="header" href="#examples-1-1">Examples</a></h3>
<h4 id="basic-mapped-type"><a class="header" href="#basic-mapped-type">Basic Mapped Type</a></h4>
<pre><code class="language-lua">type Partial&lt;T&gt; = {[K in keyof T]?: T[K]}

interface User
    name: string
    age: number
    email: string
end

type PartialUser = Partial&lt;User&gt;
-- Result:
-- {
--     name?: string,
--     age?: number,
--     email?: string
-- }
</code></pre>
<h4 id="readonly-mapped-type"><a class="header" href="#readonly-mapped-type">Readonly Mapped Type</a></h4>
<pre><code class="language-lua">type Readonly&lt;T&gt; = {readonly [K in keyof T]: T[K]}

type ReadonlyUser = Readonly&lt;User&gt;
-- All properties become readonly
</code></pre>
<h4 id="required-mapped-type"><a class="header" href="#required-mapped-type">Required Mapped Type</a></h4>
<pre><code class="language-lua">type Required&lt;T&gt; = {[K in keyof T]-?: T[K]}

interface PartialConfig
    host?: string
    port?: number
end

type Config = Required&lt;PartialConfig&gt;
-- Both properties become required
</code></pre>
<h4 id="adding-and-removing-modifiers"><a class="header" href="#adding-and-removing-modifiers">Adding and Removing Modifiers</a></h4>
<pre><code class="language-lua">-- Add readonly
type AddReadonly&lt;T&gt; = {+readonly [K in keyof T]: T[K]}

-- Remove readonly
type RemoveReadonly&lt;T&gt; = {-readonly [K in keyof T]: T[K]}

-- Add optional
type AddOptional&lt;T&gt; = {[K in keyof T]+?: T[K]}

-- Remove optional (make required)
type RemoveOptional&lt;T&gt; = {[K in keyof T]-?: T[K]}
</code></pre>
<h4 id="record-type"><a class="header" href="#record-type">Record Type</a></h4>
<pre><code class="language-lua">type Record&lt;K extends string | number, T&gt; = {[P in K]: T}

type StringMap = Record&lt;string, number&gt;
-- {[key: string]: number}

type Status = "pending" | "active" | "completed"
type StatusRecord = Record&lt;Status, boolean&gt;
-- {
--     pending: boolean,
--     active: boolean,
--     completed: boolean
-- }
</code></pre>
<h2 id="template-literal-types-1"><a class="header" href="#template-literal-types-1">Template Literal Types</a></h2>
<p>Create types from template string patterns.</p>
<h3 id="syntax-2-1"><a class="header" href="#syntax-2-1">Syntax</a></h3>
<pre><code class="language-lua">type Pattern = `prefix_${T}_suffix`
</code></pre>
<h3 id="examples-2-1"><a class="header" href="#examples-2-1">Examples</a></h3>
<h4 id="basic-template-literal-type"><a class="header" href="#basic-template-literal-type">Basic Template Literal Type</a></h4>
<pre><code class="language-lua">type EventName&lt;T extends string&gt; = `on${T}Changed`

type NameEvent = EventName&lt;"name"&gt;  -- "onNameChanged"
type AgeEvent = EventName&lt;"age"&gt;    -- "onAgeChanged"
</code></pre>
<h4 id="combining-with-unions"><a class="header" href="#combining-with-unions">Combining with Unions</a></h4>
<pre><code class="language-lua">type HTTPVerb = "GET" | "POST" | "PUT" | "DELETE"
type Endpoint = `/${HTTPVerb}`

-- Result: "/GET" | "/POST" | "/PUT" | "/DELETE"
</code></pre>
<h4 id="multiple-interpolations"><a class="header" href="#multiple-interpolations">Multiple Interpolations</a></h4>
<pre><code class="language-lua">type EventHandler&lt;T extends string, U extends string&gt; = `on${T}${U}`

type Handler = EventHandler&lt;"User", "Created"&gt;  -- "onUserCreated"
</code></pre>
<h2 id="type-queries-typeof"><a class="header" href="#type-queries-typeof">Type Queries (typeof)</a></h2>
<p>Extract the type of a value.</p>
<h3 id="syntax-3-1"><a class="header" href="#syntax-3-1">Syntax</a></h3>
<pre><code class="language-lua">typeof expression
</code></pre>
<h3 id="examples-3-1"><a class="header" href="#examples-3-1">Examples</a></h3>
<pre><code class="language-lua">const config = {
    host = "localhost",
    port = 8080,
    ssl = true
}

type Config = typeof config
-- Result:
-- {
--     host: string,
--     port: number,
--     ssl: boolean
-- }
</code></pre>
<h4 id="with-functions"><a class="header" href="#with-functions">With Functions</a></h4>
<pre><code class="language-lua">function add(a: number, b: number): number
    return a + b
end

type AddType = typeof add
-- (a: number, b: number) =&gt; number
</code></pre>
<h2 id="keyof-type-operator"><a class="header" href="#keyof-type-operator">KeyOf Type Operator</a></h2>
<p>Get union of all property keys.</p>
<h3 id="syntax-4-1"><a class="header" href="#syntax-4-1">Syntax</a></h3>
<pre><code class="language-lua">keyof T
</code></pre>
<h3 id="examples-4-1"><a class="header" href="#examples-4-1">Examples</a></h3>
<pre><code class="language-lua">interface Point
    x: number
    y: number
    z: number
end

type PointKeys = keyof Point
-- "x" | "y" | "z"
</code></pre>
<h4 id="with-index-signatures"><a class="header" href="#with-index-signatures">With Index Signatures</a></h4>
<pre><code class="language-lua">interface StringMap
    [key: string]: any
end

type Keys = keyof StringMap
-- string
</code></pre>
<h2 id="indexed-access-types"><a class="header" href="#indexed-access-types">Indexed Access Types</a></h2>
<p>Access the type of a property.</p>
<h3 id="syntax-5-1"><a class="header" href="#syntax-5-1">Syntax</a></h3>
<pre><code class="language-lua">T[K]
</code></pre>
<h3 id="examples-5-1"><a class="header" href="#examples-5-1">Examples</a></h3>
<pre><code class="language-lua">interface User
    name: string
    age: number
    email: string
end

type NameType = User["name"]    -- string
type AgeType = User["age"]      -- number
</code></pre>
<h4 id="with-keyof"><a class="header" href="#with-keyof">With keyof</a></h4>
<pre><code class="language-lua">type PropertyType = User[keyof User]
-- string | number (union of all property types)
</code></pre>
<h2 id="infer-keyword-1"><a class="header" href="#infer-keyword-1">Infer Keyword</a></h2>
<p>Extract types within conditional types.</p>
<h3 id="syntax-6-1"><a class="header" href="#syntax-6-1">Syntax</a></h3>
<pre><code class="language-lua">T extends Pattern&lt;infer U&gt; ? U : never
</code></pre>
<h3 id="examples-6-1"><a class="header" href="#examples-6-1">Examples</a></h3>
<h4 id="inferring-return-type"><a class="header" href="#inferring-return-type">Inferring Return Type</a></h4>
<pre><code class="language-lua">type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : never

type Func1 = () =&gt; string
type Func2 = () =&gt; number

type R1 = ReturnType&lt;Func1&gt;  -- string
type R2 = ReturnType&lt;Func2&gt;  -- number
</code></pre>
<h4 id="inferring-array-element-type"><a class="header" href="#inferring-array-element-type">Inferring Array Element Type</a></h4>
<pre><code class="language-lua">type ElementType&lt;T&gt; = T extends (infer U)[] ? U : never

type A = ElementType&lt;string[]&gt;  -- string
type B = ElementType&lt;number[]&gt;  -- number
</code></pre>
<h4 id="inferring-function-parameters"><a class="header" href="#inferring-function-parameters">Inferring Function Parameters</a></h4>
<pre><code class="language-lua">type Parameters&lt;T&gt; = T extends (...args: infer P) =&gt; any ? P : never

type Func = (a: string, b: number) =&gt; void
type Params = Parameters&lt;Func&gt;  -- [string, number]
</code></pre>
<h2 id="type-predicates-1"><a class="header" href="#type-predicates-1">Type Predicates</a></h2>
<p>Type guards with predicates.</p>
<h3 id="syntax-7-1"><a class="header" href="#syntax-7-1">Syntax</a></h3>
<pre><code class="language-lua">parameter is Type
</code></pre>
<h3 id="examples-7-1"><a class="header" href="#examples-7-1">Examples</a></h3>
<pre><code class="language-lua">function isString(value: unknown): value is string
    return type(value) == "string"
end

function process(value: string | number): void
    if isString(value) then
        -- value is string here
        print(value:upper())
    else
        -- value is number here
        print(value * 2)
    end
end
</code></pre>
<h4 id="custom-type-guards"><a class="header" href="#custom-type-guards">Custom Type Guards</a></h4>
<pre><code class="language-lua">interface Dog
    bark(): void
end

interface Cat
    meow(): void
end

function isDog(animal: Dog | Cat): animal is Dog
    return (animal as any).bark ~= nil
end

function handleAnimal(animal: Dog | Cat): void
    if isDog(animal) then
        animal:bark()
    else
        animal:meow()
    end
end
</code></pre>
<h2 id="variadic-types-1"><a class="header" href="#variadic-types-1">Variadic Types</a></h2>
<p>Handle variable-length return types.</p>
<h3 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h3>
<pre><code class="language-lua">...T[]
</code></pre>
<h3 id="examples-8"><a class="header" href="#examples-8">Examples</a></h3>
<pre><code class="language-lua">function tuple&lt;T...&gt;(...args: T...): T...
    return ...
end

const [a, b, c] = tuple(1, "hello", true)
-- a: number, b: string, c: boolean
</code></pre>
<h2 id="utility-types"><a class="header" href="#utility-types">Utility Types</a></h2>
<p>LuaNext provides built-in utility types:</p>
<h3 id="partial"><a class="header" href="#partial">Partial<t></t></a></h3>
<p>Make all properties optional:</p>
<pre><code class="language-lua">type Partial&lt;T&gt; = {[K in keyof T]?: T[K]}
</code></pre>
<h3 id="required"><a class="header" href="#required">Required<t></t></a></h3>
<p>Make all properties required:</p>
<pre><code class="language-lua">type Required&lt;T&gt; = {[K in keyof T]-?: T[K]}
</code></pre>
<h3 id="readonly-1"><a class="header" href="#readonly-1">Readonly<t></t></a></h3>
<p>Make all properties readonly:</p>
<pre><code class="language-lua">type Readonly&lt;T&gt; = {readonly [K in keyof T]: T[K]}
</code></pre>
<h3 id="recordk-t"><a class="header" href="#recordk-t">Record&lt;K, T&gt;</a></h3>
<p>Create object type with keys K and values T:</p>
<pre><code class="language-lua">type Record&lt;K extends string | number, T&gt; = {[P in K]: T}
</code></pre>
<h3 id="pickt-k"><a class="header" href="#pickt-k">Pick&lt;T, K&gt;</a></h3>
<p>Pick subset of properties:</p>
<pre><code class="language-lua">type Pick&lt;T, K extends keyof T&gt; = {[P in K]: T[P]}

interface User
    id: string
    name: string
    email: string
    age: number
end

type UserPreview = Pick&lt;User, "id" | "name"&gt;
-- {id: string, name: string}
</code></pre>
<h3 id="omitt-k"><a class="header" href="#omitt-k">Omit&lt;T, K&gt;</a></h3>
<p>Omit properties:</p>
<pre><code class="language-lua">type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;

type UserWithoutEmail = Omit&lt;User, "email"&gt;
-- {id: string, name: string, age: number}
</code></pre>
<h3 id="excludet-u"><a class="header" href="#excludet-u">Exclude&lt;T, U&gt;</a></h3>
<p>Exclude types from union:</p>
<pre><code class="language-lua">type Exclude&lt;T, U&gt; = T extends U ? never : T

type A = Exclude&lt;"a" | "b" | "c", "a"&gt;  -- "b" | "c"
</code></pre>
<h3 id="extractt-u"><a class="header" href="#extractt-u">Extract&lt;T, U&gt;</a></h3>
<p>Extract types from union:</p>
<pre><code class="language-lua">type Extract&lt;T, U&gt; = T extends U ? T : never

type A = Extract&lt;"a" | "b" | "c", "a" | "d"&gt;  -- "a"
</code></pre>
<h3 id="nonnilable"><a class="header" href="#nonnilable">NonNilable<t></t></a></h3>
<p>Remove nil from type:</p>
<pre><code class="language-lua">type NonNilable&lt;T&gt; = T extends nil ? never : T

type A = NonNilable&lt;string | nil&gt;  -- string
</code></pre>
<h3 id="nilable"><a class="header" href="#nilable">Nilable<t></t></a></h3>
<p>Add nil to type:</p>
<pre><code class="language-lua">type Nilable&lt;T&gt; = T | nil
</code></pre>
<h3 id="returntype"><a class="header" href="#returntype">ReturnType<t></t></a></h3>
<p>Extract function return type:</p>
<pre><code class="language-lua">type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : never
</code></pre>
<h3 id="parameters"><a class="header" href="#parameters">Parameters<t></t></a></h3>
<p>Extract function parameter types:</p>
<pre><code class="language-lua">type Parameters&lt;T&gt; = T extends (...args: infer P) =&gt; any ? P : never
</code></pre>
<h2 id="complex-type-transformations"><a class="header" href="#complex-type-transformations">Complex Type Transformations</a></h2>
<h3 id="flatten-object-type"><a class="header" href="#flatten-object-type">Flatten Object Type</a></h3>
<pre><code class="language-lua">type Flatten&lt;T&gt; = T extends object ? {[K in keyof T]: T[K]} : T
</code></pre>
<h3 id="deep-partial"><a class="header" href="#deep-partial">Deep Partial</a></h3>
<pre><code class="language-lua">type DeepPartial&lt;T&gt; = {
    [K in keyof T]?: T[K] extends object ? DeepPartial&lt;T[K]&gt; : T[K]
}
</code></pre>
<h3 id="deep-readonly"><a class="header" href="#deep-readonly">Deep Readonly</a></h3>
<pre><code class="language-lua">type DeepReadonly&lt;T&gt; = {
    readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K]
}
</code></pre>
<h3 id="mutable-remove-readonly"><a class="header" href="#mutable-remove-readonly">Mutable (Remove Readonly)</a></h3>
<pre><code class="language-lua">type Mutable&lt;T&gt; = {
    -readonly [K in keyof T]: T[K]
}
</code></pre>
<h2 id="type-constraints"><a class="header" href="#type-constraints">Type Constraints</a></h2>
<p>Constrain type parameters:</p>
<pre><code class="language-lua">type Lengthwise = {length: number}

function logLength&lt;T extends Lengthwise&gt;(arg: T): void
    print(arg.length)
end

logLength({length = 10})      -- ✅ OK
logLength([1, 2, 3])          -- ✅ OK (arrays have length)
-- logLength(42)              -- ❌ Error: number doesn't have length
</code></pre>
<h2 id="details-7"><a class="header" href="#details-7">Details</a></h2>
<h3 id="conditional-type-inference"><a class="header" href="#conditional-type-inference">Conditional Type Inference</a></h3>
<p>When using <code>infer</code>, the inferred type is captured and can be used in the true branch:</p>
<pre><code class="language-lua">type UnpackArray&lt;T&gt; = T extends (infer U)[] ? U : T

type A = UnpackArray&lt;string[]&gt;  -- string
type B = UnpackArray&lt;number&gt;    -- number (fallback)
</code></pre>
<h3 id="mapped-type-modifiers"><a class="header" href="#mapped-type-modifiers">Mapped Type Modifiers</a></h3>
<ul>
<li><code>+?</code> or <code>?</code> — Make optional</li>
<li><code>-?</code> — Make required</li>
<li><code>+readonly</code> or <code>readonly</code> — Make readonly</li>
<li><code>-readonly</code> — Remove readonly</li>
</ul>
<h3 id="template-literal-type-inference"><a class="header" href="#template-literal-type-inference">Template Literal Type Inference</a></h3>
<p>Template literal types support inference:</p>
<pre><code class="language-lua">type ExtractVersion&lt;T&gt; = T extends `v${infer N}` ? N : never

type A = ExtractVersion&lt;"v1.0.0"&gt;  -- "1.0.0"
</code></pre>
<h3 id="distributive-conditional-types-1"><a class="header" href="#distributive-conditional-types-1">Distributive Conditional Types</a></h3>
<p>Conditional types distribute over unions automatically:</p>
<pre><code class="language-lua">type ToArray&lt;T&gt; = T extends any ? T[] : never

type Result = ToArray&lt;string | number&gt;
-- Distributes to: ToArray&lt;string&gt; | ToArray&lt;number&gt;
-- Result: string[] | number[]
</code></pre>
<p>Wrap in <code>[]</code> to prevent distribution:</p>
<pre><code class="language-lua">type ToArray&lt;T&gt; = [T] extends [any] ? T[] : never

type Result = ToArray&lt;string | number&gt;
-- Result: (string | number)[]
</code></pre>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See Also</a></h2>
<ul>
<li><a href="#type-system">Type System</a> — Basic type system features</li>
<li><a href="#interfaces">Interfaces</a> — Object type definitions</li>
<li><a href="#generics-1">Generics</a> — Generic types</li>
<li><a href="#utility-types-reference">Utility Types</a> — Complete utility type reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>LuaNext provides a comprehensive set of operators for arithmetic, comparison, logical operations, bitwise operations, and special operators like optional chaining, null coalescing, and more.</p>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<h3 id="basic-arithmetic"><a class="header" href="#basic-arithmetic">Basic Arithmetic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>+</code></td><td>Addition</td><td><code>5 + 3</code></td><td><code>8</code></td></tr>
<tr><td><code>-</code></td><td>Subtraction</td><td><code>10 - 4</code></td><td><code>6</code></td></tr>
<tr><td><code>*</code></td><td>Multiplication</td><td><code>6 * 7</code></td><td><code>42</code></td></tr>
<tr><td><code>/</code></td><td>Division</td><td><code>15 / 3</code></td><td><code>5.0</code></td></tr>
<tr><td><code>%</code></td><td>Modulo</td><td><code>17 % 5</code></td><td><code>2</code></td></tr>
<tr><td><code>^</code></td><td>Exponentiation</td><td><code>2 ^ 10</code></td><td><code>1024</code></td></tr>
<tr><td><code>//</code></td><td>Floor division</td><td><code>17 // 5</code></td><td><code>3</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const a: number = 10 + 5   -- 15
const b: number = 20 - 7   -- 13
const c: number = 6 * 4    -- 24
const d: number = 15 / 3   -- 5.0
const e: number = 17 % 5   -- 2
const f: number = 2 ^ 10   -- 1024
const g: number = 17 // 5  -- 3 (floor division)
</code></pre>
<h3 id="unary-arithmetic"><a class="header" href="#unary-arithmetic">Unary Arithmetic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>-</code></td><td>Negation</td><td><code>-5</code></td><td><code>-5</code></td></tr>
<tr><td><code>#</code></td><td>Length</td><td><code>#{1,2,3}</code></td><td><code>3</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const x: number = 10
const negated: number = -x  -- -10

const arr: number[] = {1, 2, 3, 4, 5}
const length: number = #arr  -- 5

const str: string = "hello"
const strLen: number = #str  -- 5
</code></pre>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>==</code></td><td>Equal</td><td><code>5 == 5</code></td></tr>
<tr><td><code>~=</code></td><td>Not equal</td><td><code>5 ~= 3</code></td></tr>
<tr><td><code>&lt;</code></td><td>Less than</td><td><code>3 &lt; 5</code></td></tr>
<tr><td><code>&lt;=</code></td><td>Less than or equal</td><td><code>5 &lt;= 5</code></td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td><td><code>7 &gt; 3</code></td></tr>
<tr><td><code>&gt;=</code></td><td>Greater than or equal</td><td><code>5 &gt;= 5</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const isEqual: boolean = 5 == 5          -- true
const notEqual: boolean = 5 ~= 3         -- true
const lessThan: boolean = 3 &lt; 5          -- true
const lessOrEqual: boolean = 5 &lt;= 5      -- true
const greaterThan: boolean = 7 &gt; 3       -- true
const greaterOrEqual: boolean = 5 &gt;= 5   -- true
</code></pre>
<h2 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>and</code></td><td>Logical AND</td><td><code>true and false</code></td></tr>
<tr><td><code>or</code></td><td>Logical OR</td><td><code>true or false</code></td></tr>
<tr><td><code>not</code></td><td>Logical NOT</td><td><code>not true</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const result1: boolean = true and false   -- false
const result2: boolean = true or false    -- true
const result3: boolean = not true         -- false

-- Short-circuit evaluation
const value = x &gt; 0 and x or 0  -- Returns x if x &gt; 0, else 0
</code></pre>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h2>
<p>Available in Lua 5.3+:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>&amp;</code></td><td>Bitwise AND</td><td><code>12 &amp; 10</code></td></tr>
<tr><td>`</td><td>`</td><td>Bitwise OR</td></tr>
<tr><td><code>~</code> (unary)</td><td>Bitwise NOT</td><td><code>~5</code></td></tr>
<tr><td><code>~</code> (binary)</td><td>Bitwise XOR</td><td><code>12 ~ 10</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>Left shift</td><td><code>1 &lt;&lt; 3</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>Right shift</td><td><code>8 &gt;&gt; 2</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const a: integer = 12       -- 1100 in binary
const b: integer = 10       -- 1010 in binary

const bitwiseAnd: integer = a &amp; b   -- 8 (1000)
const bitwiseOr: integer = a | b    -- 14 (1110)
const bitwiseXor: integer = a ~ b   -- 6 (0110)
const bitwiseNot: integer = ~a      -- -13
const leftShift: integer = 1 &lt;&lt; 3   -- 8 (1 * 2^3)
const rightShift: integer = 8 &gt;&gt; 2  -- 2 (8 / 2^2)
</code></pre>
<h2 id="string-concatenation"><a class="header" href="#string-concatenation">String Concatenation</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>..</code></td><td>Concatenate</td><td><code>"Hello" .. " World"</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const greeting: string = "Hello" .. " " .. "World"  -- "Hello World"
const message: string = "Count: " .. tostring(42)    -- "Count: 42"
</code></pre>
<h2 id="compound-assignment"><a class="header" href="#compound-assignment">Compound Assignment</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Equivalent</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>+=</code></td><td><code>x = x + y</code></td><td>Add and assign</td></tr>
<tr><td><code>-=</code></td><td><code>x = x - y</code></td><td>Subtract and assign</td></tr>
<tr><td><code>*=</code></td><td><code>x = x * y</code></td><td>Multiply and assign</td></tr>
<tr><td><code>/=</code></td><td><code>x = x / y</code></td><td>Divide and assign</td></tr>
<tr><td><code>%=</code></td><td><code>x = x % y</code></td><td>Modulo and assign</td></tr>
<tr><td><code>^=</code></td><td><code>x = x ^ y</code></td><td>Exponentiate and assign</td></tr>
<tr><td><code>//=</code></td><td><code>x = x // y</code></td><td>Floor divide and assign</td></tr>
<tr><td><code>..=</code></td><td><code>x = x .. y</code></td><td>Concatenate and assign</td></tr>
<tr><td><code>&amp;=</code></td><td><code>x = x &amp; y</code></td><td>Bitwise AND and assign</td></tr>
<tr><td>`</td><td>=`</td><td>`x = x</td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>x = x &lt;&lt; y</code></td><td>Left shift and assign</td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>x = x &gt;&gt; y</code></td><td>Right shift and assign</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">local x: number = 10
x += 5   -- x = 15
x -= 3   -- x = 12
x *= 2   -- x = 24
x /= 4   -- x = 6.0
x %= 5   -- x = 1.0
x ^= 3   -- x = 1.0

local s: string = "Hello"
s ..= " World"  -- s = "Hello World"

local flags: integer = 0b1100
flags &amp;= 0b1010  -- flags = 0b1000
</code></pre>
<h2 id="optional-chaining-1"><a class="header" href="#optional-chaining-1">Optional Chaining</a></h2>
<p>Safely access nested properties that might be nil:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>?.</code></td><td>Optional member access</td><td><code>obj?.property</code></td></tr>
<tr><td><code>?[]</code></td><td>Optional index access</td><td><code>arr?[1]</code></td></tr>
<tr><td><code>?()</code></td><td>Optional call</td><td><code>func?()</code></td></tr>
<tr><td><code>?:</code></td><td>Optional method call</td><td><code>obj?:method()</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">interface User
    name: string
    address?: {
        street: string
        city: string
    }
end

const user: User | nil = getUser()

-- Without optional chaining (verbose)
const city1 = user ~= nil and user.address ~= nil and user.address.city or nil

-- With optional chaining (concise)
const city2 = user?.address?.city  -- nil if user or address is nil

-- Optional method call
const result = obj?:method()  -- Only calls if obj is not nil

-- Optional function call
const value = func?()  -- Only calls if func is not nil

-- Optional index
const item = array?[1]  -- nil if array is nil
</code></pre>
<h2 id="null-coalescing"><a class="header" href="#null-coalescing">Null Coalescing</a></h2>
<p>Provide default values for nil:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>??</code></td><td>Null coalesce</td><td><code>value ?? default</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const name: string = user?.name ?? "Anonymous"
const port: number = config?.port ?? 8080
const items: string[] = data?.items ?? {}

-- Chaining
const value = a ?? b ?? c ?? defaultValue
</code></pre>
<p>Difference from <code>or</code>:</p>
<pre><code class="language-lua">-- or returns right side for any falsy value (nil, false)
const x = false or "default"  -- "default"

-- ?? only returns right side for nil
const y = false ?? "default"  -- false
</code></pre>
<h2 id="ternary-operator-1"><a class="header" href="#ternary-operator-1">Ternary Operator</a></h2>
<p>Conditional expression:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>? :</code></td><td>Ternary</td><td><code>condition ? trueValue : falseValue</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const max = a &gt; b ? a : b
const status = isActive ? "Active" : "Inactive"
const message = count &gt; 0 ? `${count} items` : "No items"

-- Nested ternary
const category = score &gt;= 90 ? "A" :
                 score &gt;= 80 ? "B" :
                 score &gt;= 70 ? "C" : "F"
</code></pre>
<h2 id="pipe-operator"><a class="header" href="#pipe-operator">Pipe Operator</a></h2>
<p>Chain function calls:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>`</td><td>&gt;`</td><td>Pipe</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const result = data
    |&gt; parseJSON
    |&gt; validateData
    |&gt; transform
    |&gt; stringify

-- Equivalent to:
const result = stringify(transform(validateData(parseJSON(data))))

-- With arguments
const result = data
    |&gt; trim
    |&gt; split(_, ",")
    |&gt; map(_, parseInt)
    |&gt; filter(_, isPositive)
</code></pre>
<h2 id="error-chain-operator-1"><a class="header" href="#error-chain-operator-1">Error Chain Operator</a></h2>
<p>Shorthand for try-catch:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>!!</code></td><td>Error chain</td><td><code>operation() !! fallback</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const data = fetchData() !! defaultData
const config = loadConfig() !! getDefaultConfig()

-- Equivalent to:
const data = try fetchData() catch _ =&gt; defaultData
</code></pre>
<h2 id="instanceof-operator"><a class="header" href="#instanceof-operator">Instanceof Operator</a></h2>
<p>Check instance types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>instanceof</code></td><td>Type check</td><td><code>obj instanceof ClassName</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">if user instanceof AdminUser then
    print("User is an admin")
end

function handleAnimal(animal: Animal): void
    if animal instanceof Dog then
        animal:bark()
    elseif animal instanceof Cat then
        animal:meow()
    end
end
</code></pre>
<h2 id="type-assertion"><a class="header" href="#type-assertion">Type Assertion</a></h2>
<p>Cast types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>as</code></td><td>Type assertion</td><td><code>value as Type</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-lua">const data: unknown = getData()
const user = data as User

const num = someValue as number
const str = someValue as string

-- Use with caution—bypasses type checking
</code></pre>
<h2 id="spread-and-rest"><a class="header" href="#spread-and-rest">Spread and Rest</a></h2>
<h3 id="spread-operator"><a class="header" href="#spread-operator">Spread Operator</a></h3>
<p>Expand arrays or objects:</p>
<pre><code class="language-lua">-- Array spread
const arr1 = {1, 2, 3}
const arr2 = {4, 5, 6}
const combined = {...arr1, ...arr2}  -- {1, 2, 3, 4, 5, 6}

-- Object spread
const obj1 = {x = 1, y = 2}
const obj2 = {y = 3, z = 4}
const merged = {...obj1, ...obj2}  -- {x = 1, y = 3, z = 4}
</code></pre>
<h3 id="rest-operator"><a class="header" href="#rest-operator">Rest Operator</a></h3>
<p>Collect remaining elements:</p>
<pre><code class="language-lua">-- Function parameters
function sum(...numbers: number[]): number
    local total = 0
    for _, n in ipairs(numbers) do
        total += n
    end
    return total
end

print(sum(1, 2, 3, 4, 5))  -- 15

-- Array destructuring
const [first, ...rest] = {1, 2, 3, 4, 5}
-- first = 1, rest = {2, 3, 4, 5}

-- Object destructuring
const {x, ...remaining} = {x = 1, y = 2, z = 3}
-- x = 1, remaining = {y = 2, z = 3}
</code></pre>
<h2 id="precedence"><a class="header" href="#precedence">Precedence</a></h2>
<p>Operators listed from highest to lowest precedence:</p>
<ol>
<li><strong>Member access</strong>: <code>.</code>, <code>[]</code>, <code>:</code></li>
<li><strong>Function call</strong>: <code>()</code></li>
<li><strong>Unary</strong>: <code>not</code>, <code>-</code>, <code>#</code>, <code>~</code></li>
<li><strong>Exponentiation</strong>: <code>^</code></li>
<li><strong>Multiplicative</strong>: <code>*</code>, <code>/</code>, <code>%</code>, <code>//</code></li>
<li><strong>Additive</strong>: <code>+</code>, <code>-</code></li>
<li><strong>Concatenation</strong>: <code>..</code></li>
<li><strong>Bitwise shift</strong>: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li><strong>Bitwise AND</strong>: <code>&amp;</code></li>
<li><strong>Bitwise XOR</strong>: <code>~</code></li>
<li><strong>Bitwise OR</strong>: <code>|</code></li>
<li><strong>Comparison</strong>: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>~=</code>, <code>instanceof</code></li>
<li><strong>Logical AND</strong>: <code>and</code></li>
<li><strong>Logical OR</strong>: <code>or</code></li>
<li><strong>Null coalesce</strong>: <code>??</code></li>
<li><strong>Ternary</strong>: <code>? :</code></li>
<li><strong>Pipe</strong>: <code>|&gt;</code></li>
<li><strong>Error chain</strong>: <code>!!</code></li>
<li><strong>Assignment</strong>: <code>=</code>, <code>+=</code>, <code>-=</code>, etc.</li>
</ol>
<p>Use parentheses for clarity:</p>
<pre><code class="language-lua">const result = (a + b) * c     -- Explicit grouping
const value = x &gt; 0 and y or z  -- Can be ambiguous, use parens
const value = (x &gt; 0) and y or z  -- Clear precedence
</code></pre>
<h2 id="operator-overloading-1"><a class="header" href="#operator-overloading-1">Operator Overloading</a></h2>
<p>Classes can overload operators:</p>
<pre><code class="language-lua">class Vector(public x: number, public y: number)
    operator +(other: Vector): Vector
        return Vector.new(self.x + other.x, self.y + other.y)
    end

    operator -(other: Vector): Vector
        return Vector.new(self.x - other.x, self.y - other.y)
    end

    operator *(scalar: number): Vector
        return Vector.new(self.x * scalar, self.y * scalar)
    end

    operator ==(other: Vector): boolean
        return self.x == other.x and self.y == other.y
    end

    operator #(): number
        return math.sqrt(self.x * self.x + self.y * self.y)
    end
end

const v1 = Vector.new(1, 2)
const v2 = Vector.new(3, 4)
const v3 = v1 + v2          -- Vector(4, 6)
const v4 = v1 * 2           -- Vector(2, 4)
const equal = v1 == v2      -- false
const length = #v1          -- 2.236...
</code></pre>
<h2 id="see-also-12"><a class="header" href="#see-also-12">See Also</a></h2>
<ul>
<li><a href="#classes">Classes</a> — Operator overloading</li>
<li><a href="#error-handling">Error Handling</a> — Error chain operator</li>
<li><a href="#type-system">Type System</a> — Type assertions and instanceof</li>
<li><a href="#advanced-types">Advanced Types</a> — Type operators</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="migrating-from-lua"><a class="header" href="#migrating-from-lua">Migrating from Lua</a></h1>
<p>This guide helps you migrate existing Lua code to LuaNext, taking advantage of static typing and modern features while maintaining compatibility.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>LuaNext is a <strong>gradual typing</strong> system, meaning you can:</p>
<ol>
<li>Start with zero type annotations (valid Lua is valid LuaNext)</li>
<li>Add types incrementally where they provide value</li>
<li>Gradually enable modern features (OOP, FP, decorators)</li>
<li>Maintain full compatibility with existing Lua code</li>
</ol>
<h2 id="migration-strategy"><a class="header" href="#migration-strategy">Migration Strategy</a></h2>
<h3 id="quick-start-three-step-migration"><a class="header" href="#quick-start-three-step-migration">Quick Start: Three-Step Migration</a></h3>
<ol>
<li><strong>Rename files</strong> — Change <code>.lua</code> to <code>.luax</code></li>
<li><strong>Compile</strong> — Run <code>luanext your-file.luax</code> (should work immediately)</li>
<li><strong>Add types gradually</strong> — Start with function signatures, then variables</li>
</ol>
<h3 id="recommended-approach"><a class="header" href="#recommended-approach">Recommended Approach</a></h3>
<p>For large codebases:</p>
<ol>
<li><strong>Start at the edges</strong> — Add types to public APIs first</li>
<li><strong>Work inward</strong> — Type internal modules once APIs are typed</li>
<li><strong>Use <code>unknown</code></strong> — For complex external data, use <code>unknown</code> and narrow</li>
<li><strong>Enable features incrementally</strong> — Turn on <code>strictNullChecks</code>, OOP, FP as needed</li>
</ol>
<h2 id="basic-syntax-changes"><a class="header" href="#basic-syntax-changes">Basic Syntax Changes</a></h2>
<h3 id="variable-declarations-1"><a class="header" href="#variable-declarations-1">Variable Declarations</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">local x = 10
local name = "Alice"
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- Mutable variables (same as Lua)
local x: number = 10
local name: string = "Alice"

-- Immutable variables (new)
const PI: number = 3.14159
const status: string = "active"
</code></pre>
<p><strong>Migration tip:</strong> Use <code>const</code> for values that never change. This catches accidental reassignment bugs and enables better type inference.</p>
<h3 id="function-declarations-1"><a class="header" href="#function-declarations-1">Function Declarations</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">function add(a, b)
    return a + b
end

function greet(name)
    print("Hello, " .. name)
end
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- Add parameter and return types
function add(a: number, b: number): number
    return a + b
end

function greet(name: string): void
    print("Hello, " .. name)
end

-- Types can be inferred for simple cases
function double(x: number)  -- return type inferred as number
    return x * 2
end
</code></pre>
<p><strong>Migration tip:</strong> Start by adding types to function signatures. This documents intent and catches type errors at call sites.</p>
<h3 id="table-types"><a class="header" href="#table-types">Table Types</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">local point = {x = 10, y = 20}

function distance(p1, p2)
    local dx = p2.x - p1.x
    local dy = p2.y - p1.y
    return math.sqrt(dx * dx + dy * dy)
end
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- Define table shape with interface
interface Point
    x: number
    y: number
end

const point: Point = {x = 10, y = 20}

function distance(p1: Point, p2: Point): number
    const dx = p2.x - p1.x
    const dy = p2.y - p1.y
    return math.sqrt(dx * dx + dy * dy)
end

-- Or use inline types for one-offs
const config: {host: string, port: number} = {
    host = "localhost",
    port = 8080
}
</code></pre>
<p><strong>Migration tip:</strong> Create interfaces for tables used in multiple places. Use inline types for local, one-off tables.</p>
<h3 id="arrays-1"><a class="header" href="#arrays-1">Arrays</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">local numbers = {1, 2, 3, 4, 5}
local names = {"Alice", "Bob", "Charlie"}
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- Add array type annotations
const numbers: number[] = {1, 2, 3, 4, 5}
const names: string[] = {"Alice", "Bob", "Charlie"}

-- Generic syntax (equivalent)
const items: Array&lt;string&gt; = {"a", "b", "c"}
</code></pre>
<h2 id="handling-nil"><a class="header" href="#handling-nil">Handling Nil</a></h2>
<h3 id="nullable-types-2"><a class="header" href="#nullable-types-2">Nullable Types</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">local value = nil
value = "hello"

function findUser(id)
    -- May return nil
    return users[id]
end
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- Explicitly allow nil with union type
local value: string | nil = nil
value = "hello"

function findUser(id: string): User | nil
    return users[id]
end

-- Check for nil before use
const user = findUser("123")
if user ~= nil then
    print(user.name)  -- user is User here (narrowed)
end
</code></pre>
<p><strong>Migration tip:</strong> Enable <code>strictNullChecks</code> in config to catch nil-related bugs. This forces explicit nil handling.</p>
<h3 id="optional-chaining-new-feature"><a class="header" href="#optional-chaining-new-feature">Optional Chaining (New Feature)</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">-- Verbose nil checking
local city = nil
if user ~= nil and user.address ~= nil then
    city = user.address.city
end
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- Optional chaining
const city = user?.address?.city  -- nil if any part is nil

-- Optional method calls
const result = obj?:method()  -- Only calls if obj is not nil
</code></pre>
<h2 id="replacing-metatables-with-classes"><a class="header" href="#replacing-metatables-with-classes">Replacing Metatables with Classes</a></h2>
<h3 id="lua-metatable-pattern"><a class="header" href="#lua-metatable-pattern">Lua Metatable Pattern</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">local Vector = {}
Vector.__index = Vector

function Vector.new(x, y)
    local self = setmetatable({}, Vector)
    self.x = x
    self.y = y
    return self
end

function Vector:add(other)
    return Vector.new(self.x + other.x, self.y + other.y)
end

function Vector:magnitude()
    return math.sqrt(self.x * self.x + self.y * self.y)
end

local v1 = Vector.new(1, 2)
local v2 = Vector.new(3, 4)
local v3 = v1:add(v2)
</code></pre>
<p><strong>LuaNext (with OOP enabled):</strong></p>
<pre><code class="language-lua">-- Class syntax replaces metatable boilerplate
class Vector(public x: number, public y: number)
    function add(other: Vector): Vector
        return Vector.new(self.x + other.x, self.y + other.y)
    end

    function magnitude(): number
        return math.sqrt(self.x * self.x + self.y * self.y)
    end
end

const v1 = Vector.new(1, 2)
const v2 = Vector.new(3, 4)
const v3 = v1:add(v2)
</code></pre>
<p><strong>Migration tip:</strong> Classes compile to metatables, so the generated code is similar to hand-written Lua. Class features are available by default.</p>
<h3 id="operator-overloading-2"><a class="header" href="#operator-overloading-2">Operator Overloading</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">function Vector:__add(other)
    return Vector.new(self.x + other.x, self.y + other.y)
end

Vector.__mul = function(self, scalar)
    return Vector.new(self.x * scalar, self.y * scalar)
end
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">class Vector(public x: number, public y: number)
    operator +(other: Vector): Vector
        return Vector.new(self.x + other.x, self.y + other.y)
    end

    operator *(scalar: number): Vector
        return Vector.new(self.x * scalar, self.y * scalar)
    end
end

const v1 = Vector.new(1, 2)
const v2 = Vector.new(3, 4)
const v3 = v1 + v2       -- Uses operator +
const v4 = v1 * 2        -- Uses operator *
</code></pre>
<h2 id="string-operations"><a class="header" href="#string-operations">String Operations</a></h2>
<h3 id="string-concatenation-1"><a class="header" href="#string-concatenation-1">String Concatenation</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">local message = "Hello, " .. name .. "! You are " .. age .. " years old."
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- Template strings (more readable)
const message = `Hello, ${name}! You are ${age} years old.`

-- Compiles to concatenation, same as Lua
-- local message = "Hello, " .. tostring(name) .. "! You are " .. tostring(age) .. " years old."
</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<h3 id="pcallxpcall-pattern"><a class="header" href="#pcallxpcall-pattern">pcall/xpcall Pattern</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">local success, result = pcall(function()
    return riskyOperation()
end)

if not success then
    print("Error: " .. result)
else
    print("Result: " .. result)
end
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- Try/catch syntax (compiles to pcall)
try
    const result = riskyOperation()
    print("Result: " .. result)
catch error
    print("Error: " .. error)
end

-- Try expression for simple fallbacks
const result = try riskyOperation() catch _ =&gt; defaultValue

-- Error chain operator (shorthand)
const result = riskyOperation() !! defaultValue
</code></pre>
<h2 id="module-system"><a class="header" href="#module-system">Module System</a></h2>
<h3 id="lua-modules"><a class="header" href="#lua-modules">Lua Modules</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">-- math-utils.lua
local M = {}

function M.add(a, b)
    return a + b
end

function M.multiply(a, b)
    return a * b
end

return M

-- main.lua
local utils = require("math-utils")
print(utils.add(5, 3))
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- math-utils.luax
export function add(a: number, b: number): number
    return a + b
end

export function multiply(a: number, b: number): number
    return a * b
end

-- main.luax
import {add, multiply} from "./math-utils"
print(add(5, 3))

-- Or import everything
import * as utils from "./math-utils"
print(utils.add(5, 3))
</code></pre>
<p><strong>Migration tip:</strong> The ES6-style module system compiles to Lua’s <code>require</code> and module pattern. It provides better tooling support (autocomplete, refactoring).</p>
<h2 id="control-flow-enhancements"><a class="header" href="#control-flow-enhancements">Control Flow Enhancements</a></h2>
<h3 id="pattern-matching-2"><a class="header" href="#pattern-matching-2">Pattern Matching</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">function getStatusMessage(code)
    if code == 200 then
        return "OK"
    elseif code == 404 then
        return "Not Found"
    elseif code == 500 then
        return "Internal Server Error"
    else
        return "Unknown Status"
    end
end
</code></pre>
<p><strong>LuaNext (with FP enabled):</strong></p>
<pre><code class="language-lua">function getStatusMessage(code: number): string
    return match code
        | 200 -&gt; "OK"
        | 404 -&gt; "Not Found"
        | 500 -&gt; "Internal Server Error"
        | _ -&gt; "Unknown Status"
    end
end
</code></pre>
<p><strong>Migration tip:</strong> Pattern matching and functional features are available by default. Pattern matching compiles to if-else chains, no runtime overhead.</p>
<h2 id="type-annotations-for-existing-apis"><a class="header" href="#type-annotations-for-existing-apis">Type Annotations for Existing APIs</a></h2>
<h3 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">local result = table.concat(items, ", ")
local index = string.find(text, "pattern")
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- LuaNext provides types for standard library
const result: string = table.concat(items, ", ")
const index: number | nil = string.find(text, "pattern")

-- Type checker knows standard library signatures
table.insert(numbers, "wrong")  -- ❌ Type error
</code></pre>
<h3 id="external-libraries"><a class="header" href="#external-libraries">External Libraries</a></h3>
<p>For libraries without types:</p>
<pre><code class="language-lua">-- Declare types for external library
declare module "external-lib"
    export function process(data: string): number
    export interface Config
        timeout: number
        retries: number
    end
end

import {process, type Config} from "external-lib"

const result: number = process("data")
const config: Config = {timeout = 1000, retries = 3}
</code></pre>
<h2 id="configuration-for-migration"><a class="header" href="#configuration-for-migration">Configuration for Migration</a></h2>
<h3 id="gradual-adoption-config"><a class="header" href="#gradual-adoption-config">Gradual Adoption Config</a></h3>
<p>Start with minimal type checking:</p>
<pre><code class="language-yaml"># luanext.config.yaml
compilerOptions:
  target: "5.1"              # Match your Lua version
  strictNullChecks: false    # Allow nil anywhere (Lua default)
  enableDecorators: false    # Keep it simple
  outDir: "dist"
</code></pre>
<h3 id="progressive-strictness"><a class="header" href="#progressive-strictness">Progressive Strictness</a></h3>
<p>As you add types, increase strictness:</p>
<pre><code class="language-yaml">compilerOptions:
  target: "5.4"
  strictNullChecks: true     # Enable once nil handling is typed
  enableDecorators: true     # Enable for metadata features
  outDir: "dist"
</code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="iterators"><a class="header" href="#iterators">Iterators</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">for i, value in ipairs(array) do
    print(i, value)
end

for key, value in pairs(table) do
    print(key, value)
end
</code></pre>
<p><strong>LuaNext (same syntax, with types):</strong></p>
<pre><code class="language-lua">const array: number[] = {1, 2, 3, 4, 5}

for i, value in ipairs(array) do
    -- i is number, value is number
    print(i, value)
end

interface Data
    [key: string]: any
end

const data: Data = {x = 1, y = 2}

for key, value in pairs(data) do
    -- key is string, value is any
    print(key, value)
end
</code></pre>
<h3 id="varargs"><a class="header" href="#varargs">Varargs</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">function sum(...)
    local total = 0
    for _, n in ipairs({...}) do
        total = total + n
    end
    return total
end
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">function sum(...numbers: number[]): number
    local total = 0
    for _, n in ipairs(numbers) do
        total = total + n
    end
    return total
end

print(sum(1, 2, 3, 4, 5))  -- 15
</code></pre>
<h3 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h3>
<p><strong>Lua:</strong></p>
<pre><code class="language-lua">function processItems(items, callback)
    for _, item in ipairs(items) do
        callback(item)
    end
end

processItems(numbers, function(n)
    print(n * 2)
end)
</code></pre>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">function processItems(items: number[], callback: (n: number) =&gt; void): void
    for _, item in ipairs(items) do
        callback(item)
    end
end

processItems(numbers, (n) =&gt; {
    print(n * 2)
})

-- Or with traditional syntax
processItems(numbers, function(n: number): void
    print(n * 2)
end)
</code></pre>
<h2 id="compatibility-considerations"><a class="header" href="#compatibility-considerations">Compatibility Considerations</a></h2>
<h3 id="lua-version-targeting"><a class="header" href="#lua-version-targeting">Lua Version Targeting</a></h3>
<p>LuaNext compiles to different Lua versions:</p>
<pre><code class="language-yaml">compilerOptions:
  target: "5.1"  # Uses compatibility patterns
  # OR
  target: "5.3"  # Uses integer type, bitwise operators
  # OR
  target: "5.4"  # Uses latest features
</code></pre>
<p><strong>5.1 → 5.4 differences:</strong></p>
<ul>
<li><strong>Integers</strong> — <code>integer</code> type is type-checked in 5.1/5.2, native in 5.3+</li>
<li><strong>Bitwise operators</strong> — Compile to bit library calls in 5.1/5.2, native in 5.3+</li>
<li><strong><code>goto</code></strong> — Available in 5.2+</li>
<li><strong>Integer division (<code>//</code>)</strong> — Emulated in 5.1/5.2, native in 5.3+</li>
</ul>
<h3 id="c-api-and-ffi"><a class="header" href="#c-api-and-ffi">C API and FFI</a></h3>
<p>LuaNext is <strong>source compatible</strong> only. For C extensions:</p>
<pre><code class="language-lua">-- Declare C module types
declare module "cjson"
    export function encode(data: any): string
    export function decode(json: string): any
end

import * as cjson from "cjson"

const json: string = cjson.encode({x = 1, y = 2})
</code></pre>
<h3 id="metatables-still-work"><a class="header" href="#metatables-still-work">Metatables Still Work</a></h3>
<p>LuaNext classes compile to metatables, so existing metatable code is compatible:</p>
<pre><code class="language-lua">class MyClass
    -- LuaNext class
end

-- Still accessible as metatable in generated Lua
local mt = getmetatable(MyClass.new())
print(mt.__index)  -- Works as expected
</code></pre>
<h2 id="migration-checklist"><a class="header" href="#migration-checklist">Migration Checklist</a></h2>
<h3 id="phase-1-setup"><a class="header" href="#phase-1-setup">Phase 1: Setup</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Install LuaNext compiler</li>
<li><input disabled="" type="checkbox"> Rename <code>.lua</code> files to <code>.luax</code></li>
<li><input disabled="" type="checkbox"> Create <code>luanext.config.yaml</code> with minimal settings</li>
<li><input disabled="" type="checkbox"> Verify project compiles without errors</li>
</ul>
<h3 id="phase-2-add-types"><a class="header" href="#phase-2-add-types">Phase 2: Add Types</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Add types to public API functions</li>
<li><input disabled="" type="checkbox"> Add types to complex data structures (interfaces)</li>
<li><input disabled="" type="checkbox"> Add types to frequently-used utility functions</li>
<li><input disabled="" type="checkbox"> Enable <code>strictNullChecks</code> when ready</li>
</ul>
<h3 id="phase-3-modern-features"><a class="header" href="#phase-3-modern-features">Phase 3: Modern Features</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Convert metatables to classes</li>
<li><input disabled="" type="checkbox"> Add pattern matching for complex conditionals</li>
<li><input disabled="" type="checkbox"> Use decorators for metadata (enable with <code>enableDecorators: true</code>)</li>
</ul>
<h3 id="phase-4-refinement"><a class="header" href="#phase-4-refinement">Phase 4: Refinement</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Add types to remaining untyped code</li>
<li><input disabled="" type="checkbox"> Enable all strict checks</li>
<li><input disabled="" type="checkbox"> Review and fix type errors</li>
<li><input disabled="" type="checkbox"> Document types for external consumers</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="type-mismatch-errors"><a class="header" href="#type-mismatch-errors">“Type mismatch” errors</a></h3>
<p><strong>Problem:</strong> Lua allows mixing types, but LuaNext doesn’t.</p>
<p><strong>Solution:</strong> Use union types or type assertions:</p>
<pre><code class="language-lua">-- Union type
local value: string | number = getValue()

-- Type assertion (use sparingly)
const data = externalCall() as MyType
</code></pre>
<h3 id="cannot-assign-to-const"><a class="header" href="#cannot-assign-to-const">“Cannot assign to const”</a></h3>
<p><strong>Problem:</strong> Variable declared with <code>const</code> cannot be reassigned.</p>
<p><strong>Solution:</strong> Use <code>local</code> for mutable variables:</p>
<pre><code class="language-lua">local count = 0
count = count + 1  -- OK
</code></pre>
<h3 id="missing-nil-check"><a class="header" href="#missing-nil-check">“Missing nil check”</a></h3>
<p><strong>Problem:</strong> <code>strictNullChecks</code> requires explicit nil handling.</p>
<p><strong>Solution:</strong> Check for nil or use optional chaining:</p>
<pre><code class="language-lua">-- Explicit nil check
if value ~= nil then
    print(value.property)
end

-- Optional chaining
print(value?.property)
</code></pre>
<h3 id="module-not-found"><a class="header" href="#module-not-found">“Module not found”</a></h3>
<p><strong>Problem:</strong> Import path doesn’t match file structure.</p>
<p><strong>Solution:</strong> Use relative paths:</p>
<pre><code class="language-lua">-- From src/main.luax importing src/utils.luax
import {helper} from "./utils"

-- From src/main.luax importing src/lib/utils.luax
import {helper} from "./lib/utils"
</code></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="zero-runtime-cost"><a class="header" href="#zero-runtime-cost">Zero Runtime Cost</a></h3>
<p>All LuaNext features compile to plain Lua with <strong>no runtime overhead</strong>:</p>
<ul>
<li><strong>Types</strong> — Erased at compile time</li>
<li><strong>Interfaces</strong> — Type-checking only, no runtime representation</li>
<li><strong>Classes</strong> — Compile to metatables (same as hand-written Lua)</li>
<li><strong>Pattern matching</strong> — Compiles to if-else chains</li>
<li><strong>Template strings</strong> — Compile to concatenation</li>
</ul>
<h3 id="same-performance-as-lua"><a class="header" href="#same-performance-as-lua">Same Performance as Lua</a></h3>
<pre><code class="language-lua">-- LuaNext
const result: number = add(5, 3)

-- Compiles to (same as hand-written Lua)
local result = add(5, 3)
</code></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="#basics">Language Basics</a> — Core syntax and types</li>
<li><a href="#type-system">Type System</a> — Advanced type features</li>
<li><a href="#classes">Classes</a> — OOP with classes</li>
<li><a href="#pattern-matching-1">Pattern Matching</a> — Functional patterns</li>
<li><a href="#configuration-reference">Configuration</a> — Compiler options</li>
</ul>
<h2 id="see-also-13"><a class="header" href="#see-also-13">See Also</a></h2>
<ul>
<li><a href="#targeting-different-lua-versions">Lua Targets</a> — Targeting different Lua versions</li>
<li><a href="#standard-library-reference">Standard Library</a> — Typed Lua standard library</li>
<li><a href="#cli-reference">CLI Reference</a> — Command-line options</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="targeting-different-lua-versions"><a class="header" href="#targeting-different-lua-versions">Targeting Different Lua Versions</a></h1>
<p>LuaNext can target Lua versions 5.1, 5.2, 5.3, and 5.4. This guide explains the differences, compatibility patterns, and how to choose the right target for your project.</p>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Version</th><th>Released</th><th>Key Features</th><th>Compatibility</th></tr>
</thead>
<tbody>
<tr><td><strong>Lua 5.1</strong></td><td>2006</td><td>Module system, <code>setfenv</code>/<code>getfenv</code></td><td>Widest compatibility</td></tr>
<tr><td><strong>Lua 5.2</strong></td><td>2011</td><td><code>goto</code>, <code>_ENV</code>, bit32 library</td><td>Breaking changes from 5.1</td></tr>
<tr><td><strong>Lua 5.3</strong></td><td>2015</td><td>Native integers, bitwise operators</td><td>Mostly compatible with 5.2</td></tr>
<tr><td><strong>Lua 5.4</strong></td><td>2020</td><td><code>&lt;const&gt;</code>, <code>&lt;close&gt;</code>, new metamethods</td><td>Latest features</td></tr>
</tbody>
</table>
</div>
<h2 id="setting-the-target"><a class="header" href="#setting-the-target">Setting the Target</a></h2>
<h3 id="in-configuration-file"><a class="header" href="#in-configuration-file">In Configuration File</a></h3>
<pre><code class="language-yaml"># luanext.config.yaml
compilerOptions:
  target: "5.4"  # Options: "5.1", "5.2", "5.3", "5.4"
</code></pre>
<h3 id="command-line"><a class="header" href="#command-line">Command Line</a></h3>
<pre><code class="language-bash"># Target Lua 5.1
luanext --target 5.1 main.luax

# Target Lua 5.4
luanext --target 5.4 main.luax
</code></pre>
<h3 id="default-target"><a class="header" href="#default-target">Default Target</a></h3>
<p>If not specified, LuaNext targets <strong>Lua 5.4</strong> (latest features).</p>
<h2 id="choosing-a-target"><a class="header" href="#choosing-a-target">Choosing a Target</a></h2>
<h3 id="use-lua-51-when"><a class="header" href="#use-lua-51-when">Use Lua 5.1 When</a></h3>
<ul>
<li><strong>Maximum compatibility needed</strong> — Most embedded Lua uses 5.1</li>
<li><strong>Legacy systems</strong> — Older games, applications using Lua 5.1</li>
<li><strong>Widest deployment</strong> — 5.1 code runs everywhere</li>
<li><strong>Embedded environments</strong> — Many game engines and applications use 5.1</li>
</ul>
<h3 id="use-lua-52-when"><a class="header" href="#use-lua-52-when">Use Lua 5.2 When</a></h3>
<ul>
<li><strong>You need <code>goto</code></strong> — For complex control flow (state machines, etc.)</li>
<li><strong><code>_ENV</code> manipulation needed</strong> — For sandboxing or environment control</li>
<li><strong>5.1 is too old</strong> — But 5.3+ features aren’t critical</li>
</ul>
<h3 id="use-lua-53-when"><a class="header" href="#use-lua-53-when">Use Lua 5.3 When</a></h3>
<ul>
<li><strong>Native integers needed</strong> — For performance with whole numbers</li>
<li><strong>Bitwise operators</strong> — For bit manipulation (games, protocols)</li>
<li><strong>UTF-8 library</strong> — For Unicode string handling</li>
<li><strong>Better performance</strong> — Integer optimizations help</li>
</ul>
<h3 id="use-lua-54-when"><a class="header" href="#use-lua-54-when">Use Lua 5.4 When</a></h3>
<ul>
<li><strong>Latest features</strong> — <code>&lt;const&gt;</code>, <code>&lt;close&gt;</code>, generational GC</li>
<li><strong>New metamethods</strong> — <code>__close</code> for resource management</li>
<li><strong>Best performance</strong> — Latest optimizations</li>
<li><strong>No legacy constraints</strong> — New projects with modern Lua</li>
</ul>
<h2 id="feature-compatibility-matrix"><a class="header" href="#feature-compatibility-matrix">Feature Compatibility Matrix</a></h2>
<h3 id="language-features"><a class="header" href="#language-features">Language Features</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>5.1</th><th>5.2</th><th>5.3</th><th>5.4</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Basic syntax</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>—</td></tr>
<tr><td>Metatables</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>—</td></tr>
<tr><td>Coroutines</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>—</td></tr>
<tr><td><code>goto</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Emulated in 5.1</td></tr>
<tr><td><code>_ENV</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Uses <code>setfenv</code> in 5.1</td></tr>
<tr><td>Native integers</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td><td>Type-checked only in 5.1/5.2</td></tr>
<tr><td>Bitwise ops</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td><td>Uses bit32/bit library in 5.1/5.2</td></tr>
<tr><td>Integer division (<code>//</code>)</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td><td>Emulated with <code>math.floor(a/b)</code></td></tr>
<tr><td><code>&lt;const&gt;</code> variables</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>Type-checked only in 5.1-5.3</td></tr>
<tr><td><code>&lt;close&gt;</code> variables</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>Not available in older versions</td></tr>
</tbody>
</table>
</div>
<h3 id="standard-library-1"><a class="header" href="#standard-library-1">Standard Library</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Library</th><th>5.1</th><th>5.2</th><th>5.3</th><th>5.4</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>table.*</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>Some functions moved in 5.2+</td></tr>
<tr><td><code>string.*</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>—</td></tr>
<tr><td><code>math.*</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>—</td></tr>
<tr><td><code>io.*</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>—</td></tr>
<tr><td><code>os.*</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>—</td></tr>
<tr><td><code>module()</code></td><td>✅</td><td>⚠️</td><td>❌</td><td>❌</td><td>Deprecated in 5.2, removed in 5.3</td></tr>
<tr><td><code>setfenv/getfenv</code></td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>Replaced by <code>_ENV</code></td></tr>
<tr><td><code>bit32.*</code></td><td>❌</td><td>✅</td><td>✅</td><td>⚠️</td><td>Deprecated in 5.3 (use bitwise ops)</td></tr>
<tr><td><code>utf8.*</code></td><td>❌</td><td>❌</td><td>✅</td><td>✅</td><td>—</td></tr>
<tr><td><code>table.pack/unpack</code></td><td>⚠️</td><td>✅</td><td>✅</td><td>✅</td><td>Use <code>unpack</code> in 5.1</td></tr>
<tr><td><code>table.move</code></td><td>❌</td><td>❌</td><td>✅</td><td>✅</td><td>—</td></tr>
</tbody>
</table>
</div>
<p>Legend: ✅ Available | ❌ Not available | ⚠️ Deprecated/Changed</p>
<h2 id="code-generation-differences"><a class="header" href="#code-generation-differences">Code Generation Differences</a></h2>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">const count: integer = 42
const index: integer = #array
</code></pre>
<p><strong>Compiles to (5.3+):</strong></p>
<pre><code class="language-lua">local count = 42
local index = #array
</code></pre>
<p><strong>Compiles to (5.1/5.2):</strong></p>
<pre><code class="language-lua">-- Same output, but type is checked at compile time only
local count = 42
local index = #array
</code></pre>
<p><strong>Note:</strong> In 5.1/5.2, <code>integer</code> is a type annotation only. In 5.3+, Lua uses actual integer type internally for performance.</p>
<h3 id="bitwise-operators-1"><a class="header" href="#bitwise-operators-1">Bitwise Operators</a></h3>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">const a: integer = 12 &amp; 10   -- AND
const b: integer = 12 | 10   -- OR
const c: integer = 12 ~ 10   -- XOR
const d: integer = ~5        -- NOT
const e: integer = 1 &lt;&lt; 3    -- Left shift
const f: integer = 8 &gt;&gt; 2    -- Right shift
</code></pre>
<p><strong>Compiles to (5.3+):</strong></p>
<pre><code class="language-lua">local a = 12 &amp; 10
local b = 12 | 10
local c = 12 ~ 10
local d = ~5
local e = 1 &lt;&lt; 3
local f = 8 &gt;&gt; 2
</code></pre>
<p><strong>Compiles to (5.2):</strong></p>
<pre><code class="language-lua">-- Uses bit32 library
local a = bit32.band(12, 10)
local b = bit32.bor(12, 10)
local c = bit32.bxor(12, 10)
local d = bit32.bnot(5)
local e = bit32.lshift(1, 3)
local f = bit32.rshift(8, 2)
</code></pre>
<p><strong>Compiles to (5.1):</strong></p>
<pre><code class="language-lua">-- Uses polyfill or external bit library
local a = bit.band(12, 10)
local b = bit.bor(12, 10)
local c = bit.bxor(12, 10)
local d = bit.bnot(5)
local e = bit.lshift(1, 3)
local f = bit.rshift(8, 2)
</code></pre>
<h3 id="integer-division"><a class="header" href="#integer-division">Integer Division</a></h3>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">const result: number = 17 // 5  -- Floor division
</code></pre>
<p><strong>Compiles to (5.3+):</strong></p>
<pre><code class="language-lua">local result = 17 // 5
</code></pre>
<p><strong>Compiles to (5.1/5.2):</strong></p>
<pre><code class="language-lua">local result = math.floor(17 / 5)
</code></pre>
<h3 id="table-operations"><a class="header" href="#table-operations">Table Operations</a></h3>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">const packed = table.pack(1, 2, 3, 4, 5)
const moved = table.move(source, 1, 5, 1, dest)
</code></pre>
<p><strong>Compiles to (5.2+):</strong></p>
<pre><code class="language-lua">local packed = table.pack(1, 2, 3, 4, 5)
local moved = table.move(source, 1, 5, 1, dest)
</code></pre>
<p><strong>Compiles to (5.1):</strong></p>
<pre><code class="language-lua">-- Polyfill for table.pack
local function pack(...)
    return {n = select("#", ...), ...}
end
local packed = pack(1, 2, 3, 4, 5)

-- Polyfill for table.move
local function move(a1, f, e, t, a2)
    a2 = a2 or a1
    for i = 0, e - f do
        a2[t + i] = a1[f + i]
    end
    return a2
end
local moved = move(source, 1, 5, 1, dest)
</code></pre>
<h3 id="module-system-1"><a class="header" href="#module-system-1">Module System</a></h3>
<p><strong>LuaNext:</strong></p>
<pre><code class="language-lua">-- ES6-style imports/exports
import {add, multiply} from "./math-utils"
export function divide(a: number, b: number): number
    return a / b
end
</code></pre>
<p><strong>Compiles to (All versions):</strong></p>
<pre><code class="language-lua">-- Uses require and module pattern
local math_utils = require("math-utils")
local add = math_utils.add
local multiply = math_utils.multiply

local M = {}

function M.divide(a, b)
    return a / b
end

return M
</code></pre>
<p><strong>Note:</strong> Module compilation is the same across all Lua versions. LuaNext uses the return-table pattern, not <code>module()</code>.</p>
<h2 id="cross-version-compatibility-patterns"><a class="header" href="#cross-version-compatibility-patterns">Cross-Version Compatibility Patterns</a></h2>
<h3 id="writing-portable-code"><a class="header" href="#writing-portable-code">Writing Portable Code</a></h3>
<p>Use LuaNext features that work across all versions:</p>
<pre><code class="language-lua">-- ✅ Portable: Basic types
const name: string = "Alice"
const count: number = 42

-- ✅ Portable: Functions
function add(a: number, b: number): number
    return a + b
end

-- ✅ Portable: Interfaces
interface Point
    x: number
    y: number
end

-- ✅ Portable: Arrays and tables
const numbers: number[] = {1, 2, 3}
const point: Point = {x = 1, y = 2}
</code></pre>
<h3 id="avoid-version-specific-features"><a class="header" href="#avoid-version-specific-features">Avoid Version-Specific Features</a></h3>
<p>If targeting multiple versions:</p>
<pre><code class="language-lua">-- ❌ Avoid in portable code (5.3+ only)
const flags: integer = 0b1100
const result: integer = flags &amp; 0b1010

-- ✅ Use instead (all versions)
const flags: number = 12
const result: number = bitwiseAnd(flags, 10)  -- Custom function
</code></pre>
<h3 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional Compilation</a></h3>
<p>LuaNext doesn’t support <code>#ifdef</code> style conditionals. Instead:</p>
<p><strong>Option 1: Configuration-based</strong></p>
<pre><code class="language-yaml"># luanext-5.1.config.yaml
compilerOptions:
  target: "5.1"
  defines:
    USE_BIT_LIBRARY: true

# luanext-5.3.config.yaml
compilerOptions:
  target: "5.3"
  defines:
    USE_BIT_LIBRARY: false
</code></pre>
<p><strong>Option 2: Runtime detection</strong></p>
<pre><code class="language-lua">-- Detect Lua version at runtime
const luaVersion = tonumber(_VERSION:match("%d+%.%d+"))

function bitwiseAnd(a: number, b: number): number
    if luaVersion &gt;= 5.3 then
        return a &amp; b
    else
        return bit32.band(a, b)
    end
end
</code></pre>
<h2 id="testing-across-versions"><a class="header" href="#testing-across-versions">Testing Across Versions</a></h2>
<h3 id="using-multiple-lua-installations"><a class="header" href="#using-multiple-lua-installations">Using Multiple Lua Installations</a></h3>
<pre><code class="language-bash"># Test with Lua 5.1
lua5.1 output.lua

# Test with Lua 5.3
lua5.3 output.lua

# Test with Lua 5.4
lua5.4 output.lua
</code></pre>
<h3 id="docker-testing"><a class="header" href="#docker-testing">Docker Testing</a></h3>
<pre><code class="language-dockerfile"># Dockerfile
FROM alpine:latest

RUN apk add --no-cache lua5.1 lua5.3 lua5.4

COPY dist/ /app/
WORKDIR /app

CMD ["lua5.4", "main.lua"]
</code></pre>
<h3 id="cicd-matrix-testing"><a class="header" href="#cicd-matrix-testing">CI/CD Matrix Testing</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml
strategy:
  matrix:
    lua-version: ['5.1', '5.2', '5.3', '5.4']
steps:
  - name: Setup Lua
    uses: leafo/gh-actions-lua@v9
    with:
      luaVersion: ${{ matrix.lua-version }}
  - name: Run tests
    run: lua test/all_tests.lua
</code></pre>
<h2 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h2>
<h3 id="version-performance-characteristics"><a class="header" href="#version-performance-characteristics">Version Performance Characteristics</a></h3>
<p><strong>Lua 5.1:</strong></p>
<ul>
<li><strong>Wide compatibility</strong> — Runs on most platforms and embedded systems</li>
<li><strong>Best for</strong> — Legacy applications, maximum compatibility</li>
<li><strong>Limitations</strong> — No native integers, older standard library, no bitwise operators</li>
</ul>
<p><strong>Lua 5.3:</strong></p>
<ul>
<li><strong>Good integer performance</strong> — Native 64-bit integers</li>
<li><strong>Bitwise operators</strong> — Faster than library calls</li>
<li><strong>Best for</strong> — Numerical applications, bit manipulation</li>
</ul>
<p><strong>Lua 5.4:</strong></p>
<ul>
<li><strong>Generational GC</strong> — Better for applications with many short-lived objects</li>
<li><strong>Best for</strong> — Modern applications, long-running servers</li>
<li><strong>Latest optimizations</strong> — Most recent performance improvements</li>
</ul>
<h3 id="optimization-by-target"><a class="header" href="#optimization-by-target">Optimization by Target</a></h3>
<p><strong>For Lua 5.1:</strong></p>
<pre><code class="language-lua">-- Use number everywhere (no integer optimization)
function sum(arr: number[]): number
    local total: number = 0
    for i = 1, #arr do
        total = total + arr[i]
    end
    return total
end
</code></pre>
<p><strong>For Lua 5.3+:</strong></p>
<pre><code class="language-lua">-- Use integer for loops and counters
function sum(arr: number[]): number
    local total: number = 0
    for i: integer = 1, #arr do
        total = total + arr[i]
    end
    return total
end
</code></pre>
<h2 id="migration-between-versions"><a class="header" href="#migration-between-versions">Migration Between Versions</a></h2>
<h3 id="upgrading-from-51-to-53"><a class="header" href="#upgrading-from-51-to-53">Upgrading from 5.1 to 5.3+</a></h3>
<p><strong>Changes needed:</strong></p>
<ol>
<li><strong>Replace <code>bit</code> library with operators:</strong></li>
</ol>
<pre><code class="language-lua">-- Before (5.1)
const result = bit.band(a, b)

-- After (5.3+)
const result = a &amp; b
</code></pre>
<ol>
<li><strong>Replace <code>module()</code> with return pattern:</strong></li>
</ol>
<pre><code class="language-lua">-- Before (5.1)
module("mymodule")
function foo() end

-- After (all versions via LuaNext)
export function foo(): void end
</code></pre>
<ol>
<li><strong>Use <code>table.pack</code> instead of <code>arg</code> table:</strong></li>
</ol>
<pre><code class="language-lua">-- Before (5.1)
function varargs(...)
    const args = arg
end

-- After (5.2+)
function varargs(...: any[])
    const args = table.pack(...)
end
</code></pre>
<h3 id="downgrading-from-54-to-51"><a class="header" href="#downgrading-from-54-to-51">Downgrading from 5.4 to 5.1</a></h3>
<p><strong>Changes needed:</strong></p>
<ol>
<li><strong>Remove <code>&lt;const&gt;</code> and <code>&lt;close&gt;</code></strong> — LuaNext handles this automatically</li>
<li><strong>Avoid bitwise operators</strong> — Use functions instead</li>
<li><strong>Test with polyfills</strong> — Ensure compatibility functions work</li>
</ol>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<h3 id="quick-decision-guide"><a class="header" href="#quick-decision-guide">Quick Decision Guide</a></h3>
<pre><code class="language-text">Need wide compatibility?  → Target 5.1
Need bitwise operators?   → Target 5.3+
Need latest features?     → Target 5.4
Building new project?     → Target 5.4
Legacy system support?    → Target 5.1
</code></pre>
<h3 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h3>
<ol>
<li><strong>Choose target based on deployment environment</strong></li>
<li><strong>Test on actual target Lua version</strong></li>
<li><strong>Use portable LuaNext features when possible</strong></li>
<li><strong>Avoid version-specific Lua features</strong></li>
<li><strong>Document target version requirements</strong></li>
</ol>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="#migrating-from-lua">Migrating from Lua</a> — Porting Lua code to LuaNext</li>
<li><a href="#configuration-reference">Configuration</a> — All compiler options</li>
<li><a href="#cli-reference">CLI Reference</a> — Command-line usage</li>
</ul>
<h2 id="see-also-14"><a class="header" href="#see-also-14">See Also</a></h2>
<ul>
<li><a href="#migrating-from-lua">Migrating from Lua</a> — Porting Lua code to LuaNext</li>
<li><a href="#configuration-reference">Configuration</a> — All compiler options</li>
<li><a href="#cli-reference">CLI Reference</a> — Command-line usage</li>
<li><a href="#standard-library-reference">Standard Library</a> — Typed standard library</li>
<li><a href="https://www.lua.org/manual/">Lua Manual</a> — Official Lua documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-reference"><a class="header" href="#cli-reference">CLI Reference</a></h1>
<p>Complete command-line interface reference for the LuaNext compiler.</p>
<h2 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h2>
<pre><code class="language-bash">luanext [OPTIONS] &lt;FILES&gt;...
luanext --init
luanext --help
luanext --version
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<h3 id="compile-single-file"><a class="header" href="#compile-single-file">Compile Single File</a></h3>
<pre><code class="language-bash">luanext main.luax
</code></pre>
<p>Compiles <code>main.luax</code> to <code>main.lua</code> in the same directory.</p>
<h3 id="compile-multiple-files"><a class="header" href="#compile-multiple-files">Compile Multiple Files</a></h3>
<pre><code class="language-bash">luanext file1.luax file2.luax file3.luax
</code></pre>
<p>Compiles each file to corresponding <code>.lua</code> output.</p>
<h3 id="compile-with-glob-patterns"><a class="header" href="#compile-with-glob-patterns">Compile with Glob Patterns</a></h3>
<pre><code class="language-bash"># Compile all .luax files in src/
luanext "src/**/*.luax"

# Compile multiple patterns
luanext "src/**/*.luax" "tests/**/*.luax"
</code></pre>
<p><strong>Note:</strong> Use quotes around glob patterns to prevent shell expansion.</p>
<h3 id="specify-output-directory"><a class="header" href="#specify-output-directory">Specify Output Directory</a></h3>
<pre><code class="language-bash">luanext main.luax --out-dir dist/
</code></pre>
<p>Compiles <code>main.luax</code> to <code>dist/main.lua</code>.</p>
<h3 id="bundle-to-single-file"><a class="header" href="#bundle-to-single-file">Bundle to Single File</a></h3>
<pre><code class="language-bash">luanext "src/**/*.luax" --out-file bundle.lua
</code></pre>
<p>Compiles all files and concatenates them into <code>bundle.lua</code>.</p>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<h3 id="inputoutput"><a class="header" href="#inputoutput">Input/Output</a></h3>
<h4 id="files"><a class="header" href="#files"><code>&lt;FILES&gt;...</code></a></h4>
<p>Input files to compile. Supports glob patterns.</p>
<pre><code class="language-bash">luanext main.luax utils.luax
luanext "src/**/*.luax"
</code></pre>
<h4 id="-p---project-file"><a class="header" href="#-p---project-file"><code>-p, --project &lt;FILE&gt;</code></a></h4>
<p>Path to <code>luanext.config.yaml</code> configuration file.</p>
<pre><code class="language-bash">luanext --project ./config/luanext.config.yaml main.luax
</code></pre>
<p>If not specified, LuaNext looks for <code>luanext.config.yaml</code> in the current directory and parent directories.</p>
<h4 id="--out-dir-dir"><a class="header" href="#--out-dir-dir"><code>--out-dir &lt;DIR&gt;</code></a></h4>
<p>Output directory for compiled Lua files.</p>
<pre><code class="language-bash">luanext main.luax --out-dir dist/
</code></pre>
<p>Creates <code>dist/main.lua</code> preserving directory structure.</p>
<h4 id="--out-file-file"><a class="header" href="#--out-file-file"><code>--out-file &lt;FILE&gt;</code></a></h4>
<p>Output file (concatenates all output into a single file).</p>
<pre><code class="language-bash">luanext "src/**/*.luax" --out-file bundle.lua
</code></pre>
<p>Generates a single bundled file with all modules.</p>
<h4 id="--no-emit"><a class="header" href="#--no-emit"><code>--no-emit</code></a></h4>
<p>Type-check only, do not generate output files.</p>
<pre><code class="language-bash">luanext main.luax --no-emit
</code></pre>
<p>Useful for CI/CD type checking without generating output.</p>
<h3 id="target-and-compatibility"><a class="header" href="#target-and-compatibility">Target and Compatibility</a></h3>
<h4 id="--target-version"><a class="header" href="#--target-version"><code>--target &lt;VERSION&gt;</code></a></h4>
<p>Target Lua version: <code>5.1</code>, <code>5.2</code>, <code>5.3</code>, or <code>5.4</code>.</p>
<pre><code class="language-bash">luanext main.luax --target 5.1
luanext main.luax --target 5.4
</code></pre>
<p><strong>Default:</strong> <code>5.4</code></p>
<p>Affects:</p>
<ul>
<li>Integer handling (native in 5.3+, type-checked only in 5.1/5.2)</li>
<li>Bitwise operators (native in 5.3+, library calls in 5.1/5.2)</li>
<li>Standard library compatibility</li>
</ul>
<p>See <a href="#targeting-different-lua-versions">Lua Targets</a> for details.</p>
<h3 id="source-maps"><a class="header" href="#source-maps">Source Maps</a></h3>
<h4 id="--source-map"><a class="header" href="#--source-map"><code>--source-map</code></a></h4>
<p>Generate source maps (<code>.lua.map</code> files).</p>
<pre><code class="language-bash">luanext main.luax --source-map
</code></pre>
<p>Creates <code>main.lua</code> and <code>main.lua.map</code> for debugging.</p>
<h4 id="--inline-source-map"><a class="header" href="#--inline-source-map"><code>--inline-source-map</code></a></h4>
<p>Inline source map in output file as a comment.</p>
<pre><code class="language-bash">luanext main.luax --inline-source-map
</code></pre>
<p>Embeds source map directly in <code>main.lua</code>:</p>
<pre><code class="language-lua">-- ...generated code...
--# sourceMappingURL=data:application/json;base64,...
</code></pre>
<h3 id="watch-mode"><a class="header" href="#watch-mode">Watch Mode</a></h3>
<h4 id="-w---watch"><a class="header" href="#-w---watch"><code>-w, --watch</code></a></h4>
<p>Watch input files for changes and recompile automatically.</p>
<pre><code class="language-bash">luanext "src/**/*.luax" --watch --out-dir dist/
</code></pre>
<p>Monitors files and recompiles on changes. Press <code>Ctrl+C</code> to exit.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Incremental compilation (only changed files)</li>
<li>Fast rebuild times</li>
<li>Error recovery (continues watching after errors)</li>
</ul>
<h3 id="project-initialization"><a class="header" href="#project-initialization">Project Initialization</a></h3>
<h4 id="--init"><a class="header" href="#--init"><code>--init</code></a></h4>
<p>Initialize a new LuaNext project.</p>
<pre><code class="language-bash">luanext --init
</code></pre>
<p>Creates:</p>
<ul>
<li><code>luanext.config.yaml</code> — Configuration file</li>
<li><code>main.luax</code> — Sample source file</li>
</ul>
<h3 id="type-checking-options"><a class="header" href="#type-checking-options">Type Checking Options</a></h3>
<h4 id="--no-strict-null-checks"><a class="header" href="#--no-strict-null-checks"><code>--no-strict-null-checks</code></a></h4>
<p>Disable strict null checking (allow nil anywhere).</p>
<pre><code class="language-bash">luanext main.luax --no-strict-null-checks
</code></pre>
<p>By default, LuaNext enforces explicit nil handling. This flag disables that.</p>
<h4 id="--no-implicit-unknown"><a class="header" href="#--no-implicit-unknown"><code>--no-implicit-unknown</code></a></h4>
<p>Disallow implicit <code>unknown</code> types (require explicit type annotations).</p>
<pre><code class="language-bash">luanext main.luax --no-implicit-unknown
</code></pre>
<p>Forces all values to have known types or explicit <code>unknown</code> annotation.</p>
<h4 id="--strict-naming-level"><a class="header" href="#--strict-naming-level"><code>--strict-naming &lt;LEVEL&gt;</code></a></h4>
<p>Strict naming convention enforcement: <code>error</code>, <code>warning</code>, or <code>off</code>.</p>
<pre><code class="language-bash">luanext main.luax --strict-naming error
luanext main.luax --strict-naming warning
</code></pre>
<ul>
<li><code>error</code> — Naming violations are compilation errors</li>
<li><code>warning</code> — Naming violations are warnings</li>
<li><code>off</code> — No naming enforcement (default)</li>
</ul>
<p><strong>Conventions checked:</strong></p>
<ul>
<li>Constants: <code>UPPER_SNAKE_CASE</code></li>
<li>Variables: <code>camelCase</code> or <code>snake_case</code></li>
<li>Types/Interfaces: <code>PascalCase</code></li>
<li>Functions: <code>camelCase</code> or <code>snake_case</code></li>
</ul>
<h3 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h3>
<h4 id="--enable-decorators"><a class="header" href="#--enable-decorators"><code>--enable-decorators</code></a></h4>
<p>Enable decorator syntax.</p>
<pre><code class="language-bash">luanext main.luax --enable-decorators
</code></pre>
<p>Allows using <code>@decorator</code> annotations on classes and members.</p>
<p><strong>Default:</strong> Enabled (add <code>--no-enable-decorators</code> to disable)</p>
<h3 id="module-system-2"><a class="header" href="#module-system-2">Module System</a></h3>
<h4 id="--module-mode-mode"><a class="header" href="#--module-mode-mode"><code>--module-mode &lt;MODE&gt;</code></a></h4>
<p>Module code generation mode: <code>require</code> or <code>bundle</code>.</p>
<pre><code class="language-bash">luanext main.luax --module-mode require
luanext main.luax --module-mode bundle
</code></pre>
<ul>
<li><code>require</code> — Generate separate files with <code>require()</code> calls (default)</li>
<li><code>bundle</code> — Inline all modules into output file</li>
</ul>
<h4 id="--module-paths-paths"><a class="header" href="#--module-paths-paths"><code>--module-paths &lt;PATHS&gt;</code></a></h4>
<p>Module search paths (comma-separated).</p>
<pre><code class="language-bash">luanext main.luax --module-paths "lib/,node_modules/"
</code></pre>
<p>Adds additional directories to module resolution paths.</p>
<h4 id="--enforce-namespace-path"><a class="header" href="#--enforce-namespace-path"><code>--enforce-namespace-path</code></a></h4>
<p>Enforce that namespace declarations match file paths.</p>
<pre><code class="language-bash">luanext main.luax --enforce-namespace-path
</code></pre>
<p>Example: <code>namespace MyApp.Utils</code> in <code>src/MyApp/Utils.luax</code> is valid,
but <code>namespace Other.Namespace</code> would be an error.</p>
<h3 id="output-formatting"><a class="header" href="#output-formatting">Output Formatting</a></h3>
<h4 id="--format-format"><a class="header" href="#--format-format"><code>--format &lt;FORMAT&gt;</code></a></h4>
<p>Output format: <code>readable</code>, <code>compact</code>, or <code>minified</code>.</p>
<pre><code class="language-bash">luanext main.luax --format readable   # Default: formatted with indentation
luanext main.luax --format compact    # Minimal whitespace
luanext main.luax --format minified   # Single line, no whitespace
</code></pre>
<p><strong>Readable:</strong></p>
<pre><code class="language-lua">local function add(a, b)
    return a + b
end
</code></pre>
<p><strong>Compact:</strong></p>
<pre><code class="language-lua">local function add(a, b)
  return a + b
end
</code></pre>
<p><strong>Minified:</strong></p>
<pre><code class="language-lua">local function add(a,b)return a+b end
</code></pre>
<h4 id="--copy-lua-to-output"><a class="header" href="#--copy-lua-to-output"><code>--copy-lua-to-output</code></a></h4>
<p>Copy plain <code>.lua</code> files to output directory.</p>
<pre><code class="language-bash">luanext "src/**/*.luax" --copy-lua-to-output --out-dir dist/
</code></pre>
<p>Copies non-LuaNext <code>.lua</code> files from source to output directory.</p>
<h3 id="optimization"><a class="header" href="#optimization">Optimization</a></h3>
<h4 id="--optimize"><a class="header" href="#--optimize"><code>--optimize</code></a></h4>
<p>Enable aggressive optimizations with whole-program analysis.</p>
<pre><code class="language-bash">luanext main.luax --optimize --out-file optimized.lua
</code></pre>
<p><strong>Enabled optimizations:</strong></p>
<ul>
<li>Constant folding and propagation</li>
<li>Dead code elimination</li>
<li>Function inlining</li>
<li>Loop optimizations</li>
<li>Rich enum optimization</li>
<li>Table preallocation</li>
<li>Tail call optimization</li>
</ul>
<p><strong>Note:</strong> Requires <code>--out-file</code> or single file compilation for whole-program analysis.</p>
<h4 id="--no-optimize"><a class="header" href="#--no-optimize"><code>--no-optimize</code></a></h4>
<p>Disable all optimizations (raw transpilation).</p>
<pre><code class="language-bash">luanext main.luax --no-optimize
</code></pre>
<p>Generates Lua code directly from AST without any optimization passes.</p>
<h4 id="--profile-optimizer"><a class="header" href="#--profile-optimizer"><code>--profile-optimizer</code></a></h4>
<p>Enable optimizer profiling (logs pass timings).</p>
<pre><code class="language-bash">luanext main.luax --optimize --profile-optimizer
</code></pre>
<p>Outputs timing information for each optimization pass:</p>
<pre><code>ConstantFoldingPass: 12.3ms
DeadCodeEliminationPass: 8.7ms
InlineExpansionPass: 15.2ms
...
</code></pre>
<h4 id="--no-parallel-optimization"><a class="header" href="#--no-parallel-optimization"><code>--no-parallel-optimization</code></a></h4>
<p>Disable parallel optimization (for benchmarking).</p>
<pre><code class="language-bash">luanext main.luax --optimize --no-parallel-optimization
</code></pre>
<p>Runs optimization passes sequentially instead of in parallel.</p>
<h4 id="--no-tree-shake"><a class="header" href="#--no-tree-shake"><code>--no-tree-shake</code></a></h4>
<p>Disable tree shaking (for debugging).</p>
<pre><code class="language-bash">luanext main.luax --optimize --no-tree-shake
</code></pre>
<p>Keeps all code, even unreachable functions/exports.</p>
<h4 id="--no-scope-hoist"><a class="header" href="#--no-scope-hoist"><code>--no-scope-hoist</code></a></h4>
<p>Disable scope hoisting (for debugging).</p>
<pre><code class="language-bash">luanext main.luax --optimize --no-scope-hoist
</code></pre>
<p>Preserves module boundaries instead of merging scopes.</p>
<h3 id="caching"><a class="header" href="#caching">Caching</a></h3>
<h4 id="--no-cache"><a class="header" href="#--no-cache"><code>--no-cache</code></a></h4>
<p>Disable incremental compilation cache.</p>
<pre><code class="language-bash">luanext main.luax --no-cache
</code></pre>
<p>Forces full recompilation, ignoring <code>.luanext-cache/</code> directory.</p>
<p><strong>Note:</strong> Cache is stored in <code>.luanext-cache/</code> in the project root.</p>
<h4 id="--force-full-check"><a class="header" href="#--force-full-check"><code>--force-full-check</code></a></h4>
<p>Force full type check (disable incremental type checking).</p>
<pre><code class="language-bash">luanext main.luax --force-full-check
</code></pre>
<p>Re-type-checks all files even if unchanged.</p>
<h3 id="reflection"><a class="header" href="#reflection">Reflection</a></h3>
<h4 id="--reflection-mode"><a class="header" href="#--reflection-mode"><code>--reflection &lt;MODE&gt;</code></a></h4>
<p>Reflection metadata mode: <code>selective</code>, <code>full</code>, or <code>none</code>.</p>
<pre><code class="language-bash">luanext main.luax --reflection selective  # Default
luanext main.luax --reflection full
luanext main.luax --reflection none
</code></pre>
<ul>
<li><code>selective</code> — Include metadata for decorated items only</li>
<li><code>full</code> — Include metadata for all types and functions</li>
<li><code>none</code> — No reflection metadata</li>
</ul>
<p><strong>Metadata includes:</strong></p>
<ul>
<li>Type information</li>
<li>Decorator annotations</li>
<li>Parameter names</li>
<li>Property types</li>
</ul>
<h3 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h3>
<h4 id="--pretty"><a class="header" href="#--pretty"><code>--pretty</code></a></h4>
<p>Pretty print diagnostics (default: enabled).</p>
<pre><code class="language-bash">luanext main.luax --pretty
</code></pre>
<p><strong>With <code>--pretty</code>:</strong></p>
<pre><code>error[E0001]: Type mismatch
  ┌─ main.luax:5:10
  │
5 │     const x: number = "hello"
  │              ^^^^^^   ^^^^^^^ expected number, found string
  │              │
  │              type annotation
</code></pre>
<p><strong>Without <code>--pretty</code> (<code>--no-pretty</code>):</strong></p>
<pre><code>main.luax:5:10: error[E0001]: Type mismatch: expected number, found string
</code></pre>
<h4 id="--diagnostics"><a class="header" href="#--diagnostics"><code>--diagnostics</code></a></h4>
<p>Show diagnostic error codes in output.</p>
<pre><code class="language-bash">luanext main.luax --diagnostics
</code></pre>
<p>Includes error codes like <code>[E0001]</code>, <code>[E0042]</code> in diagnostic messages.</p>
<h3 id="information"><a class="header" href="#information">Information</a></h3>
<h4 id="--help"><a class="header" href="#--help"><code>--help</code></a></h4>
<p>Display help information.</p>
<pre><code class="language-bash">luanext --help
</code></pre>
<h4 id="--version"><a class="header" href="#--version"><code>--version</code></a></h4>
<p>Display version information.</p>
<pre><code class="language-bash">luanext --version
</code></pre>
<h2 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Code</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>0</code></td><td>Success (no errors)</td></tr>
<tr><td><code>1</code></td><td>Compilation error (type errors, syntax errors)</td></tr>
<tr><td><code>2</code></td><td>File not found or I/O error</td></tr>
<tr><td><code>3</code></td><td>Configuration error (invalid config file)</td></tr>
</tbody>
</table>
</div>
<h2 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h2>
<p>Instead of command-line options, use <code>luanext.config.yaml</code>:</p>
<pre><code class="language-yaml">compilerOptions:
  target: "5.4"
  outDir: "dist"
  outFile: "bundle.lua"
  sourceMap: true
  inlineSourceMap: false
  noEmit: false
  strictNullChecks: true
  enableDecorators: true
  moduleMode: "require"
  format: "readable"
  optimize: false
  reflection: "selective"
  pretty: true
  copyLuaToOutput: false

include:
  - "src/**/*.luax"
  - "tests/**/*.luax"

exclude:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/*.test.luax"
</code></pre>
<p>Command-line options override config file values.</p>
<p>See <a href="#configuration-reference">Configuration Reference</a> for complete options.</p>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<h3 id="basic-compilation"><a class="header" href="#basic-compilation">Basic Compilation</a></h3>
<pre><code class="language-bash"># Compile single file
luanext main.luax

# Compile to specific directory
luanext main.luax --out-dir build/

# Compile with source maps
luanext main.luax --source-map
</code></pre>
<h3 id="project-compilation"><a class="header" href="#project-compilation">Project Compilation</a></h3>
<pre><code class="language-bash"># Use project configuration
luanext

# Compile entire project
luanext "src/**/*.luax" --out-dir dist/

# Bundle project to single file
luanext "src/**/*.luax" --out-file app.lua
</code></pre>
<h3 id="watch-mode-1"><a class="header" href="#watch-mode-1">Watch Mode</a></h3>
<pre><code class="language-bash"># Watch for changes
luanext "src/**/*.luax" --watch --out-dir dist/

# Watch with optimizations
luanext "src/**/*.luax" --watch --optimize --out-file bundle.lua
</code></pre>
<h3 id="type-checking"><a class="header" href="#type-checking">Type Checking</a></h3>
<pre><code class="language-bash"># Type-check only (no output)
luanext "src/**/*.luax" --no-emit

# Type-check with strict settings
luanext main.luax --no-emit --no-implicit-unknown --strict-naming error
</code></pre>
<h3 id="optimization-1"><a class="header" href="#optimization-1">Optimization</a></h3>
<pre><code class="language-bash"># Optimize single file
luanext main.luax --optimize --out-file optimized.lua

# Optimize project bundle
luanext "src/**/*.luax" --optimize --out-file app.min.lua --format minified

# Profile optimizer performance
luanext main.luax --optimize --profile-optimizer
</code></pre>
<h3 id="cross-lua-version"><a class="header" href="#cross-lua-version">Cross-Lua-Version</a></h3>
<pre><code class="language-bash"># Target Lua 5.1 (LuaJIT compatible)
luanext main.luax --target 5.1 --out-dir dist-5.1/

# Target Lua 5.4 (latest features)
luanext main.luax --target 5.4 --out-dir dist-5.4/
</code></pre>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<h3 id="rust_log"><a class="header" href="#rust_log"><code>RUST_LOG</code></a></h3>
<p>Control logging verbosity.</p>
<pre><code class="language-bash"># Info level (default)
RUST_LOG=info luanext main.luax

# Debug level (detailed logs)
RUST_LOG=debug luanext main.luax

# Trace level (very verbose)
RUST_LOG=trace luanext main.luax

# Silence logs
RUST_LOG=off luanext main.luax
</code></pre>
<h3 id="no_color"><a class="header" href="#no_color"><code>NO_COLOR</code></a></h3>
<p>Disable colored output.</p>
<pre><code class="language-bash">NO_COLOR=1 luanext main.luax
</code></pre>
<h2 id="glob-patterns"><a class="header" href="#glob-patterns">Glob Patterns</a></h2>
<p>LuaNext supports standard glob patterns for file selection:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Matches</th></tr>
</thead>
<tbody>
<tr><td><code>*</code></td><td>Any characters except <code>/</code></td></tr>
<tr><td><code>**</code></td><td>Any characters including <code>/</code> (recursive)</td></tr>
<tr><td><code>?</code></td><td>Single character</td></tr>
<tr><td><code>[abc]</code></td><td>Any character in set</td></tr>
<tr><td><code>{a,b}</code></td><td>Either <code>a</code> or <code>b</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># All .luax files in src/
luanext "src/*.luax"

# All .luax files in src/ and subdirectories
luanext "src/**/*.luax"

# Only files matching pattern
luanext "src/**/*{Utils,Helper}.luax"

# Multiple patterns
luanext "src/**/*.luax" "lib/**/*.luax"
</code></pre>
<h2 id="tips-and-best-practices"><a class="header" href="#tips-and-best-practices">Tips and Best Practices</a></h2>
<h3 id="use-configuration-files"><a class="header" href="#use-configuration-files">Use Configuration Files</a></h3>
<p>For projects with complex settings, use <code>luanext.config.yaml</code>:</p>
<pre><code class="language-bash"># Automatically uses luanext.config.yaml
luanext

# Or specify config explicitly
luanext --project ./custom-config.yaml
</code></pre>
<h3 id="watch-mode-for-development"><a class="header" href="#watch-mode-for-development">Watch Mode for Development</a></h3>
<p>Use watch mode during development for fast feedback:</p>
<pre><code class="language-bash">luanext "src/**/*.luax" --watch --out-dir dist/
</code></pre>
<h3 id="optimization-for-production"><a class="header" href="#optimization-for-production">Optimization for Production</a></h3>
<p>Enable optimizations for production builds:</p>
<pre><code class="language-bash">luanext "src/**/*.luax" --optimize --out-file app.lua --format minified
</code></pre>
<h3 id="type-check-in-cicd"><a class="header" href="#type-check-in-cicd">Type-Check in CI/CD</a></h3>
<p>Use <code>--no-emit</code> for fast type checking in CI:</p>
<pre><code class="language-bash">luanext "src/**/*.luax" --no-emit --diagnostics
</code></pre>
<h3 id="debug-optimization-issues"><a class="header" href="#debug-optimization-issues">Debug Optimization Issues</a></h3>
<p>If optimizations cause issues, disable specific passes:</p>
<pre><code class="language-bash"># Disable tree shaking
luanext main.luax --optimize --no-tree-shake

# Disable scope hoisting
luanext main.luax --optimize --no-scope-hoist

# Disable all optimizations
luanext main.luax --no-optimize
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="no-input-files-specified"><a class="header" href="#no-input-files-specified">“No input files specified”</a></h3>
<p><strong>Problem:</strong> No files match the pattern or no files provided.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Check glob pattern matches files
ls src/**/*.luax

# Use quotes around patterns
luanext "src/**/*.luax"
</code></pre>
<h3 id="configuration-file-not-found"><a class="header" href="#configuration-file-not-found">“Configuration file not found”</a></h3>
<p><strong>Problem:</strong> <code>luanext.config.yaml</code> not found.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Initialize project
luanext --init

# Or specify config path
luanext --project path/to/config.yaml
</code></pre>
<h3 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h3>
<p><strong>Problem:</strong> Type errors or syntax errors.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Use pretty diagnostics
luanext main.luax --pretty --diagnostics

# Check specific file
luanext problem-file.luax --no-emit
</code></pre>
<h3 id="cache-issues"><a class="header" href="#cache-issues">Cache Issues</a></h3>
<p><strong>Problem:</strong> Stale cache causing incorrect behavior.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Clear cache and recompile
rm -rf .luanext-cache/
luanext main.luax

# Or disable cache
luanext main.luax --no-cache
</code></pre>
<h2 id="see-also-15"><a class="header" href="#see-also-15">See Also</a></h2>
<ul>
<li><a href="#configuration-reference">Configuration Reference</a> — Config file options</li>
<li><a href="#migrating-from-lua">Migrating from Lua</a> — Porting Lua code</li>
<li><a href="#targeting-different-lua-versions">Lua Targets</a> — Targeting different Lua versions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h1>
<p>Complete reference for <code>luanext.config.yaml</code> configuration file.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The <code>luanext.config.yaml</code> file configures the LuaNext compiler for your project. Place it in your project root to customize compiler behavior, type checking, output format, and more.</p>
<h2 id="configuration-file-structure"><a class="header" href="#configuration-file-structure">Configuration File Structure</a></h2>
<pre><code class="language-yaml">compilerOptions:
  # Type checking options
  strictNullChecks: true
  strictNaming: "error"
  noImplicitUnknown: false
  noExplicitUnknown: false

  # Code generation options
  target: "5.4"
  enableDecorators: true
  allowNonTypedLua: true

  # Output options
  outDir: "dist"
  outFile: null
  sourceMap: false
  noEmit: false

  # Module system
  moduleMode: "require"
  modulePaths:
    - "./?.luax"
    - "./lua_modules/?.luax"
  enforceNamespacePath: false

  # Formatting
  outputFormat: "readable"
  pretty: true
  copyLuaToOutput: false

include:
  - "src/**/*.luax"
  - "lib/**/*.luax"

exclude:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/*.test.luax"
</code></pre>
<h2 id="compiler-options"><a class="header" href="#compiler-options">Compiler Options</a></h2>
<h3 id="compileroptionsstrictnullchecks"><a class="header" href="#compileroptionsstrictnullchecks"><code>compilerOptions.strictNullChecks</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>true</code></p>
<p>Enable strict null checking. When enabled, values cannot be <code>nil</code> unless explicitly allowed with union types.</p>
<pre><code class="language-yaml">compilerOptions:
  strictNullChecks: true
</code></pre>
<p><strong>With strict null checks:</strong></p>
<pre><code class="language-lua">function greet(name: string): void
    print("Hello, " .. name)
end

greet(nil)  -- ❌ Error: Cannot pass nil to string parameter
</code></pre>
<p><strong>Without strict null checks:</strong></p>
<pre><code class="language-lua">function greet(name: string): void
    print("Hello, " .. (name or "Guest"))
end

greet(nil)  -- ✅ OK (nil treated as valid string)
</code></pre>
<p><strong>Recommendation:</strong> Keep enabled for type safety. Use <code>string | nil</code> when nil is intentional.</p>
<h3 id="compileroptionsstrictnaming"><a class="header" href="#compileroptionsstrictnaming"><code>compilerOptions.strictNaming</code></a></h3>
<p><strong>Type:</strong> <code>"off" | "warning" | "error"</code>
<strong>Default:</strong> <code>"error"</code></p>
<p>Enforce naming conventions for identifiers.</p>
<pre><code class="language-yaml">compilerOptions:
  strictNaming: "error"  # Violations are errors
  # OR
  strictNaming: "warning"  # Violations are warnings
  # OR
  strictNaming: "off"  # No enforcement
</code></pre>
<p><strong>Naming conventions checked:</strong></p>
<ul>
<li><strong>Constants</strong> — <code>UPPER_SNAKE_CASE</code> (<code>MAX_SIZE</code>, <code>DEFAULT_TIMEOUT</code>)</li>
<li><strong>Variables</strong> — <code>camelCase</code> or <code>snake_case</code> (<code>userName</code>, <code>user_name</code>)</li>
<li><strong>Types/Interfaces</strong> — <code>PascalCase</code> (<code>UserProfile</code>, <code>HttpRequest</code>)</li>
<li><strong>Functions</strong> — <code>camelCase</code> or <code>snake_case</code> (<code>getUserName</code>, <code>get_user_name</code>)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">const MAX_SIZE: number = 100  -- ✅ OK (UPPER_SNAKE_CASE)
const maxSize: number = 100   -- ❌ Error with strictNaming: "error"

interface UserData  -- ✅ OK (PascalCase)
interface user_data  -- ❌ Error with strictNaming: "error"
</code></pre>
<h3 id="compileroptionsnoimplicitunknown"><a class="header" href="#compileroptionsnoimplicitunknown"><code>compilerOptions.noImplicitUnknown</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>false</code></p>
<p>Disallow implicit <code>unknown</code> types. Requires explicit type annotations.</p>
<pre><code class="language-yaml">compilerOptions:
  noImplicitUnknown: true
</code></pre>
<p><strong>With <code>noImplicitUnknown: true</code>:</strong></p>
<pre><code class="language-lua">function process(data)  -- ❌ Error: Parameter 'data' has implicit unknown type
    print(data)
end

-- Must annotate explicitly
function process(data: unknown): void  -- ✅ OK
    print(data)
end
</code></pre>
<p><strong>Recommendation:</strong> Enable for libraries and shared code. Disable for rapid prototyping.</p>
<h3 id="compileroptionsnoexplicitunknown"><a class="header" href="#compileroptionsnoexplicitunknown"><code>compilerOptions.noExplicitUnknown</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>false</code></p>
<p>Disallow explicit <code>unknown</code> types. Forces all types to be known.</p>
<pre><code class="language-yaml">compilerOptions:
  noExplicitUnknown: true
</code></pre>
<p><strong>With <code>noExplicitUnknown: true</code>:</strong></p>
<pre><code class="language-lua">const data: unknown = getData()  -- ❌ Error: unknown type not allowed

-- Must use specific type
const data: string | number | table = getData()  -- ✅ OK
</code></pre>
<p><strong>Recommendation:</strong> Rarely needed. Use only in highly type-strict codebases.</p>
<h3 id="compileroptionstarget"><a class="header" href="#compileroptionstarget"><code>compilerOptions.target</code></a></h3>
<p><strong>Type:</strong> <code>"5.1" | "5.2" | "5.3" | "5.4"</code>
<strong>Default:</strong> <code>"5.4"</code></p>
<p>Target Lua version for code generation.</p>
<pre><code class="language-yaml">compilerOptions:
  target: "5.4"  # Latest features
  # OR
  target: "5.1"  # LuaJIT compatible
</code></pre>
<p><strong>Affects:</strong></p>
<ul>
<li><strong>Integers</strong> — Native in 5.3+, type-checked only in 5.1/5.2</li>
<li><strong>Bitwise operators</strong> — Native in 5.3+, library calls in 5.1/5.2</li>
<li><strong>Integer division (<code>//</code>)</strong> — Native in 5.3+, <code>math.floor(a/b)</code> in 5.1/5.2</li>
<li><strong>Standard library</strong> — Different functions available in different versions</li>
</ul>
<p>See <a href="#targeting-different-lua-versions">Lua Targets Guide</a> for complete compatibility matrix.</p>
<h3 id="compileroptionsenabledecorators"><a class="header" href="#compileroptionsenabledecorators"><code>compilerOptions.enableDecorators</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>true</code></p>
<p>Enable decorator syntax (<code>@decorator</code>).</p>
<pre><code class="language-yaml">compilerOptions:
  enableDecorators: true
</code></pre>
<p><strong>With decorators enabled:</strong></p>
<pre><code class="language-lua">@readonly
class Config
    version: string
end
</code></pre>
<p><strong>Without decorators:</strong></p>
<pre><code class="language-lua">-- Decorator syntax not available
class Config
    readonly version: string  -- Use property modifier instead
end
</code></pre>
<h3 id="compileroptionsallownontypedlua"><a class="header" href="#compileroptionsallownontypedlua"><code>compilerOptions.allowNonTypedLua</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>true</code></p>
<p>Allow importing plain <code>.lua</code> files without type information.</p>
<pre><code class="language-yaml">compilerOptions:
  allowNonTypedLua: true
</code></pre>
<p><strong>With <code>allowNonTypedLua: true</code>:</strong></p>
<pre><code class="language-lua">import * as legacy from "./legacy-code.lua"  -- ✅ OK (types treated as unknown)
</code></pre>
<p><strong>With <code>allowNonTypedLua: false</code>:</strong></p>
<pre><code class="language-lua">import * as legacy from "./legacy-code.lua"  -- ❌ Error: Cannot import untyped Lua
</code></pre>
<p><strong>Recommendation:</strong> Keep enabled when gradually migrating from Lua. Disable for fully-typed codebases.</p>
<h3 id="compileroptionsoutdir"><a class="header" href="#compileroptionsoutdir"><code>compilerOptions.outDir</code></a></h3>
<p><strong>Type:</strong> <code>string | null</code>
<strong>Default:</strong> <code>null</code> (output to same directory as input)</p>
<p>Output directory for compiled Lua files.</p>
<pre><code class="language-yaml">compilerOptions:
  outDir: "dist"
</code></pre>
<p><strong>Directory structure:</strong></p>
<pre><code>project/
├── src/
│   ├── main.luax
│   └── utils/
│       └── helpers.luax
└── dist/                    # Output directory
    ├── main.lua
    └── utils/
        └── helpers.lua
</code></pre>
<p><strong>Preserves source structure:</strong> Directory hierarchy from source is maintained in output.</p>
<h3 id="compileroptionsoutfile"><a class="header" href="#compileroptionsoutfile"><code>compilerOptions.outFile</code></a></h3>
<p><strong>Type:</strong> <code>string | null</code>
<strong>Default:</strong> <code>null</code> (separate files)</p>
<p>Bundle all output into a single file.</p>
<pre><code class="language-yaml">compilerOptions:
  outFile: "bundle.lua"
</code></pre>
<p><strong>Single file output:</strong></p>
<pre><code>project/
├── src/
│   ├── main.luax
│   └── utils.luax
└── bundle.lua  # All modules in one file
</code></pre>
<p><strong>Note:</strong> Uses bundling strategy to combine all modules. Mutually exclusive with separate file output.</p>
<h3 id="compileroptionssourcemap"><a class="header" href="#compileroptionssourcemap"><code>compilerOptions.sourceMap</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>false</code></p>
<p>Generate source maps (<code>.lua.map</code> files).</p>
<pre><code class="language-yaml">compilerOptions:
  sourceMap: true
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>dist/
├── main.lua
└── main.lua.map  # Source map for debugging
</code></pre>
<p><strong>Source maps enable:</strong></p>
<ul>
<li>Debugging LuaNext code from generated Lua</li>
<li>Accurate error locations in stack traces</li>
<li>IDE integration for breakpoints</li>
</ul>
<h3 id="compileroptionsnoemit"><a class="header" href="#compileroptionsnoemit"><code>compilerOptions.noEmit</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>false</code></p>
<p>Type-check only, do not generate output files.</p>
<pre><code class="language-yaml">compilerOptions:
  noEmit: true
</code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>CI/CD type checking</li>
<li>Editor integration (LSP)</li>
<li>Pre-commit hooks</li>
</ul>
<h3 id="compileroptionspretty"><a class="header" href="#compileroptionspretty"><code>compilerOptions.pretty</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>true</code></p>
<p>Pretty-print diagnostic messages with colors and context.</p>
<pre><code class="language-yaml">compilerOptions:
  pretty: true
</code></pre>
<p><strong>With pretty output:</strong></p>
<pre><code>error[E0001]: Type mismatch
  ┌─ main.luax:5:10
  │
5 │     const x: number = "hello"
  │              ^^^^^^   ^^^^^^^ expected number, found string
  │              │
  │              type annotation
</code></pre>
<p><strong>Without pretty output:</strong></p>
<pre><code>main.luax:5:10: error[E0001]: Type mismatch: expected number, found string
</code></pre>
<h3 id="compileroptionsmodulemode"><a class="header" href="#compileroptionsmodulemode"><code>compilerOptions.moduleMode</code></a></h3>
<p><strong>Type:</strong> <code>"require" | "bundle"</code>
<strong>Default:</strong> <code>"require"</code></p>
<p>Module code generation mode.</p>
<pre><code class="language-yaml">compilerOptions:
  moduleMode: "require"  # Separate files with require()
  # OR
  moduleMode: "bundle"   # Inline all modules
</code></pre>
<p><strong><code>require</code> mode:</strong></p>
<pre><code class="language-lua">-- Generates separate files
local utils = require("utils")
local helper = utils.helper
</code></pre>
<p><strong><code>bundle</code> mode:</strong></p>
<pre><code class="language-lua">-- Inlines modules
local utils = (function()
    -- utils module code
end)()
local helper = utils.helper
</code></pre>
<h3 id="compileroptionsmodulepaths"><a class="header" href="#compileroptionsmodulepaths"><code>compilerOptions.modulePaths</code></a></h3>
<p><strong>Type:</strong> <code>string[]</code>
<strong>Default:</strong></p>
<pre><code class="language-yaml">- "./?.luax"
- "./lua_modules/?.luax"
- "./lua_modules/?/init.luax"
</code></pre>
<p>Module search paths for resolving imports.</p>
<pre><code class="language-yaml">compilerOptions:
  modulePaths:
    - "./?.luax"
    - "./lib/?.luax"
    - "./vendor/?/init.luax"
</code></pre>
<p><strong>Path patterns:</strong></p>
<ul>
<li><code>?</code> — Replaced with module name</li>
<li>Example: Importing <code>"utils"</code> checks <code>./utils.luax</code>, <code>./lib/utils.luax</code>, <code>./vendor/utils/init.luax</code></li>
</ul>
<h3 id="compileroptionsenforcenamespacepath"><a class="header" href="#compileroptionsenforcenamespacepath"><code>compilerOptions.enforceNamespacePath</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>false</code></p>
<p>Enforce that namespace declarations match file paths.</p>
<pre><code class="language-yaml">compilerOptions:
  enforceNamespacePath: true
</code></pre>
<p><strong>With enforcement:</strong></p>
<pre><code class="language-lua">-- File: src/MyApp/Utils.luax
namespace MyApp.Utils  -- ✅ OK (matches path)

-- File: src/MyApp/Utils.luax
namespace Other.Name  -- ❌ Error: Namespace doesn't match file path
</code></pre>
<h3 id="compileroptionsoutputformat"><a class="header" href="#compileroptionsoutputformat"><code>compilerOptions.outputFormat</code></a></h3>
<p><strong>Type:</strong> <code>"readable" | "compact" | "minified"</code>
<strong>Default:</strong> <code>"readable"</code></p>
<p>Output format for generated Lua code.</p>
<pre><code class="language-yaml">compilerOptions:
  outputFormat: "readable"  # Pretty formatting (default)
  # OR
  outputFormat: "compact"   # Minimal whitespace
  # OR
  outputFormat: "minified"  # No unnecessary whitespace
</code></pre>
<p><strong>Readable:</strong></p>
<pre><code class="language-lua">local function add(a, b)
    return a + b
end
</code></pre>
<p><strong>Compact:</strong></p>
<pre><code class="language-lua">local function add(a, b)
  return a + b
end
</code></pre>
<p><strong>Minified:</strong></p>
<pre><code class="language-lua">local function add(a,b)return a+b end
</code></pre>
<h3 id="compileroptionscopyluatooutput"><a class="header" href="#compileroptionscopyluatooutput"><code>compilerOptions.copyLuaToOutput</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code>
<strong>Default:</strong> <code>false</code></p>
<p>Copy plain <code>.lua</code> files to output directory during compilation.</p>
<pre><code class="language-yaml">compilerOptions:
  copyLuaToOutput: true
  outDir: "dist"
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>src/
├── main.luax       # Compiled to dist/main.lua
└── legacy.lua      # Copied to dist/legacy.lua (if copyLuaToOutput: true)
</code></pre>
<p><strong>Use case:</strong> Include plain Lua files in output directory without modification.</p>
<h2 id="includeexclude-patterns"><a class="header" href="#includeexclude-patterns">Include/Exclude Patterns</a></h2>
<h3 id="include"><a class="header" href="#include"><code>include</code></a></h3>
<p><strong>Type:</strong> <code>string[]</code>
<strong>Default:</strong> <code>["**/*.luax"]</code></p>
<p>Files to include in compilation (glob patterns).</p>
<pre><code class="language-yaml">include:
  - "src/**/*.luax"
  - "lib/**/*.luax"
  - "tests/**/*.luax"
</code></pre>
<p><strong>Glob patterns:</strong></p>
<ul>
<li><code>*</code> — Match any characters except <code>/</code></li>
<li><code>**</code> — Match any characters including <code>/</code> (recursive)</li>
<li><code>?</code> — Match single character</li>
<li><code>{a,b}</code> — Match either <code>a</code> or <code>b</code></li>
</ul>
<h3 id="exclude"><a class="header" href="#exclude"><code>exclude</code></a></h3>
<p><strong>Type:</strong> <code>string[]</code>
<strong>Default:</strong></p>
<pre><code class="language-yaml">- "**/node_modules/**"
- "**/dist/**"
</code></pre>
<p>Files to exclude from compilation (glob patterns).</p>
<pre><code class="language-yaml">exclude:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/*.test.luax"
  - "**/examples/**"
</code></pre>
<p><strong>Exclude takes precedence:</strong> Files matching <code>exclude</code> are omitted even if they match <code>include</code>.</p>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<h3 id="development-configuration"><a class="header" href="#development-configuration">Development Configuration</a></h3>
<p>Fast compilation, detailed errors:</p>
<pre><code class="language-yaml">compilerOptions:
  target: "5.4"
  strictNullChecks: true
  outDir: "build"
  sourceMap: true
  pretty: true
  outputFormat: "readable"
  allowNonTypedLua: true

include:
  - "src/**/*.luax"

exclude:
  - "**/node_modules/**"
  - "**/build/**"
</code></pre>
<h3 id="production-configuration"><a class="header" href="#production-configuration">Production Configuration</a></h3>
<p>Optimized output, strict checking:</p>
<pre><code class="language-yaml">compilerOptions:
  target: "5.3"
  strictNullChecks: true
  strictNaming: "error"
  noImplicitUnknown: true
  outFile: "app.lua"
  sourceMap: false
  outputFormat: "minified"
  allowNonTypedLua: false

include:
  - "src/**/*.luax"

exclude:
  - "**/node_modules/**"
  - "**/tests/**"
  - "**/*.test.luax"
</code></pre>
<h3 id="library-configuration"><a class="header" href="#library-configuration">Library Configuration</a></h3>
<p>Type-safe, portable:</p>
<pre><code class="language-yaml">compilerOptions:
  target: "5.1"  # LuaJIT compatible
  strictNullChecks: true
  strictNaming: "error"
  noImplicitUnknown: true
  outDir: "dist"
  sourceMap: true
  outputFormat: "readable"
  enableDecorators: false  # Avoid advanced features

include:
  - "src/**/*.luax"

exclude:
  - "**/node_modules/**"
  - "**/examples/**"
  - "**/tests/**"
</code></pre>
<h3 id="gradual-migration-configuration"><a class="header" href="#gradual-migration-configuration">Gradual Migration Configuration</a></h3>
<p>Permissive for Lua → LuaNext migration:</p>
<pre><code class="language-yaml">compilerOptions:
  target: "5.1"
  strictNullChecks: false  # Allow nil everywhere
  strictNaming: "off"      # No naming enforcement
  noImplicitUnknown: false
  outDir: "build"
  pretty: true
  allowNonTypedLua: true   # Allow importing .lua files
  copyLuaToOutput: true    # Copy non-typed files

include:
  - "src/**/*.luax"
  - "src/**/*.lua"  # Include legacy Lua

exclude:
  - "**/node_modules/**"
</code></pre>
<h2 id="cli-overrides"><a class="header" href="#cli-overrides">CLI Overrides</a></h2>
<p>Command-line options override configuration file values:</p>
<pre><code class="language-bash"># Config has target: "5.4", CLI overrides to 5.1
luanext --target 5.1 main.luax

# Config has outDir: "build", CLI overrides to "dist"
luanext --out-dir dist main.luax

# Config has sourceMap: false, CLI enables it
luanext --source-map main.luax
</code></pre>
<p><strong>Precedence:</strong> CLI &gt; Config File &gt; Defaults</p>
<h2 id="configuration-loading"><a class="header" href="#configuration-loading">Configuration Loading</a></h2>
<h3 id="automatic-discovery"><a class="header" href="#automatic-discovery">Automatic Discovery</a></h3>
<p>LuaNext searches for <code>luanext.config.yaml</code> in:</p>
<ol>
<li>Current directory</li>
<li>Parent directories (up to project root)</li>
<li>Stops at first match</li>
</ol>
<pre><code class="language-bash"># Automatically finds ./luanext.config.yaml
luanext src/main.luax
</code></pre>
<h3 id="explicit-path"><a class="header" href="#explicit-path">Explicit Path</a></h3>
<p>Specify config file path with <code>--project</code>:</p>
<pre><code class="language-bash">luanext --project ./configs/prod.yaml src/main.luax
</code></pre>
<h3 id="no-configuration"><a class="header" href="#no-configuration">No Configuration</a></h3>
<p>Without a config file, all defaults are used:</p>
<pre><code class="language-bash"># Uses all default options
luanext main.luax
</code></pre>
<h2 id="initializing-configuration"><a class="header" href="#initializing-configuration">Initializing Configuration</a></h2>
<h3 id="create-default-config"><a class="header" href="#create-default-config">Create Default Config</a></h3>
<pre><code class="language-bash">luanext --init
</code></pre>
<p>Creates <code>luanext.config.yaml</code> with default settings:</p>
<pre><code class="language-yaml">compilerOptions:
  strictNullChecks: true
  strictNaming: error
  noImplicitUnknown: false
  noExplicitUnknown: false
  target: '5.4'
  enableDecorators: true
  allowNonTypedLua: true
  copyLuaToOutput: false
  sourceMap: false
  noEmit: false
  pretty: true
  moduleMode: require
  modulePaths:
  - ./?.luax
  - ./lua_modules/?.luax
  - ./lua_modules/?/init.luax
  enforceNamespacePath: false
  outputFormat: readable
include:
- '**/*.luax'
exclude:
- '**/node_modules/**'
- '**/dist/**'
</code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<h3 id="use-version-control"><a class="header" href="#use-version-control">Use Version Control</a></h3>
<p>Commit <code>luanext.config.yaml</code> to version control:</p>
<pre><code class="language-bash">git add luanext.config.yaml
git commit -m "Add LuaNext configuration"
</code></pre>
<h3 id="separate-devprod-configs"><a class="header" href="#separate-devprod-configs">Separate Dev/Prod Configs</a></h3>
<p>Use different configs for environments:</p>
<pre><code>project/
├── luanext.config.yaml       # Development (default)
├── luanext.prod.yaml         # Production
└── luanext.test.yaml         # Testing
</code></pre>
<pre><code class="language-bash"># Development
luanext

# Production
luanext --project luanext.prod.yaml

# Testing
luanext --project luanext.test.yaml
</code></pre>
<h3 id="document-custom-settings"><a class="header" href="#document-custom-settings">Document Custom Settings</a></h3>
<p>Add comments to explain non-standard options:</p>
<pre><code class="language-yaml">compilerOptions:
  # Using 5.1 for LuaJIT compatibility
  target: "5.1"

  # Disabled during migration from Lua
  strictNullChecks: false

  # Required by third-party library
  allowNonTypedLua: true
</code></pre>
<h3 id="validate-configuration"><a class="header" href="#validate-configuration">Validate Configuration</a></h3>
<p>Test config changes with <code>--no-emit</code>:</p>
<pre><code class="language-bash"># Check configuration without generating files
luanext --no-emit src/**/*.luax
</code></pre>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="configuration-file-not-found-1"><a class="header" href="#configuration-file-not-found-1">“Configuration file not found”</a></h3>
<p><strong>Problem:</strong> <code>luanext.config.yaml</code> not found in current or parent directories.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Create default config
luanext --init

# Or specify path explicitly
luanext --project path/to/config.yaml
</code></pre>
<h3 id="invalid-configuration"><a class="header" href="#invalid-configuration">“Invalid configuration”</a></h3>
<p><strong>Problem:</strong> YAML syntax error or invalid option value.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Check YAML syntax
yamllint luanext.config.yaml

# Validate against schema
luanext --project luanext.config.yaml --no-emit
</code></pre>
<h3 id="options-not-taking-effect"><a class="header" href="#options-not-taking-effect">Options Not Taking Effect</a></h3>
<p><strong>Problem:</strong> CLI overrides or incorrect option names.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Check CLI flags (they override config)</li>
<li>Verify option names use <code>camelCase</code> (e.g., <code>strictNullChecks</code> not <code>strict_null_checks</code>)</li>
<li>Check for typos in YAML keys</li>
</ul>
<h2 id="see-also-16"><a class="header" href="#see-also-16">See Also</a></h2>
<ul>
<li><a href="#cli-reference">CLI Reference</a> — Command-line options</li>
<li><a href="#migrating-from-lua">Migrating from Lua</a> — Migration strategies</li>
<li><a href="#targeting-different-lua-versions">Lua Targets</a> — Target version details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="standard-library-reference"><a class="header" href="#standard-library-reference">Standard Library Reference</a></h1>
<p>Complete reference for Lua standard library functions with LuaNext type annotations.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>LuaNext provides type definitions for the entire Lua standard library across all versions (5.1-5.4). These types enable autocomplete, type checking, and documentation in your editor.</p>
<p><strong>Coverage:</strong></p>
<ul>
<li>Global functions (print, type, tostring, etc.)</li>
<li>string module</li>
<li>table module</li>
<li>math module</li>
<li>io module</li>
<li>os module</li>
<li>debug module</li>
<li>coroutine module</li>
<li>package module</li>
<li>Version-specific modules (bit32, utf8, etc.)</li>
</ul>
<h2 id="global-functions"><a class="header" href="#global-functions">Global Functions</a></h2>
<h3 id="output-functions"><a class="header" href="#output-functions">Output Functions</a></h3>
<h4 id="printargs-unknown-void"><a class="header" href="#printargs-unknown-void"><code>print(...args: unknown): void</code></a></h4>
<p>Prints values to standard output.</p>
<pre><code class="language-lua">print("Hello, World!")
print("Count:", 42)
print(1, 2, 3, 4, 5)
</code></pre>
<p><strong>Automatically converts values using <code>tostring()</code>.</strong></p>
<h3 id="type-functions"><a class="header" href="#type-functions">Type Functions</a></h3>
<h4 id="typevalue-unknown-string"><a class="header" href="#typevalue-unknown-string"><code>type(value: unknown): string</code></a></h4>
<p>Returns the type of a value as a string.</p>
<p><strong>Possible return values:</strong></p>
<ul>
<li><code>"nil"</code> — nil value</li>
<li><code>"boolean"</code> — true or false</li>
<li><code>"number"</code> — numeric value</li>
<li><code>"string"</code> — text value</li>
<li><code>"function"</code> — function</li>
<li><code>"table"</code> — table/object</li>
<li><code>"thread"</code> — coroutine</li>
<li><code>"userdata"</code> — C userdata</li>
</ul>
<pre><code class="language-lua">print(type(42))          -- "number"
print(type("hello"))     -- "string"
print(type({}))          -- "table"
print(type(nil))         -- "nil"
</code></pre>
<h4 id="tostringvalue-unknown-string"><a class="header" href="#tostringvalue-unknown-string"><code>tostring(value: unknown): string</code></a></h4>
<p>Converts a value to a string.</p>
<pre><code class="language-lua">const str: string = tostring(42)        -- "42"
const str2: string = tostring(true)     -- "true"
const str3: string = tostring({x = 1})  -- "table: 0x..."
</code></pre>
<p><strong>Calls <code>__tostring</code> metamethod if available.</strong></p>
<h4 id="tonumbervalue-string--number-base-number-number--nil"><a class="header" href="#tonumbervalue-string--number-base-number-number--nil"><code>tonumber(value: string | number, base?: number): number | nil</code></a></h4>
<p>Converts a string or number to a number.</p>
<pre><code class="language-lua">const num: number | nil = tonumber("42")      -- 42
const hex: number | nil = tonumber("FF", 16)  -- 255
const bin: number | nil = tonumber("1010", 2) -- 10
const invalid: number | nil = tonumber("abc") -- nil
</code></pre>
<p><strong>Base:</strong> Optional base for conversion (2-36), default is 10.</p>
<h3 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h3>
<h4 id="errormessage-unknown-level-number-never"><a class="header" href="#errormessage-unknown-level-number-never"><code>error(message: unknown, level?: number): never</code></a></h4>
<p>Raises an error with the given message.</p>
<pre><code class="language-lua">if value &lt; 0 then
    error("Value must be positive")
end

-- With stack level
error("Invalid argument", 2)  -- Report error at caller
</code></pre>
<p><strong>Never returns</strong> — execution stops and error propagates.</p>
<h4 id="asserttcondition-t-message-string-t"><a class="header" href="#asserttcondition-t-message-string-t"><code>assert&lt;T&gt;(condition: T, message?: string): T</code></a></h4>
<p>Checks a condition, raises error if false.</p>
<pre><code class="language-lua">const file = assert(io.open("data.txt"), "File not found")
-- If open returns nil, raises error with message

const value: number = assert(getValue())
-- Narrows type: value is guaranteed non-nil after assert
</code></pre>
<p><strong>Returns the condition value if true.</strong></p>
<h3 id="table-access"><a class="header" href="#table-access">Table Access</a></h3>
<h4 id="rawgetk-vtable-k-v-key-k-v--nil"><a class="header" href="#rawgetk-vtable-k-v-key-k-v--nil"><code>rawget&lt;K, V&gt;(table: {[K]: V}, key: K): V | nil</code></a></h4>
<p>Gets a table value, bypassing metamethods.</p>
<pre><code class="language-lua">const value = rawget(obj, "key")  -- Ignores __index metamethod
</code></pre>
<h4 id="rawsetk-vtable-k-v-key-k-value-v-k-v"><a class="header" href="#rawsetk-vtable-k-v-key-k-value-v-k-v"><code>rawset&lt;K, V&gt;(table: {[K]: V}, key: K, value: V): {[K]: V}</code></a></h4>
<p>Sets a table value, bypassing metamethods.</p>
<pre><code class="language-lua">rawset(obj, "key", "value")  -- Ignores __newindex metamethod
</code></pre>
<h4 id="rawequaltv1-t-v2-t-boolean"><a class="header" href="#rawequaltv1-t-v2-t-boolean"><code>rawequal&lt;T&gt;(v1: T, v2: T): boolean</code></a></h4>
<p>Compares values for equality, bypassing <code>__eq</code> metamethod.</p>
<pre><code class="language-lua">const equal: boolean = rawequal(a, b)  -- True raw equality
</code></pre>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<h4 id="pairsk-vtable-k-v-iterator"><a class="header" href="#pairsk-vtable-k-v-iterator"><code>pairs&lt;K, V&gt;(table: {[K]: V}): iterator</code></a></h4>
<p>Returns an iterator for all key-value pairs.</p>
<pre><code class="language-lua">const data = {x = 1, y = 2, z = 3}

for key, value in pairs(data) do
    print(key, value)
end
-- Output: x  1, y  2, z  3 (order not guaranteed)
</code></pre>
<h4 id="ipairsvtable-v-iterator"><a class="header" href="#ipairsvtable-v-iterator"><code>ipairs&lt;V&gt;(table: V[]): iterator</code></a></h4>
<p>Returns an iterator for sequential integer keys.</p>
<pre><code class="language-lua">const arr: number[] = {10, 20, 30, 40}

for i, value in ipairs(arr) do
    print(i, value)
end
-- Output: 1  10, 2  20, 3  30, 4  40
</code></pre>
<p><strong>Stops at first nil value.</strong></p>
<h4 id="nextk-vtable-k-v-key-k-k--nil-v--nil"><a class="header" href="#nextk-vtable-k-v-key-k-k--nil-v--nil"><code>next&lt;K, V&gt;(table: {[K]: V}, key?: K): (K | nil, V | nil)</code></a></h4>
<p>Returns the next key-value pair (used internally by <code>pairs</code>).</p>
<pre><code class="language-lua">const t = {a = 1, b = 2, c = 3}
const key, value = next(t, nil)  -- First pair
</code></pre>
<h3 id="metatables"><a class="header" href="#metatables">Metatables</a></h3>
<h4 id="setmetatablet-mtable-t-metatable-m--nil-t"><a class="header" href="#setmetatablet-mtable-t-metatable-m--nil-t"><code>setmetatable&lt;T, M&gt;(table: T, metatable: M | nil): T</code></a></h4>
<p>Sets or removes a metatable.</p>
<pre><code class="language-lua">const obj = {}
const mt = {
    __index = function(t, key)
        return "default"
    end
}

setmetatable(obj, mt)
print(obj.any_key)  -- "default"
</code></pre>
<h4 id="getmetatabletvalue-t-table--nil"><a class="header" href="#getmetatabletvalue-t-table--nil"><code>getmetatable&lt;T&gt;(value: T): table | nil</code></a></h4>
<p>Gets the metatable of a value.</p>
<pre><code class="language-lua">const mt = getmetatable(obj)

if mt ~= nil then
    print("Has metatable")
end
</code></pre>
<p><strong>Returns <code>__metatable</code> field if set</strong> (metatable protection).</p>
<h3 id="argument-handling"><a class="header" href="#argument-handling">Argument Handling</a></h3>
<h4 id="selecttindex-number---args-t-unknown"><a class="header" href="#selecttindex-number---args-t-unknown"><code>select&lt;T&gt;(index: number | "#", ...args: T[]): unknown</code></a></h4>
<p>Selects arguments from a variable argument list.</p>
<pre><code class="language-lua">-- Get count of arguments
const count: number = select("#", 1, 2, 3, 4, 5)  -- 5

-- Get arguments from index 3 onward
const a, b, c = select(3, 10, 20, 30, 40, 50)  -- 30, 40, 50
</code></pre>
<h4 id="unpacktlist-t-i-number-j-number-t"><a class="header" href="#unpacktlist-t-i-number-j-number-t"><code>unpack&lt;T&gt;(list: T[], i?: number, j?: number): ...T</code></a></h4>
<p>Returns multiple values from a table (Lua 5.1 name for <code>table.unpack</code>).</p>
<pre><code class="language-lua">const arr = {1, 2, 3, 4, 5}
print(unpack(arr))        -- 1  2  3  4  5
print(unpack(arr, 2, 4))  -- 2  3  4
</code></pre>
<h3 id="code-execution"><a class="header" href="#code-execution">Code Execution</a></h3>
<h4 id="loadchunk-string----string--nil-chunkname-string-mode-t--b--bt-env-table---unknown--nil-string--nil"><a class="header" href="#loadchunk-string----string--nil-chunkname-string-mode-t--b--bt-env-table---unknown--nil-string--nil"><code>load(chunk: string | (() =&gt; string | nil), chunkname?: string, mode?: "t" | "b" | "bt", env?: table): (() =&gt; unknown) | nil, string | nil</code></a></h4>
<p>Loads a chunk from a string or function.</p>
<pre><code class="language-lua">const func, err = load("return 2 + 2")
if func ~= nil then
    print(func())  -- 4
else
    print("Error:", err)
end
</code></pre>
<p><strong>Mode:</strong></p>
<ul>
<li><code>"t"</code> — Text only (Lua source)</li>
<li><code>"b"</code> — Binary only (bytecode)</li>
<li><code>"bt"</code> — Both (default)</li>
</ul>
<h4 id="loadfilefilename-string-mode-t--b--bt-env-table---unknown--nil-string--nil"><a class="header" href="#loadfilefilename-string-mode-t--b--bt-env-table---unknown--nil-string--nil"><code>loadfile(filename?: string, mode?: "t" | "b" | "bt", env?: table): (() =&gt; unknown) | nil, string | nil</code></a></h4>
<p>Loads a chunk from a file.</p>
<pre><code class="language-lua">const func, err = loadfile("script.lua")
if func ~= nil then
    func()  -- Execute the loaded script
end
</code></pre>
<h4 id="dofilefilename-string-unknown"><a class="header" href="#dofilefilename-string-unknown"><code>dofile(filename?: string): ...unknown</code></a></h4>
<p>Loads and executes a file.</p>
<pre><code class="language-lua">dofile("init.lua")  -- Load and run init.lua
</code></pre>
<p><strong>Deprecated:</strong> Use <code>loadfile</code> for better error handling.</p>
<h4 id="pcallt-rfunc-t--r-args-t-true-r--false-string"><a class="header" href="#pcallt-rfunc-t--r-args-t-true-r--false-string"><code>pcall&lt;T, R&gt;(func: (...T) =&gt; ...R, ...args: T): (true, ...R) | (false, string)</code></a></h4>
<p>Calls a function in protected mode.</p>
<pre><code class="language-lua">const success, result = pcall(function()
    return riskyOperation()
end)

if success then
    print("Result:", result)
else
    print("Error:", result)  -- result is error message
end
</code></pre>
<p><strong>Returns:</strong> <code>true</code> + results on success, <code>false</code> + error message on failure.</p>
<h4 id="xpcallt-rfunc-t--r-errorhandler-error-unknown--unknown-args-t-unknown"><a class="header" href="#xpcallt-rfunc-t--r-errorhandler-error-unknown--unknown-args-t-unknown"><code>xpcall&lt;T, R&gt;(func: (...T) =&gt; ...R, errorHandler: (error: unknown) =&gt; unknown, ...args: T): ...unknown</code></a></h4>
<p>Calls a function with a custom error handler.</p>
<pre><code class="language-lua">const result = xpcall(
    function() return operation() end,
    function(err)
        print("Error occurred:", err)
        print(debug.traceback())
        return nil
    end
)
</code></pre>
<h3 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h3>
<h4 id="collectgarbageopt-collect--stop--restart--count--step--setpause--setstepmul--isrunning-arg-number-unknown"><a class="header" href="#collectgarbageopt-collect--stop--restart--count--step--setpause--setstepmul--isrunning-arg-number-unknown"><code>collectgarbage(opt?: "collect" | "stop" | "restart" | "count" | "step" | "setpause" | "setstepmul" | "isrunning", arg?: number): unknown</code></a></h4>
<p>Controls the garbage collector.</p>
<pre><code class="language-lua">-- Force full collection
collectgarbage("collect")

-- Get memory usage in KB
const memKB: number = collectgarbage("count")

-- Stop garbage collection
collectgarbage("stop")

-- Restart garbage collection
collectgarbage("restart")
</code></pre>
<h2 id="string-module"><a class="header" href="#string-module">String Module</a></h2>
<h3 id="stringbytes-string-i-number-j-number-number"><a class="header" href="#stringbytes-string-i-number-j-number-number"><code>string.byte(s: string, i?: number, j?: number): ...number</code></a></h3>
<p>Returns byte values of characters.</p>
<pre><code class="language-lua">print(string.byte("ABC"))        -- 65 (A)
print(string.byte("ABC", 2))     -- 66 (B)
print(string.byte("ABC", 1, 3))  -- 65 66 67
</code></pre>
<h3 id="stringcharbytes-number-string"><a class="header" href="#stringcharbytes-number-string"><code>string.char(...bytes: number[]): string</code></a></h3>
<p>Converts bytes to a string.</p>
<pre><code class="language-lua">const s: string = string.char(65, 66, 67)  -- "ABC"
</code></pre>
<h3 id="stringfinds-string-pattern-string-init-number-plain-boolean-number--nil-number--nil-string"><a class="header" href="#stringfinds-string-pattern-string-init-number-plain-boolean-number--nil-number--nil-string"><code>string.find(s: string, pattern: string, init?: number, plain?: boolean): number | nil, number | nil, ...string</code></a></h3>
<p>Finds a pattern in a string.</p>
<pre><code class="language-lua">const start, end = string.find("hello world", "world")  -- 7, 11
const i, j = string.find("test", "x")  -- nil, nil (not found)

-- Plain search (no patterns)
const pos = string.find("a.b.c", ".", 1, true)  -- 2 (finds literal dot)
</code></pre>
<h3 id="stringformatformat-string-args-unknown-string"><a class="header" href="#stringformatformat-string-args-unknown-string"><code>string.format(format: string, ...args: unknown[]): string</code></a></h3>
<p>Formats a string (like C’s printf).</p>
<pre><code class="language-lua">const s: string = string.format("Hello, %s!", "World")  -- "Hello, World!"
const n: string = string.format("%d + %d = %d", 2, 3, 5)  -- "2 + 3 = 5"
const f: string = string.format("%.2f", 3.14159)  -- "3.14"
</code></pre>
<p><strong>Format specifiers:</strong> <code>%s</code> (string), <code>%d</code> (integer), <code>%f</code> (float), <code>%x</code> (hex), etc.</p>
<h3 id="stringgmatchs-string-pattern-string---string"><a class="header" href="#stringgmatchs-string-pattern-string---string"><code>string.gmatch(s: string, pattern: string): () =&gt; ...string</code></a></h3>
<p>Returns an iterator for pattern matches.</p>
<pre><code class="language-lua">const text = "one two three"

for word in string.gmatch(text, "%w+") do
    print(word)
end
-- Output: one, two, three
</code></pre>
<h3 id="stringgsubs-string-pattern-string-repl-string--table---string--string-n-number-string-number"><a class="header" href="#stringgsubs-string-pattern-string-repl-string--table---string--string-n-number-string-number"><code>string.gsub(s: string, pattern: string, repl: string | table | ((...: string) =&gt; string), n?: number): string, number</code></a></h3>
<p>Global substitution.</p>
<pre><code class="language-lua">-- String replacement
const result = string.gsub("hello world", "world", "Lua")  -- "hello Lua", 1

-- Function replacement
const result2 = string.gsub("1 2 3", "%d", function(n)
    return tostring(tonumber(n) * 2)
end)  -- "2 4 6", 3

-- Table replacement
const replacements = {hello = "hi", world = "Lua"}
const result3 = string.gsub("hello world", "%w+", replacements)  -- "hi Lua", 2
</code></pre>
<h3 id="stringlens-string-number"><a class="header" href="#stringlens-string-number"><code>string.len(s: string): number</code></a></h3>
<p>Returns string length in bytes.</p>
<pre><code class="language-lua">const length: number = string.len("hello")  -- 5
</code></pre>
<p><strong>Equivalent to <code>#s</code> operator.</strong></p>
<h3 id="stringlowers-string-string"><a class="header" href="#stringlowers-string-string"><code>string.lower(s: string): string</code></a></h3>
<p>Converts to lowercase.</p>
<pre><code class="language-lua">const lower: string = string.lower("Hello World")  -- "hello world"
</code></pre>
<h3 id="stringuppers-string-string"><a class="header" href="#stringuppers-string-string"><code>string.upper(s: string): string</code></a></h3>
<p>Converts to uppercase.</p>
<pre><code class="language-lua">const upper: string = string.upper("Hello World")  -- "HELLO WORLD"
</code></pre>
<h3 id="stringmatchs-string-pattern-string-init-number-string--nil"><a class="header" href="#stringmatchs-string-pattern-string-init-number-string--nil"><code>string.match(s: string, pattern: string, init?: number): ...string | nil</code></a></h3>
<p>Matches a pattern once.</p>
<pre><code class="language-lua">const match: string | nil = string.match("abc123def", "%d+")  -- "123"
const a, b, c = string.match("2024-01-15", "(%d+)-(%d+)-(%d+)")  -- "2024", "01", "15"
</code></pre>
<h3 id="stringreps-string-n-number-sep-string-string"><a class="header" href="#stringreps-string-n-number-sep-string-string"><code>string.rep(s: string, n: number, sep?: string): string</code></a></h3>
<p>Repeats a string n times.</p>
<pre><code class="language-lua">const repeated: string = string.rep("ab", 3)  -- "ababab"
const with_sep: string = string.rep("x", 3, "-")  -- "x-x-x"
</code></pre>
<h3 id="stringreverses-string-string"><a class="header" href="#stringreverses-string-string"><code>string.reverse(s: string): string</code></a></h3>
<p>Reverses a string.</p>
<pre><code class="language-lua">const reversed: string = string.reverse("hello")  -- "olleh"
</code></pre>
<h3 id="stringsubs-string-i-number-j-number-string"><a class="header" href="#stringsubs-string-i-number-j-number-string"><code>string.sub(s: string, i: number, j?: number): string</code></a></h3>
<p>Extracts a substring.</p>
<pre><code class="language-lua">const sub: string = string.sub("hello", 2, 4)  -- "ell"
const from_start: string = string.sub("hello", 1, 3)  -- "hel"
const to_end: string = string.sub("hello", 3)  -- "llo"
</code></pre>
<p><strong>Negative indices count from the end:</strong> <code>string.sub("hello", -3)</code> is <code>"llo"</code>.</p>
<h2 id="table-module"><a class="header" href="#table-module">Table Module</a></h2>
<h3 id="tableconcatlist-string-sep-string-i-number-j-number-string"><a class="header" href="#tableconcatlist-string-sep-string-i-number-j-number-string"><code>table.concat(list: string[], sep?: string, i?: number, j?: number): string</code></a></h3>
<p>Concatenates table elements into a string.</p>
<pre><code class="language-lua">const arr = {"a", "b", "c", "d"}
const str: string = table.concat(arr)           -- "abcd"
const csv: string = table.concat(arr, ", ")     -- "a, b, c, d"
const range: string = table.concat(arr, "-", 2, 3)  -- "b-c"
</code></pre>
<h3 id="tableinsertlist-t-pos-number-value-t-void"><a class="header" href="#tableinsertlist-t-pos-number-value-t-void"><code>table.insert(list: T[], pos?: number, value: T): void</code></a></h3>
<p>Inserts an element into a table.</p>
<pre><code class="language-lua">const arr: number[] = {1, 2, 3}

table.insert(arr, 4)      -- {1, 2, 3, 4} (append)
table.insert(arr, 2, 10)  -- {1, 10, 2, 3, 4} (insert at index 2)
</code></pre>
<h3 id="tableremovelist-t-pos-number-t--nil"><a class="header" href="#tableremovelist-t-pos-number-t--nil"><code>table.remove(list: T[], pos?: number): T | nil</code></a></h3>
<p>Removes and returns an element.</p>
<pre><code class="language-lua">const arr: number[] = {10, 20, 30, 40}

const last = table.remove(arr)     -- Returns 40, arr is {10, 20, 30}
const second = table.remove(arr, 2)  -- Returns 20, arr is {10, 30}
</code></pre>
<h3 id="tablesortlist-t-comp-a-t-b-t--boolean-void"><a class="header" href="#tablesortlist-t-comp-a-t-b-t--boolean-void"><code>table.sort(list: T[], comp?: (a: T, b: T) =&gt; boolean): void</code></a></h3>
<p>Sorts a table in-place.</p>
<pre><code class="language-lua">const arr: number[] = {3, 1, 4, 1, 5, 9, 2, 6}
table.sort(arr)  -- {1, 1, 2, 3, 4, 5, 6, 9}

-- Custom comparator (descending)
table.sort(arr, function(a, b) return a &gt; b end)  -- {9, 6, 5, 4, 3, 2, 1, 1}
</code></pre>
<h3 id="tablepackargs-t-n-number-number-t-lua-52"><a class="header" href="#tablepackargs-t-n-number-number-t-lua-52"><code>table.pack(...args: T[]): {n: number, [number]: T}</code> (Lua 5.2+)</a></h3>
<p>Packs arguments into a table with count.</p>
<pre><code class="language-lua">const packed = table.pack(1, 2, 3, 4, 5)
print(packed.n)     -- 5
print(packed[3])    -- 3
</code></pre>
<h3 id="tableunpacklist-t-i-number-j-number-t-lua-52"><a class="header" href="#tableunpacklist-t-i-number-j-number-t-lua-52"><code>table.unpack(list: T[], i?: number, j?: number): ...T</code> (Lua 5.2+)</a></h3>
<p>Unpacks a table into multiple values.</p>
<pre><code class="language-lua">const arr = {10, 20, 30}
const a, b, c = table.unpack(arr)  -- a=10, b=20, c=30
</code></pre>
<p><strong>In Lua 5.1:</strong> Use global <code>unpack()</code> function instead.</p>
<h3 id="tablemovea1-t-f-number-e-number-t-number-a2-t-t-lua-53"><a class="header" href="#tablemovea1-t-f-number-e-number-t-number-a2-t-t-lua-53"><code>table.move(a1: T[], f: number, e: number, t: number, a2?: T[]): T[]</code> (Lua 5.3+)</a></h3>
<p>Moves elements between tables.</p>
<pre><code class="language-lua">const src = {1, 2, 3, 4, 5}
const dst = {10, 20, 30}

table.move(src, 1, 3, 2, dst)  -- dst becomes {10, 1, 2, 3, 30}
</code></pre>
<h2 id="math-module"><a class="header" href="#math-module">Math Module</a></h2>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<ul>
<li><code>math.pi</code> — π (3.14159265358979…)</li>
<li><code>math.huge</code> — Infinity (positive)</li>
<li><code>math.maxinteger</code> (5.3+) — Maximum integer value</li>
<li><code>math.mininteger</code> (5.3+) — Minimum integer value</li>
</ul>
<h3 id="trigonometric"><a class="header" href="#trigonometric">Trigonometric</a></h3>
<pre><code class="language-lua">math.sin(x: number): number      -- Sine
math.cos(x: number): number      -- Cosine
math.tan(x: number): number      -- Tangent
math.asin(x: number): number     -- Arcsine
math.acos(x: number): number     -- Arccosine
math.atan(y: number, x?: number): number  -- Arctangent
math.sinh(x: number): number     -- Hyperbolic sine (5.3+)
math.cosh(x: number): number     -- Hyperbolic cosine (5.3+)
math.tanh(x: number): number     -- Hyperbolic tangent (5.3+)
math.deg(x: number): number      -- Radians to degrees
math.rad(x: number): number      -- Degrees to radians
</code></pre>
<h3 id="exponentiallogarithmic"><a class="header" href="#exponentiallogarithmic">Exponential/Logarithmic</a></h3>
<pre><code class="language-lua">math.exp(x: number): number      -- e^x
math.log(x: number, base?: number): number  -- Logarithm
math.sqrt(x: number): number     -- Square root
math.pow(x: number, y: number): number  -- x^y (deprecated, use ^)
</code></pre>
<h3 id="rounding"><a class="header" href="#rounding">Rounding</a></h3>
<pre><code class="language-lua">math.abs(x: number): number      -- Absolute value
math.ceil(x: number): number     -- Round up
math.floor(x: number): number    -- Round down
math.modf(x: number): number, number  -- Integer and fractional parts
</code></pre>
<h3 id="minmax"><a class="header" href="#minmax">Min/Max</a></h3>
<pre><code class="language-lua">math.max(...args: number[]): number  -- Maximum value
math.min(...args: number[]): number  -- Minimum value
</code></pre>
<h3 id="random"><a class="header" href="#random">Random</a></h3>
<pre><code class="language-lua">math.random(m?: number, n?: number): number  -- Random number
math.randomseed(x: number): void             -- Set random seed
</code></pre>
<p><strong>Usage:</strong></p>
<ul>
<li><code>math.random()</code> → Float in [0, 1)</li>
<li><code>math.random(n)</code> → Integer in [1, n]</li>
<li><code>math.random(m, n)</code> → Integer in [m, n]</li>
</ul>
<h3 id="integer-operations-lua-53"><a class="header" href="#integer-operations-lua-53">Integer Operations (Lua 5.3+)</a></h3>
<pre><code class="language-lua">math.tointeger(x: number): integer | nil  -- Convert to integer
math.type(x: number): "integer" | "float" | nil  -- Check number type
math.ult(m: integer, n: integer): boolean  -- Unsigned less than
</code></pre>
<h2 id="io-module"><a class="header" href="#io-module">IO Module</a></h2>
<h3 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h3>
<pre><code class="language-lua">io.open(filename: string, mode?: string): file | nil, string | nil
io.close(file?: file): boolean, string | nil
io.read(...formats: string[]): ...string | number | nil
io.write(...args: string[]): file | nil, string | nil
io.flush(): void
io.lines(filename?: string, ...formats: string[]): () =&gt; ...string | number | nil
io.input(file?: string | file): file
io.output(file?: string | file): file
io.tmpfile(): file
io.type(obj: unknown): "file" | "closed file" | nil
</code></pre>
<p><strong>File modes:</strong> <code>"r"</code> (read), <code>"w"</code> (write), <code>"a"</code> (append), <code>"r+"</code> (read/write), <code>"w+"</code>, <code>"a+"</code></p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-lua">const file = io.open("data.txt", "r")
if file ~= nil then
    const content = file:read("*all")
    file:close()
    print(content)
end
</code></pre>
<h2 id="os-module"><a class="header" href="#os-module">OS Module</a></h2>
<pre><code class="language-lua">os.clock(): number                  -- CPU time used
os.date(format?: string, time?: number): string | table  -- Format date/time
os.difftime(t2: number, t1: number): number  -- Time difference
os.execute(command?: string): boolean, string, number | nil  -- Execute shell command
os.exit(code?: number | boolean, close?: boolean): never  -- Exit program
os.getenv(varname: string): string | nil  -- Get environment variable
os.remove(filename: string): boolean, string | nil  -- Delete file
os.rename(oldname: string, newname: string): boolean, string | nil  -- Rename file
os.setlocale(locale: string | nil, category?: string): string | nil  -- Set locale
os.time(date?: table): number  -- Get time
os.tmpname(): string  -- Generate temp filename
</code></pre>
<h2 id="coroutine-module"><a class="header" href="#coroutine-module">Coroutine Module</a></h2>
<pre><code class="language-lua">coroutine.create(func: () =&gt; ...unknown): thread  -- Create coroutine
coroutine.resume(co: thread, ...args: unknown[]): boolean, ...unknown  -- Resume
coroutine.yield(...args: unknown[]): ...unknown  -- Yield
coroutine.status(co: thread): "running" | "suspended" | "normal" | "dead"  -- Status
coroutine.running(): thread | nil, boolean  -- Current coroutine
coroutine.wrap(func: () =&gt; ...unknown): (...args: unknown[]) =&gt; ...unknown  -- Wrap as function
coroutine.isyieldable(): boolean  -- Check if can yield (5.3+)
coroutine.close(co: thread): boolean, string | nil  -- Close coroutine (5.4+)
</code></pre>
<h2 id="version-specific-modules"><a class="header" href="#version-specific-modules">Version-Specific Modules</a></h2>
<h3 id="bit32-module-lua-52-53-only"><a class="header" href="#bit32-module-lua-52-53-only">bit32 Module (Lua 5.2-5.3 only)</a></h3>
<p>Bitwise operations library (deprecated in 5.3, use bitwise operators instead).</p>
<pre><code class="language-lua">bit32.band(...args: number[]): number  -- Bitwise AND
bit32.bor(...args: number[]): number   -- Bitwise OR
bit32.bxor(...args: number[]): number  -- Bitwise XOR
bit32.bnot(x: number): number          -- Bitwise NOT
bit32.lshift(x: number, disp: number): number  -- Left shift
bit32.rshift(x: number, disp: number): number  -- Right shift
bit32.arshift(x: number, disp: number): number  -- Arithmetic right shift
</code></pre>
<h3 id="utf8-module-lua-53"><a class="header" href="#utf8-module-lua-53">utf8 Module (Lua 5.3+)</a></h3>
<p>UTF-8 string handling.</p>
<pre><code class="language-lua">utf8.char(...codepoints: number[]): string  -- Codepoints to string
utf8.codes(s: string): () =&gt; number, number  -- Iterator over codepoints
utf8.codepoint(s: string, i?: number, j?: number): ...number  -- Extract codepoints
utf8.len(s: string, i?: number, j?: number): number | nil, number  -- UTF-8 length
utf8.offset(s: string, n: number, i?: number): number | nil  -- Byte offset of character
utf8.charpattern: string  -- Pattern matching single UTF-8 character
</code></pre>
<h2 id="see-also-17"><a class="header" href="#see-also-17">See Also</a></h2>
<ul>
<li><a href="#type-system">Type System</a> — Using standard library with types</li>
<li><a href="#modules">Modules</a> — Importing and using modules</li>
<li><a href="#targeting-different-lua-versions">Lua Targets</a> — Version-specific standard library features</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="utility-types-reference"><a class="header" href="#utility-types-reference">Utility Types Reference</a></h1>
<p>Complete reference for LuaNext’s built-in utility types. These types transform and manipulate other types.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>LuaNext provides 12 built-in utility types inspired by TypeScript:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Utility Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Partial&lt;T&gt;</code></td><td>Make all properties optional</td></tr>
<tr><td><code>Required&lt;T&gt;</code></td><td>Make all properties required</td></tr>
<tr><td><code>Readonly&lt;T&gt;</code></td><td>Make all properties readonly</td></tr>
<tr><td><code>Record&lt;K, T&gt;</code></td><td>Create object type with keys K and values T</td></tr>
<tr><td><code>Pick&lt;T, K&gt;</code></td><td>Select subset of properties</td></tr>
<tr><td><code>Omit&lt;T, K&gt;</code></td><td>Remove properties</td></tr>
<tr><td><code>Exclude&lt;T, U&gt;</code></td><td>Exclude types from union</td></tr>
<tr><td><code>Extract&lt;T, U&gt;</code></td><td>Extract types from union</td></tr>
<tr><td><code>NonNilable&lt;T&gt;</code></td><td>Remove nil from type</td></tr>
<tr><td><code>Nilable&lt;T&gt;</code></td><td>Add nil to type</td></tr>
<tr><td><code>ReturnType&lt;T&gt;</code></td><td>Extract function return type</td></tr>
<tr><td><code>Parameters&lt;T&gt;</code></td><td>Extract function parameter types</td></tr>
</tbody>
</table>
</div>
<h2 id="partial-1"><a class="header" href="#partial-1">Partial<t></t></a></h2>
<p>Makes all properties of <code>T</code> optional.</p>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<pre><code class="language-lua">type Partial&lt;T&gt; = {[K in keyof T]?: T[K]}
</code></pre>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-lua">interface User
    id: string
    name: string
    email: string
    age: number
end

type PartialUser = Partial&lt;User&gt;
-- Result:
-- {
--     id?: string,
--     name?: string,
--     email?: string,
--     age?: number
-- }

function updateUser(id: string, updates: PartialUser): void
    -- All fields are optional
    if updates.name ~= nil then
        setUserName(id, updates.name)
    end
    if updates.email ~= nil then
        setUserEmail(id, updates.email)
    end
end

updateUser("123", {name = "Alice"})  -- Only update name
updateUser("456", {email = "bob@example.com", age = 30})  -- Update multiple
</code></pre>
<h3 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h3>
<pre><code class="language-lua">-- Partial update functions
function patch&lt;T&gt;(original: T, updates: Partial&lt;T&gt;): T
    return {...original, ...updates}
end

-- Optional configuration
interface Config
    host: string
    port: number
    ssl: boolean
end

const defaultConfig: Config = {host = "localhost", port = 8080, ssl = false}

function createServer(options?: Partial&lt;Config&gt;): Server
    const config = {...defaultConfig, ...options}
    return Server.new(config)
end
</code></pre>
<h2 id="required-1"><a class="header" href="#required-1">Required<t></t></a></h2>
<p>Makes all properties of <code>T</code> required (removes optional modifiers).</p>
<h3 id="definition-1"><a class="header" href="#definition-1">Definition</a></h3>
<pre><code class="language-lua">type Required&lt;T&gt; = {[K in keyof T]-?: T[K]}
</code></pre>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre><code class="language-lua">interface PartialConfig
    host?: string
    port?: number
    ssl?: boolean
end

type Config = Required&lt;PartialConfig&gt;
-- Result:
-- {
--     host: string,
--     port: number,
--     ssl: boolean
-- }

function startServer(config: Config): void
    -- All fields guaranteed to exist
    print(`Server on ${config.host}:${config.port}`)
end

const partialConfig: PartialConfig = {host = "localhost"}
-- startServer(partialConfig)  -- ❌ Error: port and ssl missing

const fullConfig: Config = {host = "localhost", port = 8080, ssl = true}
startServer(fullConfig)  -- ✅ OK
</code></pre>
<h2 id="readonly-2"><a class="header" href="#readonly-2">Readonly<t></t></a></h2>
<p>Makes all properties of <code>T</code> readonly.</p>
<h3 id="definition-2"><a class="header" href="#definition-2">Definition</a></h3>
<pre><code class="language-lua">type Readonly&lt;T&gt; = {readonly [K in keyof T]: T[K]}
</code></pre>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<pre><code class="language-lua">interface Point
    x: number
    y: number
end

type ReadonlyPoint = Readonly&lt;Point&gt;
-- Result:
-- {
--     readonly x: number,
--     readonly y: number
-- }

const p: ReadonlyPoint = {x = 10, y = 20}
-- p.x = 15  -- ❌ Error: Cannot assign to readonly property

function movePoint(p: Point, dx: number, dy: number): ReadonlyPoint
    return {x = p.x + dx, y = p.y + dy}
end
</code></pre>
<h2 id="recordk-t-1"><a class="header" href="#recordk-t-1">Record&lt;K, T&gt;</a></h2>
<p>Creates an object type with keys <code>K</code> and values <code>T</code>.</p>
<h3 id="definition-3"><a class="header" href="#definition-3">Definition</a></h3>
<pre><code class="language-lua">type Record&lt;K extends string | number, T&gt; = {[P in K]: T}
</code></pre>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre><code class="language-lua">-- String keys
type StringMap = Record&lt;string, number&gt;
-- {[key: string]: number}

const counts: StringMap = {
    apples = 5,
    oranges = 3,
    bananas = 7
}

-- Literal union keys
type Status = "pending" | "active" | "completed"
type StatusRecord = Record&lt;Status, boolean&gt;
-- {
--     pending: boolean,
--     active: boolean,
--     completed: boolean
-- }

const statusFlags: StatusRecord = {
    pending = true,
    active = false,
    completed = false
}

-- Number keys
type Cache = Record&lt;number, string&gt;
const cache: Cache = {
    [1] = "one",
    [2] = "two",
    [3] = "three"
}
</code></pre>
<h2 id="pickt-k-1"><a class="header" href="#pickt-k-1">Pick&lt;T, K&gt;</a></h2>
<p>Selects a subset of properties from <code>T</code>.</p>
<h3 id="definition-4"><a class="header" href="#definition-4">Definition</a></h3>
<pre><code class="language-lua">type Pick&lt;T, K extends keyof T&gt; = {[P in K]: T[P]}
</code></pre>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre><code class="language-lua">interface User
    id: string
    name: string
    email: string
    age: number
    password: string
end

-- Pick only public fields
type UserPreview = Pick&lt;User, "id" | "name" | "email"&gt;
-- Result:
-- {
--     id: string,
--     name: string,
--     email: string
-- }

function getPublicProfile(user: User): UserPreview
    return {
        id = user.id,
        name = user.name,
        email = user.email
    }
end

-- Pick single field
type UserId = Pick&lt;User, "id"&gt;  -- {id: string}
</code></pre>
<h2 id="omitt-k-1"><a class="header" href="#omitt-k-1">Omit&lt;T, K&gt;</a></h2>
<p>Removes properties from <code>T</code>.</p>
<h3 id="definition-5"><a class="header" href="#definition-5">Definition</a></h3>
<pre><code class="language-lua">type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;
</code></pre>
<h3 id="usage-5"><a class="header" href="#usage-5">Usage</a></h3>
<pre><code class="language-lua">interface User
    id: string
    name: string
    email: string
    password: string
end

-- Omit sensitive fields
type PublicUser = Omit&lt;User, "password"&gt;
-- Result:
-- {
--     id: string,
--     name: string,
--     email: string
-- }

function sanitizeUser(user: User): PublicUser
    return {
        id = user.id,
        name = user.name,
        email = user.email
    }
end

-- Omit multiple fields
type UserWithoutMeta = Omit&lt;User, "id" | "password"&gt;
-- {name: string, email: string}
</code></pre>
<h2 id="excludet-u-1"><a class="header" href="#excludet-u-1">Exclude&lt;T, U&gt;</a></h2>
<p>Excludes types from a union.</p>
<h3 id="definition-6"><a class="header" href="#definition-6">Definition</a></h3>
<pre><code class="language-lua">type Exclude&lt;T, U&gt; = T extends U ? never : T
</code></pre>
<h3 id="usage-6"><a class="header" href="#usage-6">Usage</a></h3>
<pre><code class="language-lua">type All = "a" | "b" | "c" | "d"
type ExcludeAB = Exclude&lt;All, "a" | "b"&gt;
-- Result: "c" | "d"

type Primitive = string | number | boolean | nil
type NonNilPrimitive = Exclude&lt;Primitive, nil&gt;
-- Result: string | number | boolean

type Status = "pending" | "active" | "inactive" | "deleted"
type ActiveStatuses = Exclude&lt;Status, "deleted"&gt;
-- Result: "pending" | "active" | "inactive"
</code></pre>
<h2 id="extractt-u-1"><a class="header" href="#extractt-u-1">Extract&lt;T, U&gt;</a></h2>
<p>Extracts types from a union that are assignable to <code>U</code>.</p>
<h3 id="definition-7"><a class="header" href="#definition-7">Definition</a></h3>
<pre><code class="language-lua">type Extract&lt;T, U&gt; = T extends U ? T : never
</code></pre>
<h3 id="usage-7"><a class="header" href="#usage-7">Usage</a></h3>
<pre><code class="language-lua">type All = "a" | "b" | "c" | "d"
type ExtractAB = Extract&lt;All, "a" | "b" | "e"&gt;
-- Result: "a" | "b" (only types present in both)

type Mixed = string | number | boolean
type OnlyStrings = Extract&lt;Mixed, string&gt;
-- Result: string

type Status = "pending" | "active" | "completed" | "failed"
type CompletedStatuses = Extract&lt;Status, "completed" | "failed"&gt;
-- Result: "completed" | "failed"
</code></pre>
<h2 id="nonnilable-1"><a class="header" href="#nonnilable-1">NonNilable<t></t></a></h2>
<p>Removes <code>nil</code> from a type.</p>
<h3 id="definition-8"><a class="header" href="#definition-8">Definition</a></h3>
<pre><code class="language-lua">type NonNilable&lt;T&gt; = T extends nil ? never : T
</code></pre>
<h3 id="usage-8"><a class="header" href="#usage-8">Usage</a></h3>
<pre><code class="language-lua">type MaybeString = string | nil
type DefinitelyString = NonNilable&lt;MaybeString&gt;
-- Result: string

type Optional = number | string | nil
type Required = NonNilable&lt;Optional&gt;
-- Result: number | string

function requireValue&lt;T&gt;(value: T | nil): NonNilable&lt;T&gt;
    if value == nil then
        error("Value cannot be nil")
    end
    return value
end
</code></pre>
<h2 id="nilable-1"><a class="header" href="#nilable-1">Nilable<t></t></a></h2>
<p>Adds <code>nil</code> to a type.</p>
<h3 id="definition-9"><a class="header" href="#definition-9">Definition</a></h3>
<pre><code class="language-lua">type Nilable&lt;T&gt; = T | nil
</code></pre>
<h3 id="usage-9"><a class="header" href="#usage-9">Usage</a></h3>
<pre><code class="language-lua">type DefinitelyString = string
type MaybeString = Nilable&lt;DefinitelyString&gt;
-- Result: string | nil

function findUser(id: string): Nilable&lt;User&gt;
    return users[id]  -- May return nil
end

const user: Nilable&lt;User&gt; = findUser("123")
if user ~= nil then
    print(user.name)
end
</code></pre>
<h2 id="returntype-1"><a class="header" href="#returntype-1">ReturnType<t></t></a></h2>
<p>Extracts the return type of a function.</p>
<h3 id="definition-10"><a class="header" href="#definition-10">Definition</a></h3>
<pre><code class="language-lua">type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : never
</code></pre>
<h3 id="usage-10"><a class="header" href="#usage-10">Usage</a></h3>
<pre><code class="language-lua">function getUser(): {name: string, age: number}
    return {name = "Alice", age = 30}
end

type User = ReturnType&lt;typeof getUser&gt;
-- Result: {name: string, age: number}

function calculate(a: number, b: number): number
    return a + b
end

type CalculateResult = ReturnType&lt;typeof calculate&gt;
-- Result: number

-- With type alias
type FetchData = () =&gt; {id: string, value: number}
type Data = ReturnType&lt;FetchData&gt;
-- Result: {id: string, value: number}
</code></pre>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters<t></t></a></h2>
<p>Extracts the parameter types of a function as a tuple.</p>
<h3 id="definition-11"><a class="header" href="#definition-11">Definition</a></h3>
<pre><code class="language-lua">type Parameters&lt;T&gt; = T extends (...args: infer P) =&gt; any ? P : never
</code></pre>
<h3 id="usage-11"><a class="header" href="#usage-11">Usage</a></h3>
<pre><code class="language-lua">function add(a: number, b: number): number
    return a + b
end

type AddParams = Parameters&lt;typeof add&gt;
-- Result: [number, number]

function greet(name: string, greeting?: string): void
    print((greeting or "Hello") .. ", " .. name)
end

type GreetParams = Parameters&lt;typeof greet&gt;
-- Result: [string, string | nil]

-- Extract individual parameters
type FirstParam = AddParams[1]  -- number
type SecondParam = AddParams[2]  -- number
</code></pre>
<h2 id="advanced-combinations"><a class="header" href="#advanced-combinations">Advanced Combinations</a></h2>
<h3 id="deep-partial-1"><a class="header" href="#deep-partial-1">Deep Partial</a></h3>
<p>Make all nested properties optional:</p>
<pre><code class="language-lua">type DeepPartial&lt;T&gt; = {
    [K in keyof T]?: T[K] extends object ? DeepPartial&lt;T[K]&gt; : T[K]
}

interface Config
    database: {
        host: string
        port: number
    }
    cache: {
        enabled: boolean
        ttl: number
    }
end

type PartialConfig = DeepPartial&lt;Config&gt;
-- All nested properties are optional
const config: PartialConfig = {
    database = {host = "localhost"}  -- port optional
}
</code></pre>
<h3 id="deep-readonly-1"><a class="header" href="#deep-readonly-1">Deep Readonly</a></h3>
<p>Make all nested properties readonly:</p>
<pre><code class="language-lua">type DeepReadonly&lt;T&gt; = {
    readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K]
}
</code></pre>
<h3 id="mutable-remove-readonly-1"><a class="header" href="#mutable-remove-readonly-1">Mutable (Remove Readonly)</a></h3>
<p>Remove readonly modifiers:</p>
<pre><code class="language-lua">type Mutable&lt;T&gt; = {
    -readonly [K in keyof T]: T[K]
}

interface ReadonlyUser
    readonly id: string
    readonly name: string
end

type MutableUser = Mutable&lt;ReadonlyUser&gt;
-- {id: string, name: string}
</code></pre>
<h3 id="nullable-add-nil-to-all-properties"><a class="header" href="#nullable-add-nil-to-all-properties">Nullable (Add nil to all properties)</a></h3>
<pre><code class="language-lua">type Nullable&lt;T&gt; = {
    [K in keyof T]: T[K] | nil
}

interface User
    name: string
    age: number
end

type NullableUser = Nullable&lt;User&gt;
-- {name: string | nil, age: number | nil}
</code></pre>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="api-response-types"><a class="header" href="#api-response-types">API Response Types</a></h3>
<pre><code class="language-lua">interface ApiResponse&lt;T&gt;
    data: T
    status: number
    error?: string
end

type UserResponse = ApiResponse&lt;User&gt;
type UsersResponse = ApiResponse&lt;User[]&gt;
type PartialUserResponse = ApiResponse&lt;Partial&lt;User&gt;&gt;
</code></pre>
<h3 id="form-state"><a class="header" href="#form-state">Form State</a></h3>
<pre><code class="language-lua">interface FormState&lt;T&gt;
    values: T
    errors: Partial&lt;Record&lt;keyof T, string&gt;&gt;
    touched: Partial&lt;Record&lt;keyof T, boolean&gt;&gt;
end

interface LoginForm
    email: string
    password: string
end

type LoginFormState = FormState&lt;LoginForm&gt;
</code></pre>
<h3 id="configuration-builder"><a class="header" href="#configuration-builder">Configuration Builder</a></h3>
<pre><code class="language-lua">interface FullConfig
    host: string
    port: number
    ssl: boolean
    timeout: number
end

const defaults: FullConfig = {
    host = "localhost",
    port = 8080,
    ssl = false,
    timeout = 5000
}

function buildConfig(options: Partial&lt;FullConfig&gt;): Required&lt;FullConfig&gt;
    return {...defaults, ...options}
end
</code></pre>
<h2 id="see-also-18"><a class="header" href="#see-also-18">See Also</a></h2>
<ul>
<li><a href="#advanced-types">Advanced Types</a> — Detailed explanations and examples</li>
<li><a href="#type-system">Type System</a> — Core type system features</li>
<li><a href="#generics-1">Generics</a> — Generic type parameters</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="reflection-api-reference"><a class="header" href="#reflection-api-reference">Reflection API Reference</a></h1>
<p>Runtime reflection utilities for inspecting types, classes, and metadata in LuaNext.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>LuaNext provides a reflection API for runtime type inspection, primarily used with classes and decorators. The <code>Reflect</code> namespace offers functions to query type information, fields, methods, and metadata.</p>
<p><strong>Key features:</strong></p>
<ul>
<li>Runtime type checking</li>
<li>Field and method inspection</li>
<li>Metadata access (from decorators)</li>
<li>Instance checking</li>
</ul>
<h2 id="reflection-modes"><a class="header" href="#reflection-modes">Reflection Modes</a></h2>
<p>Configure reflection metadata generation in <code>luanext.config.yaml</code>:</p>
<pre><code class="language-yaml">compilerOptions:
  reflection: "selective"  # Default: metadata for decorated items only
  # OR
  reflection: "full"       # Metadata for all types and functions
  # OR
  reflection: "none"       # No reflection metadata
</code></pre>
<p><strong>Modes:</strong></p>
<ul>
<li><code>selective</code> — Include metadata only for items with decorators (minimal overhead)</li>
<li><code>full</code> — Include metadata for all types, classes, functions (complete introspection)</li>
<li><code>none</code> — No metadata (smallest bundle size, reflection APIs return nil)</li>
</ul>
<h2 id="reflect-namespace"><a class="header" href="#reflect-namespace">Reflect Namespace</a></h2>
<h3 id="reflectgettypeobj-unknown-string--nil"><a class="header" href="#reflectgettypeobj-unknown-string--nil"><code>Reflect.getType(obj: unknown): string | nil</code></a></h3>
<p>Returns the LuaNext type name of an object.</p>
<pre><code class="language-lua">import {Reflect} from "luanext:reflect"

class User
    name: string
    age: number
end

const user = User.new()
const typeName = Reflect.getType(user)  -- "User"

print(typeName)  -- "User"
</code></pre>
<p><strong>Returns:</strong></p>
<ul>
<li>Type name (e.g., <code>"User"</code>, <code>"Vector"</code>)</li>
<li><code>nil</code> if object has no reflection metadata</li>
</ul>
<h3 id="reflectgetfieldsobj-unknown-string-fieldinfo--nil"><a class="header" href="#reflectgetfieldsobj-unknown-string-fieldinfo--nil"><code>Reflect.getFields(obj: unknown): {[string]: FieldInfo} | nil</code></a></h3>
<p>Returns all fields (including inherited) of an object.</p>
<pre><code class="language-lua">interface FieldInfo
    name: string
    type: string
    readonly: boolean
    visibility: "public" | "private" | "protected"
end

const user = User.new()
const fields = Reflect.getFields(user)

if fields ~= nil then
    for name, info in pairs(fields) do
        print(`${name}: ${info.type} (${info.visibility})`)
    end
end
-- Output:
-- name: string (public)
-- age: number (public)
</code></pre>
<p><strong>Includes inherited fields from parent classes.</strong></p>
<h3 id="reflectgetownfieldsobj-unknown-string-fieldinfo--nil"><a class="header" href="#reflectgetownfieldsobj-unknown-string-fieldinfo--nil"><code>Reflect.getOwnFields(obj: unknown): {[string]: FieldInfo} | nil</code></a></h3>
<p>Returns only fields defined directly on the object’s class (excluding inherited).</p>
<pre><code class="language-lua">class Animal
    name: string
end

class Dog extends Animal
    breed: string
end

const dog = Dog.new()

const allFields = Reflect.getFields(dog)      -- {name, breed}
const ownFields = Reflect.getOwnFields(dog)   -- {breed} only
</code></pre>
<h3 id="reflectgetmethodsobj-unknown-string-methodinfo--nil"><a class="header" href="#reflectgetmethodsobj-unknown-string-methodinfo--nil"><code>Reflect.getMethods(obj: unknown): {[string]: MethodInfo} | nil</code></a></h3>
<p>Returns all methods (including inherited) of an object.</p>
<pre><code class="language-lua">interface MethodInfo
    name: string
    parameters: ParameterInfo[]
    returnType: string
    visibility: "public" | "private" | "protected"
end

interface ParameterInfo
    name: string
    type: string
    optional: boolean
end

const user = User.new()
const methods = Reflect.getMethods(user)

if methods ~= nil then
    for name, info in pairs(methods) do
        print(`${name}: (${formatParams(info.parameters)}) =&gt; ${info.returnType}`)
    end
end
</code></pre>
<h3 id="reflectgetownmethodsobj-unknown-string-methodinfo--nil"><a class="header" href="#reflectgetownmethodsobj-unknown-string-methodinfo--nil"><code>Reflect.getOwnMethods(obj: unknown): {[string]: MethodInfo} | nil</code></a></h3>
<p>Returns only methods defined directly on the object’s class (excluding inherited).</p>
<pre><code class="language-lua">class Animal
    function speak(): void end
end

class Dog extends Animal
    function bark(): void end
end

const dog = Dog.new()

const allMethods = Reflect.getMethods(dog)      -- {speak, bark}
const ownMethods = Reflect.getOwnMethods(dog)   -- {bark} only
</code></pre>
<h3 id="reflectisinstanceobj-unknown-classref-unknown-boolean"><a class="header" href="#reflectisinstanceobj-unknown-classref-unknown-boolean"><code>Reflect.isInstance(obj: unknown, classRef: unknown): boolean</code></a></h3>
<p>Checks if an object is an instance of a class.</p>
<pre><code class="language-lua">class Animal end
class Dog extends Animal end
class Cat extends Animal end

const dog = Dog.new()

print(Reflect.isInstance(dog, Dog))     -- true
print(Reflect.isInstance(dog, Animal))  -- true (parent class)
print(Reflect.isInstance(dog, Cat))     -- false
</code></pre>
<p><strong>More precise than <code>instanceof</code> operator</strong> when working with dynamic types.</p>
<h2 id="decorator-metadata-1"><a class="header" href="#decorator-metadata-1">Decorator Metadata</a></h2>
<p>Decorators can store metadata accessible via reflection.</p>
<h3 id="storing-metadata"><a class="header" href="#storing-metadata">Storing Metadata</a></h3>
<pre><code class="language-lua">function metadata(key: string, value: any): (target: any, propertyKey: string) =&gt; void
    return function(target, propertyKey)
        target.__metadata = target.__metadata or {}
        target.__metadata[propertyKey] = target.__metadata[propertyKey] or {}
        target.__metadata[propertyKey][key] = value
    end
end

class User
    @metadata("required", true)
    @metadata("minLength", 3)
    name: string

    @metadata("required", true)
    @metadata("min", 18)
    age: number
end
</code></pre>
<h3 id="accessing-metadata"><a class="header" href="#accessing-metadata">Accessing Metadata</a></h3>
<pre><code class="language-lua">function validate(obj: User): boolean
    const fields = Reflect.getFields(obj)

    if fields ~= nil then
        for fieldName, fieldInfo in pairs(fields) do
            const meta = User.__metadata[fieldName]

            if meta ~= nil then
                if meta.required and obj[fieldName] == nil then
                    error(`Field ${fieldName} is required`)
                end

                if meta.minLength ~= nil and #obj[fieldName] &lt; meta.minLength then
                    error(`Field ${fieldName} must be at least ${meta.minLength} characters`)
                end
            end
        end
    end

    return true
end

const user = User.new()
user.name = "AB"  -- Too short
validate(user)    -- Error: Field name must be at least 3 characters
</code></pre>
<h2 id="practical-examples-1"><a class="header" href="#practical-examples-1">Practical Examples</a></h2>
<h3 id="serialization"><a class="header" href="#serialization">Serialization</a></h3>
<pre><code class="language-lua">function serialize(obj: unknown): string
    const typeName = Reflect.getType(obj)

    if typeName == nil then
        return tostring(obj)
    end

    const fields = Reflect.getFields(obj)
    if fields == nil then
        return tostring(obj)
    end

    const parts: string[] = {`{type="${typeName}"`}

    for name, info in pairs(fields) do
        const value = obj[name]
        table.insert(parts, `${name}=${serializeValue(value)}`)
    end

    return table.concat(parts, ", ") .. "}"
end
</code></pre>
<h3 id="validation-framework"><a class="header" href="#validation-framework">Validation Framework</a></h3>
<pre><code class="language-lua">function validateObject&lt;T&gt;(obj: T): ValidationResult
    const errors: string[] = {}
    const fields = Reflect.getFields(obj)

    if fields ~= nil then
        for name, info in pairs(fields) do
            -- Check required fields
            if info.required and obj[name] == nil then
                table.insert(errors, `${name} is required`)
            end

            -- Type validation
            const actualType = type(obj[name])
            if not isTypeCompatible(actualType, info.type) then
                table.insert(errors, `${name} has wrong type: expected ${info.type}, got ${actualType}`)
            end
        end
    end

    return {valid = #errors == 0, errors = errors}
end
</code></pre>
<h3 id="dependency-injection"><a class="header" href="#dependency-injection">Dependency Injection</a></h3>
<pre><code class="language-lua">function inject(container: Container, target: any): void
    const fields = Reflect.getFields(target)

    if fields ~= nil then
        for name, info in pairs(fields) do
            const meta = target.__metadata?[name]

            if meta?.inject == true then
                const dependency = container:resolve(info.type)
                if dependency ~= nil then
                    target[name] = dependency
                end
            end
        end
    end
end

@injectable
class UserService
    @inject
    database: Database

    @inject
    logger: Logger
end

const service = UserService.new()
inject(container, service)  -- Auto-injects dependencies
</code></pre>
<h3 id="auto-mapping"><a class="header" href="#auto-mapping">Auto-mapping</a></h3>
<pre><code class="language-lua">function mapTo&lt;T&gt;(source: any, targetClass: any): T
    const target = targetClass.new()
    const sourceFields = Reflect.getFields(source)
    const targetFields = Reflect.getFields(target)

    if sourceFields ~= nil and targetFields ~= nil then
        for name, sourceInfo in pairs(sourceFields) do
            const targetInfo = targetFields[name]

            if targetInfo ~= nil and sourceInfo.type == targetInfo.type then
                target[name] = source[name]
            end
        end
    end

    return target
end

const dto = UserDTO.new()
dto.name = "Alice"
dto.email = "alice@example.com"

const entity: User = mapTo(dto, User)
</code></pre>
<h2 id="performance-considerations-3"><a class="header" href="#performance-considerations-3">Performance Considerations</a></h2>
<h3 id="reflection-overhead"><a class="header" href="#reflection-overhead">Reflection Overhead</a></h3>
<p><strong>Metadata storage:</strong></p>
<ul>
<li><code>selective</code> mode — Minimal (only decorated items)</li>
<li><code>full</code> mode — Moderate (all types)</li>
<li><code>none</code> mode — Zero (no metadata)</li>
</ul>
<p><strong>Runtime cost:</strong></p>
<ul>
<li>Reflection calls involve table lookups</li>
<li>Use caching for frequently accessed metadata</li>
<li>Avoid reflection in hot paths</li>
</ul>
<h3 id="optimization-tips"><a class="header" href="#optimization-tips">Optimization Tips</a></h3>
<pre><code class="language-lua">-- ✅ Good: Cache metadata
const fieldsCache = {}

function getCachedFields(obj: unknown): any
    const typeName = Reflect.getType(obj)

    if typeName == nil then
        return nil
    end

    if fieldsCache[typeName] == nil then
        fieldsCache[typeName] = Reflect.getFields(obj)
    end

    return fieldsCache[typeName]
end

-- ❌ Bad: Repeated reflection in loop
for i = 1, 10000 do
    const fields = Reflect.getFields(obj)  -- Called 10000 times!
end
</code></pre>
<h3 id="bundle-size-impact"><a class="header" href="#bundle-size-impact">Bundle Size Impact</a></h3>
<p><strong>Reflection mode comparison:</strong></p>
<pre><code>none:      100 KB (baseline)
selective: 105 KB (+5%, metadata for decorated items only)
full:      130 KB (+30%, metadata for all types)
</code></pre>
<p><strong>Recommendation:</strong> Use <code>selective</code> mode unless you need full introspection.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ol>
<li><strong>Primitive types</strong> — No reflection metadata for <code>number</code>, <code>string</code>, <code>boolean</code>, etc.</li>
<li><strong>External types</strong> — No reflection for plain Lua tables or external C types</li>
<li><strong>Private access</strong> — Reflection respects visibility modifiers in generated code</li>
<li><strong>Dynamic types</strong> — Reflection works on compiled types, not runtime <code>any</code>/<code>unknown</code></li>
</ol>
<h2 id="type-guards-with-reflection"><a class="header" href="#type-guards-with-reflection">Type Guards with Reflection</a></h2>
<p>Combine reflection with type guards:</p>
<pre><code class="language-lua">function isUser(obj: unknown): obj is User
    const typeName = Reflect.getType(obj)
    return typeName == "User"
end

function processValue(value: unknown): void
    if isUser(value) then
        -- value is User here
        print(value.name)
    end
end
</code></pre>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<p>Enable reflection debugging:</p>
<pre><code class="language-bash">RUST_LOG=debug luanext main.luax
</code></pre>
<p>Check generated metadata:</p>
<pre><code class="language-lua">-- Inspect raw metadata
const user = User.new()
print(user.__metadata)       -- Decorator metadata
print(user.__type)           -- Type name
print(user.__fields)         -- Field definitions
</code></pre>
<h2 id="see-also-19"><a class="header" href="#see-also-19">See Also</a></h2>
<ul>
<li><a href="#decorators">Decorators</a> — Using decorators with reflection</li>
<li><a href="#classes">Classes</a> — Class definitions</li>
<li><a href="#configuration-reference">Configuration</a> — Setting reflection mode</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-codes-reference"><a class="header" href="#error-codes-reference">Error Codes Reference</a></h1>
<p>Complete reference for LuaNext compiler error codes and diagnostics.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>LuaNext error codes follow the format <code>E####</code> where <code>####</code> is a four-digit number. Errors are categorized by type.</p>
<p>Enable error codes in output:</p>
<pre><code class="language-bash">luanext --diagnostics main.luax
</code></pre>
<p>Or in configuration:</p>
<pre><code class="language-yaml">compilerOptions:
  diagnostics: true
</code></pre>
<h2 id="type-errors-e0001-e0999"><a class="header" href="#type-errors-e0001-e0999">Type Errors (E0001-E0999)</a></h2>
<h3 id="e0001-type-mismatch"><a class="header" href="#e0001-type-mismatch">E0001: Type Mismatch</a></h3>
<p><strong>Description:</strong> Expected one type, found another.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">const x: number = "hello"  -- E0001: Type mismatch
</code></pre>
<p><strong>Fix:</strong> Ensure types match or use type assertion:</p>
<pre><code class="language-lua">const x: number = 42  -- ✅ OK
const y = "hello" as unknown as number  -- Type assertion (use with caution)
</code></pre>
<h3 id="e0002-undefined-variable"><a class="header" href="#e0002-undefined-variable">E0002: Undefined Variable</a></h3>
<p><strong>Description:</strong> Variable used before declaration.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">print(x)  -- E0002: Undefined variable 'x'
const x = 5
</code></pre>
<p><strong>Fix:</strong> Declare before use:</p>
<pre><code class="language-lua">const x = 5
print(x)  -- ✅ OK
</code></pre>
<h3 id="e0003-cannot-assign-to-const"><a class="header" href="#e0003-cannot-assign-to-const">E0003: Cannot Assign to Const</a></h3>
<p><strong>Description:</strong> Attempting to reassign an immutable variable.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">const PI = 3.14
PI = 3  -- E0003: Cannot assign to const variable
</code></pre>
<p><strong>Fix:</strong> Use <code>local</code> for mutable variables:</p>
<pre><code class="language-lua">local count = 0
count = 5  -- ✅ OK
</code></pre>
<h3 id="e0004-null-reference"><a class="header" href="#e0004-null-reference">E0004: Null Reference</a></h3>
<p><strong>Description:</strong> Possible nil access without check (strict null checks enabled).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">function findUser(id: string): User | nil
    return users[id]
end

const user = findUser("123")
print(user.name)  -- E0004: Possible nil reference
</code></pre>
<p><strong>Fix:</strong> Check for nil first:</p>
<pre><code class="language-lua">const user = findUser("123")
if user ~= nil then
    print(user.name)  -- ✅ OK
end
</code></pre>
<h3 id="e0005-property-does-not-exist"><a class="header" href="#e0005-property-does-not-exist">E0005: Property Does Not Exist</a></h3>
<p><strong>Description:</strong> Accessing non-existent property on a type.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">interface User
    name: string
end

const user: User = {name = "Alice"}
print(user.age)  -- E0005: Property 'age' does not exist on type 'User'
</code></pre>
<p><strong>Fix:</strong> Add property to interface or check existence:</p>
<pre><code class="language-lua">interface User
    name: string
    age?: number  -- Optional property
end
</code></pre>
<h2 id="function-errors-e1000-e1999"><a class="header" href="#function-errors-e1000-e1999">Function Errors (E1000-E1999)</a></h2>
<h3 id="e1001-argument-count-mismatch"><a class="header" href="#e1001-argument-count-mismatch">E1001: Argument Count Mismatch</a></h3>
<p><strong>Description:</strong> Wrong number of arguments passed to function.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">function add(a: number, b: number): number
    return a + b
end

add(5)  -- E1001: Expected 2 arguments, got 1
</code></pre>
<p><strong>Fix:</strong> Provide correct number of arguments:</p>
<pre><code class="language-lua">add(5, 3)  -- ✅ OK
</code></pre>
<h3 id="e1002-invalid-return-type"><a class="header" href="#e1002-invalid-return-type">E1002: Invalid Return Type</a></h3>
<p><strong>Description:</strong> Function returns wrong type.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">function getName(): string
    return 42  -- E1002: Cannot return number from function returning string
end
</code></pre>
<p><strong>Fix:</strong> Return correct type:</p>
<pre><code class="language-lua">function getName(): string
    return "Alice"  -- ✅ OK
end
</code></pre>
<h3 id="e1003-missing-return-statement"><a class="header" href="#e1003-missing-return-statement">E1003: Missing Return Statement</a></h3>
<p><strong>Description:</strong> Function with non-void return type doesn’t always return.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">function divide(a: number, b: number): number
    if b ~= 0 then
        return a / b
    end
    -- E1003: Not all code paths return a value
end
</code></pre>
<p><strong>Fix:</strong> Ensure all paths return:</p>
<pre><code class="language-lua">function divide(a: number, b: number): number
    if b ~= 0 then
        return a / b
    end
    return 0  -- ✅ OK
end
</code></pre>
<h2 id="class-errors-e2000-e2999"><a class="header" href="#class-errors-e2000-e2999">Class Errors (E2000-E2999)</a></h2>
<h3 id="e2001-cannot-extend-sealed-class"><a class="header" href="#e2001-cannot-extend-sealed-class">E2001: Cannot Extend Sealed Class</a></h3>
<p><strong>Description:</strong> Attempting to extend a class marked as sealed.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">@sealed
class FinalClass end

class Derived extends FinalClass end  -- E2001: Cannot extend sealed class
</code></pre>
<p><strong>Fix:</strong> Don’t extend sealed classes or remove <code>@sealed</code>.</p>
<h3 id="e2002-property-already-declared"><a class="header" href="#e2002-property-already-declared">E2002: Property Already Declared</a></h3>
<p><strong>Description:</strong> Duplicate property in class.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">class User
    name: string
    name: string  -- E2002: Property 'name' already declared
end
</code></pre>
<p><strong>Fix:</strong> Remove duplicate:</p>
<pre><code class="language-lua">class User
    name: string  -- ✅ OK
end
</code></pre>
<h3 id="e2003-must-override"><a class="header" href="#e2003-must-override">E2003: Must Override</a></h3>
<p><strong>Description:</strong> Abstract method not implemented.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">abstract class Animal
    abstract function speak(): void
end

class Dog extends Animal end  -- E2003: Must override abstract method 'speak'
</code></pre>
<p><strong>Fix:</strong> Implement abstract methods:</p>
<pre><code class="language-lua">class Dog extends Animal
    override function speak(): void
        print("Woof!")
    end
end
</code></pre>
<h2 id="module-errors-e3000-e3999"><a class="header" href="#module-errors-e3000-e3999">Module Errors (E3000-E3999)</a></h2>
<h3 id="e3001-module-not-found"><a class="header" href="#e3001-module-not-found">E3001: Module Not Found</a></h3>
<p><strong>Description:</strong> Cannot find imported module.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">import {helper} from "./missing"  -- E3001: Module './missing' not found
</code></pre>
<p><strong>Fix:</strong> Check file path and ensure file exists:</p>
<pre><code class="language-lua">import {helper} from "./utils"  -- ✅ OK (if utils.luax exists)
</code></pre>
<h3 id="e3002-circular-dependency"><a class="header" href="#e3002-circular-dependency">E3002: Circular Dependency</a></h3>
<p><strong>Description:</strong> Modules import each other, creating a cycle.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">-- a.luax
import {b} from "./b"

-- b.luax
import {a} from "./a"  -- E3002: Circular dependency detected
</code></pre>
<p><strong>Fix:</strong> Refactor to break cycle:</p>
<pre><code class="language-lua">-- Create shared.luax with common code
-- a.luax imports shared
-- b.luax imports shared
</code></pre>
<h3 id="e3003-export-not-found"><a class="header" href="#e3003-export-not-found">E3003: Export Not Found</a></h3>
<p><strong>Description:</strong> Trying to import non-existent export.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">-- utils.luax
export function add(a: number, b: number): number
    return a + b
end

-- main.luax
import {multiply} from "./utils"  -- E3003: Export 'multiply' not found
</code></pre>
<p><strong>Fix:</strong> Import existing exports:</p>
<pre><code class="language-lua">import {add} from "./utils"  -- ✅ OK
</code></pre>
<h2 id="generic-errors-e4000-e4999"><a class="header" href="#generic-errors-e4000-e4999">Generic Errors (E4000-E4999)</a></h2>
<h3 id="e4001-type-argument-mismatch"><a class="header" href="#e4001-type-argument-mismatch">E4001: Type Argument Mismatch</a></h3>
<p><strong>Description:</strong> Wrong type arguments for generic.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">type Box&lt;T extends number&gt; = {value: T}

type StringBox = Box&lt;string&gt;  -- E4001: string doesn't satisfy constraint 'extends number'
</code></pre>
<p><strong>Fix:</strong> Use compatible type:</p>
<pre><code class="language-lua">type NumberBox = Box&lt;number&gt;  -- ✅ OK
</code></pre>
<h3 id="e4002-cannot-infer-type-argument"><a class="header" href="#e4002-cannot-infer-type-argument">E4002: Cannot Infer Type Argument</a></h3>
<p><strong>Description:</strong> Generic type argument cannot be inferred.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">function identity&lt;T&gt;(x: T): T
    return x
end

const result = identity()  -- E4002: Cannot infer type argument for T
</code></pre>
<p><strong>Fix:</strong> Provide explicit type or argument:</p>
<pre><code class="language-lua">const result = identity&lt;number&gt;(42)  -- ✅ OK
const result2 = identity(42)  -- ✅ OK (infers number)
</code></pre>
<h2 id="pattern-matching-errors-e5000-e5999"><a class="header" href="#pattern-matching-errors-e5000-e5999">Pattern Matching Errors (E5000-E5999)</a></h2>
<h3 id="e5001-non-exhaustive-match"><a class="header" href="#e5001-non-exhaustive-match">E5001: Non-Exhaustive Match</a></h3>
<p><strong>Description:</strong> Match expression doesn’t handle all cases.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">enum Status { Pending, Active, Completed }

function handle(status: Status): string
    return match status
        | Status.Pending -&gt; "waiting"
        | Status.Active -&gt; "processing"
        -- E5001: Non-exhaustive match, missing Status.Completed
    end
end
</code></pre>
<p><strong>Fix:</strong> Handle all cases or add wildcard:</p>
<pre><code class="language-lua">function handle(status: Status): string
    return match status
        | Status.Pending -&gt; "waiting"
        | Status.Active -&gt; "processing"
        | Status.Completed -&gt; "done"  -- ✅ OK
    end
end
</code></pre>
<h3 id="e5002-unreachable-pattern"><a class="header" href="#e5002-unreachable-pattern">E5002: Unreachable Pattern</a></h3>
<p><strong>Description:</strong> Pattern will never be matched.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">match x
    | _ -&gt; "any"
    | 42 -&gt; "forty-two"  -- E5002: Unreachable pattern
end
</code></pre>
<p><strong>Fix:</strong> Reorder patterns (specific before general):</p>
<pre><code class="language-lua">match x
    | 42 -&gt; "forty-two"
    | _ -&gt; "any"  -- ✅ OK
end
</code></pre>
<h2 id="decorator-errors-e6000-e6999"><a class="header" href="#decorator-errors-e6000-e6999">Decorator Errors (E6000-E6999)</a></h2>
<h3 id="e6001-invalid-decorator-target"><a class="header" href="#e6001-invalid-decorator-target">E6001: Invalid Decorator Target</a></h3>
<p><strong>Description:</strong> Decorator applied to invalid target.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">@decorator
const x = 5  -- E6001: Cannot apply decorator to const variable
</code></pre>
<p><strong>Fix:</strong> Apply decorators to valid targets (classes, methods, properties):</p>
<pre><code class="language-lua">class User
    @decorator
    name: string  -- ✅ OK
end
</code></pre>
<h2 id="naming-convention-errors-e7000-e7999"><a class="header" href="#naming-convention-errors-e7000-e7999">Naming Convention Errors (E7000-E7999)</a></h2>
<h3 id="e7001-invalid-constant-name"><a class="header" href="#e7001-invalid-constant-name">E7001: Invalid Constant Name</a></h3>
<p><strong>Description:</strong> Const doesn’t follow UPPER_SNAKE_CASE.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">const maxSize = 100  -- E7001: Const 'maxSize' should be UPPER_SNAKE_CASE
</code></pre>
<p><strong>Fix:</strong> Use correct naming:</p>
<pre><code class="language-lua">const MAX_SIZE = 100  -- ✅ OK
</code></pre>
<h3 id="e7002-invalid-type-name"><a class="header" href="#e7002-invalid-type-name">E7002: Invalid Type Name</a></h3>
<p><strong>Description:</strong> Type/interface doesn’t follow PascalCase.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">interface user_data end  -- E7002: Type 'user_data' should be PascalCase
</code></pre>
<p><strong>Fix:</strong> Use PascalCase:</p>
<pre><code class="language-lua">interface UserData end  -- ✅ OK
</code></pre>
<h2 id="error-severity-levels"><a class="header" href="#error-severity-levels">Error Severity Levels</a></h2>
<p>Errors have different severity levels:</p>
<ul>
<li><strong>Error</strong> — Compilation fails</li>
<li><strong>Warning</strong> — Compilation succeeds, but issue flagged</li>
<li><strong>Info</strong> — Informational message</li>
</ul>
<p>Control severity with <code>strictNaming</code>:</p>
<pre><code class="language-yaml">compilerOptions:
  strictNaming: "error"    # Naming violations are errors
  # OR
  strictNaming: "warning"  # Naming violations are warnings
  # OR
  strictNaming: "off"      # No naming enforcement
</code></pre>
<h2 id="suppressing-errors"><a class="header" href="#suppressing-errors">Suppressing Errors</a></h2>
<h3 id="type-assertions-2"><a class="header" href="#type-assertions-2">Type Assertions</a></h3>
<p>Bypass type checking (use sparingly):</p>
<pre><code class="language-lua">const data = externalCall() as User  -- Suppresses type errors
</code></pre>
<h3 id="unknown-type-1"><a class="header" href="#unknown-type-1">Unknown Type</a></h3>
<p>Use <code>unknown</code> for truly dynamic data:</p>
<pre><code class="language-lua">const data: unknown = getData()

-- Must narrow type before use
if type(data) == "table" then
    print(data.value)  -- ✅ OK after narrowing
end
</code></pre>
<h2 id="debugging-errors"><a class="header" href="#debugging-errors">Debugging Errors</a></h2>
<h3 id="pretty-diagnostics"><a class="header" href="#pretty-diagnostics">Pretty Diagnostics</a></h3>
<p>Enable for better error messages:</p>
<pre><code class="language-bash">luanext --pretty main.luax
</code></pre>
<pre><code>error[E0001]: Type mismatch
  ┌─ main.luax:5:10
  │
5 │     const x: number = "hello"
  │              ^^^^^^   ^^^^^^^ expected number, found string
  │              │
  │              type annotation
</code></pre>
<h3 id="error-codes"><a class="header" href="#error-codes">Error Codes</a></h3>
<p>Show error codes for lookup:</p>
<pre><code class="language-bash">luanext --diagnostics main.luax
</code></pre>
<pre><code>main.luax:5:10: error[E0001]: Type mismatch
</code></pre>
<h2 id="see-also-20"><a class="header" href="#see-also-20">See Also</a></h2>
<ul>
<li><a href="#cli-reference">CLI Reference</a> — Diagnostic options</li>
<li><a href="#configuration-reference">Configuration</a> — Error configuration</li>
<li><a href="#type-system">Type System</a> — Type checking rules</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="grammar-reference"><a class="header" href="#grammar-reference">Grammar Reference</a></h1>
<p>Formal grammar specification for LuaNext syntax in EBNF notation.</p>
<h2 id="notation"><a class="header" href="#notation">Notation</a></h2>
<ul>
<li><code>::=</code> — Definition</li>
<li><code>|</code> — Alternative</li>
<li><code>()</code> — Grouping</li>
<li><code>[]</code> — Optional (zero or one)</li>
<li><code>{}</code> — Repetition (zero or more)</li>
<li><code>&lt;&gt;</code> — Non-terminal</li>
<li><code>""</code> — Terminal (keyword or operator)</li>
<li><code>/* */</code> — Comment</li>
</ul>
<h2 id="program-structure"><a class="header" href="#program-structure">Program Structure</a></h2>
<pre><code class="language-ebnf">&lt;program&gt; ::= {&lt;statement&gt;}

&lt;statement&gt; ::=
    | &lt;variable_declaration&gt;
    | &lt;function_declaration&gt;
    | &lt;class_declaration&gt;
    | &lt;interface_declaration&gt;
    | &lt;enum_declaration&gt;
    | &lt;type_alias&gt;
    | &lt;namespace_declaration&gt;
    | &lt;import_statement&gt;
    | &lt;export_statement&gt;
    | &lt;expression_statement&gt;
    | &lt;if_statement&gt;
    | &lt;while_statement&gt;
    | &lt;for_statement&gt;
    | &lt;do_statement&gt;
    | &lt;return_statement&gt;
    | &lt;break_statement&gt;
    | &lt;continue_statement&gt;
    | &lt;try_statement&gt;
    | &lt;throw_statement&gt;
    | &lt;match_statement&gt;
    | &lt;block&gt;
</code></pre>
<h2 id="declarations"><a class="header" href="#declarations">Declarations</a></h2>
<h3 id="variable-declaration"><a class="header" href="#variable-declaration">Variable Declaration</a></h3>
<pre><code class="language-ebnf">&lt;variable_declaration&gt; ::=
    | "const" &lt;identifier&gt; [":" &lt;type&gt;] "=" &lt;expression&gt;
    | "local" &lt;identifier&gt; [":" &lt;type&gt;] ["=" &lt;expression&gt;]
</code></pre>
<h3 id="function-declaration"><a class="header" href="#function-declaration">Function Declaration</a></h3>
<pre><code class="language-ebnf">&lt;function_declaration&gt; ::=
    "function" &lt;identifier&gt; &lt;type_parameters&gt; "(" &lt;parameter_list&gt; ")" [":" &lt;type&gt;] ["throws" &lt;type_list&gt;]
        &lt;block&gt;
    "end"

&lt;parameter_list&gt; ::= [&lt;parameter&gt; {"," &lt;parameter&gt;} ["," "..." &lt;identifier&gt; ":" &lt;type&gt; "[]"]]

&lt;parameter&gt; ::= &lt;identifier&gt; ["?" | "!"] ":" &lt;type&gt; ["=" &lt;expression&gt;]
</code></pre>
<h3 id="class-declaration"><a class="header" href="#class-declaration">Class Declaration</a></h3>
<pre><code class="language-ebnf">&lt;class_declaration&gt; ::=
    {&lt;decorator&gt;}
    "class" &lt;identifier&gt; &lt;type_parameters&gt; ["(" &lt;primary_constructor_params&gt; ")"] ["extends" &lt;type&gt;] ["implements" &lt;type_list&gt;]
        {&lt;class_member&gt;}
    "end"

&lt;primary_constructor_params&gt; ::= &lt;constructor_param&gt; {"," &lt;constructor_param&gt;}

&lt;constructor_param&gt; ::= [&lt;visibility&gt;] &lt;identifier&gt; ":" &lt;type&gt;

&lt;class_member&gt; ::=
    | &lt;property&gt;
    | &lt;method&gt;
    | &lt;constructor&gt;
    | &lt;getter&gt;
    | &lt;setter&gt;
    | &lt;operator_overload&gt;

&lt;property&gt; ::= {&lt;decorator&gt;} [&lt;visibility&gt;] ["readonly"] &lt;identifier&gt; ":" &lt;type&gt; ["=" &lt;expression&gt;]

&lt;method&gt; ::= {&lt;decorator&gt;} [&lt;visibility&gt;] ["override"] ["final"] "function" &lt;identifier&gt; &lt;type_parameters&gt; "(" &lt;parameter_list&gt; ")" [":" &lt;type&gt;] &lt;block&gt; "end"

&lt;constructor&gt; ::= "constructor" "(" &lt;parameter_list&gt; ")" &lt;block&gt; "end"

&lt;getter&gt; ::= {&lt;decorator&gt;} [&lt;visibility&gt;] "get" &lt;identifier&gt; "(" ")" ":" &lt;type&gt; &lt;block&gt; "end"

&lt;setter&gt; ::= {&lt;decorator&gt;} [&lt;visibility&gt;] "set" &lt;identifier&gt; "(" &lt;identifier&gt; ":" &lt;type&gt; ")" &lt;block&gt; "end"

&lt;operator_overload&gt; ::= {&lt;decorator&gt;} "operator" &lt;overloadable_op&gt; "(" &lt;parameter_list&gt; ")" ":" &lt;type&gt; &lt;block&gt; "end"

&lt;overloadable_op&gt; ::= "+" | "-" | "*" | "/" | "%" | "^" | "//" | ".." | "==" | "~=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "&amp;" | "|" | "~" | "&lt;&lt;" | "&gt;&gt;" | "[]" | "()" | "#" | "-" | "not"
</code></pre>
<h3 id="interface-declaration"><a class="header" href="#interface-declaration">Interface Declaration</a></h3>
<pre><code class="language-ebnf">&lt;interface_declaration&gt; ::=
    "interface" &lt;identifier&gt; &lt;type_parameters&gt; ["extends" &lt;type_list&gt;]
        {&lt;interface_member&gt;}
    "end"

&lt;interface_member&gt; ::=
    | &lt;property_signature&gt;
    | &lt;method_signature&gt;
    | &lt;index_signature&gt;
    | &lt;call_signature&gt;
    | &lt;method_with_body&gt;

&lt;property_signature&gt; ::= ["readonly"] &lt;identifier&gt; ["?"] ":" &lt;type&gt;

&lt;method_signature&gt; ::= "function" &lt;identifier&gt; &lt;type_parameters&gt; "(" &lt;parameter_list&gt; ")" ":" &lt;type&gt;

&lt;method_with_body&gt; ::= "function" &lt;identifier&gt; &lt;type_parameters&gt; "(" &lt;parameter_list&gt; ")" ":" &lt;type&gt; &lt;block&gt; "end"

&lt;index_signature&gt; ::= "[" &lt;identifier&gt; ":" &lt;type&gt; "]" ":" &lt;type&gt;

&lt;call_signature&gt; ::= "(" &lt;parameter_list&gt; ")" ":" &lt;type&gt;
</code></pre>
<h3 id="enum-declaration"><a class="header" href="#enum-declaration">Enum Declaration</a></h3>
<pre><code class="language-ebnf">&lt;enum_declaration&gt; ::=
    "enum" &lt;identifier&gt;
        &lt;enum_members&gt;
    "end"

&lt;enum_members&gt; ::= &lt;enum_variant&gt; {"," &lt;enum_variant&gt;} [","]

&lt;enum_variant&gt; ::= &lt;identifier&gt; ["=" &lt;expression&gt;]
</code></pre>
<h3 id="type-alias"><a class="header" href="#type-alias">Type Alias</a></h3>
<pre><code class="language-ebnf">&lt;type_alias&gt; ::= "type" &lt;identifier&gt; &lt;type_parameters&gt; "=" &lt;type&gt;
</code></pre>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<pre><code class="language-ebnf">&lt;type&gt; ::=
    | &lt;primary_type&gt;
    | &lt;union_type&gt;
    | &lt;intersection_type&gt;
    | &lt;function_type&gt;
    | &lt;conditional_type&gt;

&lt;primary_type&gt; ::=
    | &lt;type_reference&gt;
    | &lt;literal_type&gt;
    | &lt;array_type&gt;
    | &lt;tuple_type&gt;
    | &lt;object_type&gt;
    | &lt;parenthesized_type&gt;
    | &lt;typeof_type&gt;
    | &lt;template_literal_type&gt;

&lt;type_reference&gt; ::= &lt;identifier&gt; [&lt;type_arguments&gt;]

&lt;literal_type&gt; ::= &lt;string_literal&gt; | &lt;number_literal&gt; | "true" | "false" | "nil"

&lt;array_type&gt; ::= &lt;type&gt; "[" "]"

&lt;tuple_type&gt; ::= "[" &lt;type_list&gt; "]"

&lt;object_type&gt; ::= "{" {&lt;type_member&gt; ","} "}"

&lt;type_member&gt; ::=
    | &lt;property_signature&gt;
    | &lt;method_signature&gt;
    | &lt;index_signature&gt;

&lt;union_type&gt; ::= &lt;type&gt; "|" &lt;type&gt; {"|" &lt;type&gt;}

&lt;intersection_type&gt; ::= &lt;type&gt; "&amp;" &lt;type&gt; {"&amp;" &lt;type&gt;}

&lt;function_type&gt; ::= "(" &lt;parameter_list&gt; ")" "=&gt;" &lt;type&gt;

&lt;conditional_type&gt; ::= &lt;type&gt; "extends" &lt;type&gt; "?" &lt;type&gt; ":" &lt;type&gt;

&lt;typeof_type&gt; ::= "typeof" &lt;expression&gt;

&lt;template_literal_type&gt; ::= "`" {&lt;template_literal_element&gt;} "`"

&lt;template_literal_element&gt; ::= &lt;string_chars&gt; | "${" &lt;type&gt; "}"

&lt;type_parameters&gt; ::= "&lt;" &lt;type_parameter_list&gt; "&gt;"

&lt;type_parameter_list&gt; ::= &lt;type_parameter&gt; {"," &lt;type_parameter&gt;}

&lt;type_parameter&gt; ::= &lt;identifier&gt; ["extends" &lt;type&gt;] ["=" &lt;type&gt;]

&lt;type_arguments&gt; ::= "&lt;" &lt;type_list&gt; "&gt;"

&lt;type_list&gt; ::= &lt;type&gt; {"," &lt;type&gt;}
</code></pre>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<pre><code class="language-ebnf">&lt;expression&gt; ::=
    | &lt;assignment_expression&gt;
    | &lt;conditional_expression&gt;
    | &lt;binary_expression&gt;
    | &lt;unary_expression&gt;
    | &lt;postfix_expression&gt;
    | &lt;primary_expression&gt;

&lt;primary_expression&gt; ::=
    | &lt;identifier&gt;
    | &lt;literal&gt;
    | &lt;function_expression&gt;
    | &lt;arrow_function&gt;
    | &lt;class_expression&gt;
    | &lt;array_literal&gt;
    | &lt;table_literal&gt;
    | &lt;template_string&gt;
    | &lt;parenthesized_expression&gt;
    | &lt;new_expression&gt;

&lt;assignment_expression&gt; ::= &lt;expression&gt; &lt;assignment_op&gt; &lt;expression&gt;

&lt;assignment_op&gt; ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "//=" | "..=" | "&amp;=" | "|=" | "&lt;&lt;=" | "&gt;&gt;="

&lt;conditional_expression&gt; ::= &lt;expression&gt; "?" &lt;expression&gt; ":" &lt;expression&gt;

&lt;binary_expression&gt; ::= &lt;expression&gt; &lt;binary_op&gt; &lt;expression&gt;

&lt;binary_op&gt; ::=
    | "or" | "and"
    | "==" | "~=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="
    | "|" | "~" | "&amp;" | "&lt;&lt;" | "&gt;&gt;"
    | ".." | "+" | "-" | "*" | "/" | "//" | "%" | "^"
    | "??" | "|&gt;" | "!!"
    | "instanceof"

&lt;unary_expression&gt; ::= &lt;unary_op&gt; &lt;expression&gt;

&lt;unary_op&gt; ::= "not" | "#" | "-" | "~"

&lt;postfix_expression&gt; ::=
    | &lt;expression&gt; "." &lt;identifier&gt;
    | &lt;expression&gt; "?." &lt;identifier&gt;
    | &lt;expression&gt; "[" &lt;expression&gt; "]"
    | &lt;expression&gt; "?[" &lt;expression&gt; "]"
    | &lt;expression&gt; "(" [&lt;argument_list&gt;] ")"
    | &lt;expression&gt; "?(" [&lt;argument_list&gt;] ")"
    | &lt;expression&gt; ":" &lt;identifier&gt; "(" [&lt;argument_list&gt;] ")"
    | &lt;expression&gt; "?:" &lt;identifier&gt; "(" [&lt;argument_list&gt;] ")"
    | &lt;expression&gt; "as" &lt;type&gt;

&lt;arrow_function&gt; ::= "(" &lt;parameter_list&gt; ")" "=&gt;" (&lt;expression&gt; | &lt;block&gt;)

&lt;new_expression&gt; ::= &lt;type&gt; "." "new" "(" [&lt;argument_list&gt;] ")"

&lt;argument_list&gt; ::= &lt;expression&gt; {"," &lt;expression&gt;}
</code></pre>
<h2 id="statements"><a class="header" href="#statements">Statements</a></h2>
<h3 id="control-flow-1"><a class="header" href="#control-flow-1">Control Flow</a></h3>
<pre><code class="language-ebnf">&lt;if_statement&gt; ::=
    "if" &lt;expression&gt; "then"
        &lt;block&gt;
    {"elseif" &lt;expression&gt; "then" &lt;block&gt;}
    ["else" &lt;block&gt;]
    "end"

&lt;while_statement&gt; ::= "while" &lt;expression&gt; "do" &lt;block&gt; "end"

&lt;for_statement&gt; ::=
    | "for" &lt;identifier&gt; [":" &lt;type&gt;] "=" &lt;expression&gt; "," &lt;expression&gt; ["," &lt;expression&gt;] "do" &lt;block&gt; "end"
    | "for" &lt;identifier_list&gt; "in" &lt;expression_list&gt; "do" &lt;block&gt; "end"

&lt;do_statement&gt; ::= "do" &lt;block&gt; "end"
</code></pre>
<h3 id="pattern-matching-3"><a class="header" href="#pattern-matching-3">Pattern Matching</a></h3>
<pre><code class="language-ebnf">&lt;match_statement&gt; ::=
    "match" &lt;expression&gt;
        {"|" &lt;pattern&gt; ["if" &lt;expression&gt;] "-&gt;" (&lt;expression&gt; | &lt;block&gt; "end")}
    "end"

&lt;pattern&gt; ::=
    | &lt;identifier_pattern&gt;
    | &lt;literal_pattern&gt;
    | &lt;wildcard_pattern&gt;
    | &lt;array_pattern&gt;
    | &lt;object_pattern&gt;
    | &lt;or_pattern&gt;

&lt;identifier_pattern&gt; ::= &lt;identifier&gt;

&lt;literal_pattern&gt; ::= &lt;literal&gt;

&lt;wildcard_pattern&gt; ::= "_"

&lt;array_pattern&gt; ::= "[" [&lt;pattern_list&gt;] ["," "..." &lt;identifier&gt;] "]"

&lt;object_pattern&gt; ::= "{" [&lt;object_pattern_field&gt; {"," &lt;object_pattern_field&gt;}] "}"

&lt;object_pattern_field&gt; ::= &lt;identifier&gt; ["=" &lt;pattern&gt;]

&lt;or_pattern&gt; ::= &lt;pattern&gt; "|" &lt;pattern&gt;

&lt;pattern_list&gt; ::= &lt;pattern&gt; {"," &lt;pattern&gt;}
</code></pre>
<h3 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h3>
<pre><code class="language-ebnf">&lt;try_statement&gt; ::=
    "try"
        &lt;block&gt;
    {&lt;catch_clause&gt;}
    ["finally" &lt;block&gt;]
    "end"

&lt;catch_clause&gt; ::= "catch" [&lt;identifier&gt; [":" &lt;type&gt;]] &lt;block&gt;

&lt;throw_statement&gt; ::= "throw" &lt;expression&gt;
</code></pre>
<h3 id="module-system-3"><a class="header" href="#module-system-3">Module System</a></h3>
<pre><code class="language-ebnf">&lt;import_statement&gt; ::=
    | "import" "{" &lt;import_specifier_list&gt; "}" "from" &lt;string_literal&gt;
    | "import" "*" "as" &lt;identifier&gt; "from" &lt;string_literal&gt;
    | "import" &lt;identifier&gt; "from" &lt;string_literal&gt;

&lt;import_specifier_list&gt; ::= &lt;import_specifier&gt; {"," &lt;import_specifier&gt;}

&lt;import_specifier&gt; ::= &lt;identifier&gt; ["as" &lt;identifier&gt;] | "type" &lt;identifier&gt;

&lt;export_statement&gt; ::=
    | "export" &lt;declaration&gt;
    | "export" "{" &lt;export_specifier_list&gt; "}"
    | "export" "*" "from" &lt;string_literal&gt;

&lt;export_specifier_list&gt; ::= &lt;export_specifier&gt; {"," &lt;export_specifier&gt;}

&lt;export_specifier&gt; ::= &lt;identifier&gt; ["as" &lt;identifier&gt;]
</code></pre>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<pre><code class="language-ebnf">&lt;literal&gt; ::=
    | &lt;nil_literal&gt;
    | &lt;boolean_literal&gt;
    | &lt;number_literal&gt;
    | &lt;string_literal&gt;
    | &lt;function_literal&gt;

&lt;nil_literal&gt; ::= "nil"

&lt;boolean_literal&gt; ::= "true" | "false"

&lt;number_literal&gt; ::= &lt;decimal_literal&gt; | &lt;hex_literal&gt; | &lt;binary_literal&gt;

&lt;decimal_literal&gt; ::= &lt;digit&gt; {&lt;digit&gt;} ["." {&lt;digit&gt;}] [&lt;exponent&gt;]

&lt;hex_literal&gt; ::= "0x" &lt;hex_digit&gt; {&lt;hex_digit&gt;}

&lt;binary_literal&gt; ::= "0b" &lt;binary_digit&gt; {&lt;binary_digit&gt;}

&lt;exponent&gt; ::= ("e" | "E") ["+" | "-"] &lt;digit&gt; {&lt;digit&gt;}

&lt;string_literal&gt; ::= '"' {&lt;string_char&gt;} '"' | "'" {&lt;string_char&gt;} "'"

&lt;template_string&gt; ::= "`" {&lt;template_element&gt;} "`"

&lt;template_element&gt; ::= &lt;string_char&gt; | "${" &lt;expression&gt; "}"

&lt;array_literal&gt; ::= "{" [&lt;expression_list&gt;] "}"

&lt;table_literal&gt; ::= "{" [&lt;field_list&gt;] "}"

&lt;field_list&gt; ::= &lt;field&gt; {"," &lt;field&gt;} [","]

&lt;field&gt; ::=
    | "[" &lt;expression&gt; "]" "=" &lt;expression&gt;
    | &lt;identifier&gt; "=" &lt;expression&gt;
    | &lt;expression&gt;

&lt;expression_list&gt; ::= &lt;expression&gt; {"," &lt;expression&gt;}
</code></pre>
<h2 id="decorators-1"><a class="header" href="#decorators-1">Decorators</a></h2>
<pre><code class="language-ebnf">&lt;decorator&gt; ::= "@" &lt;identifier&gt; ["(" [&lt;argument_list&gt;] ")"]
</code></pre>
<h2 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h2>
<pre><code class="language-ebnf">&lt;identifier&gt; ::= &lt;letter&gt; {&lt;letter&gt; | &lt;digit&gt; | "_"}

&lt;letter&gt; ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"

&lt;digit&gt; ::= "0" | "1" | ... | "9"

&lt;hex_digit&gt; ::= &lt;digit&gt; | "a" | ... | "f" | "A" | ... | "F"

&lt;binary_digit&gt; ::= "0" | "1"
</code></pre>
<h2 id="operator-precedence"><a class="header" href="#operator-precedence">Operator Precedence</a></h2>
<p>From highest to lowest:</p>
<ol>
<li>Member access (<code>.</code>, <code>[]</code>, <code>:</code>)</li>
<li>Function call (<code>()</code>)</li>
<li>Unary (<code>not</code>, <code>-</code>, <code>#</code>, <code>~</code>)</li>
<li>Exponentiation (<code>^</code>)</li>
<li>Multiplicative (<code>*</code>, <code>/</code>, <code>%</code>, <code>//</code>)</li>
<li>Additive (<code>+</code>, <code>-</code>)</li>
<li>Concatenation (<code>..</code>)</li>
<li>Bitwise shift (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>)</li>
<li>Bitwise AND (<code>&amp;</code>)</li>
<li>Bitwise XOR (<code>~</code>)</li>
<li>Bitwise OR (<code>|</code>)</li>
<li>Comparison (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>~=</code>, <code>instanceof</code>)</li>
<li>Logical AND (<code>and</code>)</li>
<li>Logical OR (<code>or</code>)</li>
<li>Null coalesce (<code>??</code>)</li>
<li>Ternary (<code>? :</code>)</li>
<li>Pipe (<code>|&gt;</code>)</li>
<li>Error chain (<code>!!</code>)</li>
<li>Assignment (<code>=</code>, <code>+=</code>, etc.)</li>
</ol>
<h2 id="comments-1"><a class="header" href="#comments-1">Comments</a></h2>
<pre><code class="language-ebnf">&lt;comment&gt; ::=
    | "--" {&lt;any_char&gt;} &lt;newline&gt;          /* Single-line comment */
    | "--[[" {&lt;any_char&gt;} "]]"             /* Multi-line comment */
    | "---" {&lt;any_char&gt;} &lt;newline&gt;         /* Documentation comment */
</code></pre>
<h2 id="whitespace"><a class="header" href="#whitespace">Whitespace</a></h2>
<p>Whitespace (spaces, tabs, newlines) is ignored except in string literals and to separate tokens.</p>
<h2 id="see-also-21"><a class="header" href="#see-also-21">See Also</a></h2>
<ul>
<li><a href="#basics">Language Features</a> — Syntax examples</li>
<li><a href="#operators">Operators</a> — Operator details</li>
<li><a href="#keywords-reference">Keywords</a> — Reserved keywords</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="keywords-reference"><a class="header" href="#keywords-reference">Keywords Reference</a></h1>
<p>Complete list of reserved keywords in LuaNext.</p>
<h2 id="reserved-keywords"><a class="header" href="#reserved-keywords">Reserved Keywords</a></h2>
<p>Keywords cannot be used as identifiers (variable names, function names, etc.).</p>
<h3 id="lua-keywords"><a class="header" href="#lua-keywords">Lua Keywords</a></h3>
<p>Standard Lua keywords (inherited):</p>
<pre><code class="language-text">and       break     do        else      elseif
end       false     for       function  goto
if        in        local     nil       not
or        repeat    return    then      true
until     while
</code></pre>
<h3 id="luanext-keywords"><a class="header" href="#luanext-keywords">LuaNext Keywords</a></h3>
<p>Additional keywords introduced by LuaNext:</p>
<pre><code class="language-text">as          class       const       declare     decorator
export      extends     from        implements  import
instanceof  interface   namespace   new         override
readonly    type        typeof
</code></pre>
<h3 id="feature-specific-keywords"><a class="header" href="#feature-specific-keywords">Feature-Specific Keywords</a></h3>
<p>Keywords enabled with specific features:</p>
<p><strong>Pattern Matching:</strong></p>
<pre><code class="language-text">match
</code></pre>
<p><strong>Error Handling:</strong></p>
<pre><code class="language-text">catch     finally     rethrow     throw     throws     try
</code></pre>
<p><strong>Enums:</strong></p>
<pre><code class="language-text">enum
</code></pre>
<h2 id="usage-12"><a class="header" href="#usage-12">Usage</a></h2>
<h3 id="cannot-use-as-identifiers"><a class="header" href="#cannot-use-as-identifiers">Cannot Use as Identifiers</a></h3>
<pre><code class="language-lua">-- ❌ Error: Cannot use keyword as identifier
const function = 5
const class = "test"
local type = "string"
</code></pre>
<h3 id="valid-alternatives"><a class="header" href="#valid-alternatives">Valid Alternatives</a></h3>
<pre><code class="language-lua">-- ✅ OK: Use descriptive names instead
const func = 5
const className = "test"
local dataType = "string"
</code></pre>
<h2 id="contextual-keywords"><a class="header" href="#contextual-keywords">Contextual Keywords</a></h2>
<p>Some keywords are only reserved in specific contexts:</p>
<h3 id="declare"><a class="header" href="#declare"><code>declare</code></a></h3>
<p>Only reserved in declaration contexts:</p>
<pre><code class="language-lua">-- ✅ OK: declare as property name
const obj = {declare = true}

-- ❌ Error: declare statement
declare function print(x: unknown): void
</code></pre>
<h3 id="readonly-3"><a class="header" href="#readonly-3"><code>readonly</code></a></h3>
<p>Only reserved as a modifier:</p>
<pre><code class="language-lua">-- ✅ OK: readonly as property name
const obj = {readonly = false}

-- ❌ Error: readonly modifier
interface User
    readonly id: string
end
</code></pre>
<h3 id="new"><a class="header" href="#new"><code>new</code></a></h3>
<p>Reserved for constructor calls:</p>
<pre><code class="language-lua">-- ❌ Error: new is reserved
const new = 5

-- ✅ OK: Used for constructors
const obj = MyClass.new()
</code></pre>
<h2 id="soft-keywords"><a class="header" href="#soft-keywords">Soft Keywords</a></h2>
<p>Some identifiers are not strictly reserved but should be avoided:</p>
<pre><code class="language-text">never      unknown     void       _
</code></pre>
<p>These have special meaning in type contexts but can technically be used as identifiers (not recommended).</p>
<h2 id="future-reserved"><a class="header" href="#future-reserved">Future Reserved</a></h2>
<p>These keywords may be reserved in future versions:</p>
<pre><code class="language-text">abstract    async    await    final    private
protected   public   static   super
</code></pre>
<p><strong>Avoid using these</strong> to ensure forward compatibility.</p>
<h2 id="see-also-22"><a class="header" href="#see-also-22">See Also</a></h2>
<ul>
<li><a href="#basics">Basics</a> — Variable declarations</li>
<li><a href="#type-system">Type System</a> — Type keywords</li>
<li><a href="#classes">Classes</a> — Class keywords</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="getting-started-as-a-contributor"><a class="header" href="#getting-started-as-a-contributor">Getting Started as a Contributor</a></h1>
<p>Welcome to LuaNext! This guide will help you set up your development environment and get started contributing to the project.</p>
<h2 id="development-environment-setup"><a class="header" href="#development-environment-setup">Development Environment Setup</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li><strong>Rust 1.70+</strong> — Required for building the compiler</li>
<li><strong>Cargo</strong> — Rust’s package manager (installed with Rust)</li>
<li><strong>Git</strong> — Version control</li>
<li><strong>mdBook</strong> — Documentation site generator (optional, only needed to build docs locally)</li>
</ul>
<h3 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h3>
<ol>
<li>
<p><strong>Clone the repository</strong></p>
<pre><code class="language-bash">git clone https://github.com/forge18/luanext.git
cd luanext
</code></pre>
</li>
<li>
<p><strong>Install Rust</strong> (if not already installed)</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</li>
<li>
<p><strong>Build the project</strong></p>
<pre><code class="language-bash">cargo build --release
</code></pre>
</li>
<li>
<p><strong>Run tests</strong></p>
<pre><code class="language-bash">cargo test --all
</code></pre>
</li>
<li>
<p><strong>Install the CLI locally</strong> (for testing)</p>
<pre><code class="language-bash">cargo install --path crates/luanext-cli
</code></pre>
</li>
</ol>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<h3 id="code-quality"><a class="header" href="#code-quality">Code Quality</a></h3>
<p>Before committing, ensure code passes all checks:</p>
<pre><code class="language-bash"># Format code
cargo fmt --all

# Run linter
cargo clippy --all-targets --all-features -- -D warnings

# Run tests
cargo test --all

# Check code coverage
cargo tarpaulin --config-file tarpaulin.toml
</code></pre>
<p>The repository has pre-commit hooks that enforce these checks automatically.</p>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<pre><code>luanext/
├── crates/
│   ├── luanext-core/       # Lexer, parser, type checker, codegen
│   ├── luanext-cli/        # Command-line interface
│   ├── luanext-lsp/        # Language Server Protocol implementation
│   ├── luanext-parser/     # Parser (separate crate)
│   ├── luanext-typechecker/# Type checker (separate crate)
│   └── ...
├── docs/                   # Technical documentation (architecture, implementation)
├── docs-site/              # User-facing documentation website
│   └── src/
│       ├── getting-started/# Installation, quick-start guides
│       ├── language/       # Language reference
│       ├── guides/         # Tutorials and migration guides
│       └── reference/      # CLI, config, stdlib reference
├── editors/                # Editor integrations (VSCode, etc.)
└── scripts/                # Build and utility scripts
</code></pre>
<h2 id="contributing-to-documentation"><a class="header" href="#contributing-to-documentation">Contributing to Documentation</a></h2>
<p>The project uses a hybrid documentation structure:</p>
<h3 id="technical-documentation-docs"><a class="header" href="#technical-documentation-docs">Technical Documentation (<code>/docs</code>)</a></h3>
<p>For internal implementation details, architecture, design decisions:</p>
<ul>
<li><strong>Location:</strong> <code>/docs/</code> directory</li>
<li><strong>Audience:</strong> Contributors and maintainers</li>
<li><strong>Examples:</strong> <code>ARCHITECTURE.md</code>, <code>IMPLEMENTATION.md</code>, design documents</li>
<li><strong>Edit directly</strong> when updating technical details</li>
</ul>
<h3 id="user-facing-documentation-docs-sitesrc"><a class="header" href="#user-facing-documentation-docs-sitesrc">User-Facing Documentation (<code>/docs-site/src</code>)</a></h3>
<p>For guides, tutorials, and language reference:</p>
<ul>
<li><strong>Location:</strong> <code>/docs-site/src/</code> directory</li>
<li><strong>Audience:</strong> End users</li>
<li><strong>Sections:</strong>
<ul>
<li><code>getting-started/</code> — Installation, quick-start, setup guides</li>
<li><code>language/</code> — Language reference and features</li>
<li><code>guides/</code> — Tutorials and migration guides</li>
<li><code>reference/</code> — API reference, CLI, configuration</li>
</ul>
</li>
</ul>
<h3 id="editing-content"><a class="header" href="#editing-content">Editing Content</a></h3>
<ol>
<li>
<p><strong>For quick-start or language guides:</strong></p>
<pre><code class="language-bash"># Edit files in docs-site/src/
editor docs-site/src/guides/your-guide.md
</code></pre>
</li>
<li>
<p><strong>For technical docs:</strong></p>
<pre><code class="language-bash"># Edit files in docs/
editor docs/ARCHITECTURE.md
</code></pre>
</li>
<li>
<p><strong>Adding new pages:</strong></p>
<ul>
<li>Create the markdown file in the appropriate directory</li>
<li>Update <code>docs-site/src/SUMMARY.md</code> with the new entry</li>
<li>Test locally (see below)</li>
</ul>
</li>
</ol>
<h3 id="updating-the-navigation-menu"><a class="header" href="#updating-the-navigation-menu">Updating the Navigation Menu</a></h3>
<p>Edit <code>/docs-site/src/SUMMARY.md</code> to add or modify documentation structure:</p>
<pre><code class="language-markdown"># Summary

[Introduction](introduction.md)

---

# Language

- [Basics](language/basics.md)
- [Your New Guide](language/your-guide.md)

---
</code></pre>
<h2 id="testing-documentation-locally"><a class="header" href="#testing-documentation-locally">Testing Documentation Locally</a></h2>
<p>To preview documentation changes:</p>
<ol>
<li>
<p><strong>Install mdBook</strong> (if not already installed)</p>
<pre><code class="language-bash">cargo install mdbook mdbook-mermaid mdbook-linkcheck
</code></pre>
</li>
<li>
<p><strong>Serve documentation locally</strong></p>
<pre><code class="language-bash">cd docs-site
mdbook serve --open
</code></pre>
</li>
<li>
<p><strong>View in browser</strong> — Opens at <code>http://localhost:3000</code></p>
</li>
<li>
<p><strong>Live reload</strong> — Changes to markdown files automatically reload in browser</p>
</li>
<li>
<p><strong>Check for broken links</strong> (before submitting PR)</p>
<pre><code class="language-bash">cd docs-site
mdbook-linkcheck
</code></pre>
</li>
</ol>
<h2 id="code-submission-guidelines"><a class="header" href="#code-submission-guidelines">Code Submission Guidelines</a></h2>
<h3 id="before-submitting-a-pr"><a class="header" href="#before-submitting-a-pr">Before Submitting a PR</a></h3>
<ol>
<li>
<p><strong>Ensure code is formatted</strong></p>
<pre><code class="language-bash">cargo fmt --all
</code></pre>
</li>
<li>
<p><strong>Pass linter checks</strong></p>
<pre><code class="language-bash">cargo clippy --all-targets --all-features -- -D warnings
</code></pre>
</li>
<li>
<p><strong>All tests pass</strong></p>
<pre><code class="language-bash">cargo test --all
</code></pre>
</li>
<li>
<p><strong>Update documentation</strong></p>
<ul>
<li>If adding a new feature, update language reference or CLI docs</li>
<li>If fixing a bug, clarify in commit message</li>
<li>Keep README.md in sync with major changes</li>
</ul>
</li>
<li>
<p><strong>Documentation links pass validation</strong></p>
<pre><code class="language-bash">cd docs-site &amp;&amp; mdbook-linkcheck
</code></pre>
</li>
</ol>
<h3 id="commit-messages"><a class="header" href="#commit-messages">Commit Messages</a></h3>
<p>Use clear, descriptive commit messages:</p>
<pre><code>feat: add pattern matching support
fix: resolve type inference issue in generics
docs: clarify module system architecture
refactor: simplify type checking algorithm
test: add coverage for pattern matching
</code></pre>
<h3 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h3>
<ol>
<li>Create a feature branch</li>
<li>Make changes and commit</li>
<li>Push to your fork</li>
<li>Create a pull request with clear description</li>
<li>Address feedback from reviewers</li>
<li>Squash commits if requested</li>
</ol>
<h2 id="useful-commands"><a class="header" href="#useful-commands">Useful Commands</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>cargo build</code></td><td>Build debug binaries</td></tr>
<tr><td><code>cargo build --release</code></td><td>Build optimized release binaries</td></tr>
<tr><td><code>cargo test --all</code></td><td>Run all tests</td></tr>
<tr><td><code>cargo test --all -- --nocapture</code></td><td>Run tests with output</td></tr>
<tr><td><code>cargo doc --open</code></td><td>Build and view API documentation</td></tr>
<tr><td><code>cargo fmt --all</code></td><td>Format all code</td></tr>
<tr><td><code>cargo clippy</code></td><td>Run linter</td></tr>
<tr><td><code>mdbook serve --open</code></td><td>Preview documentation</td></tr>
</tbody>
</table>
</div>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><strong>Questions?</strong> Open a GitHub issue with the <code>question</code> label</li>
<li><strong>Bug reports?</strong> Use the <code>bug</code> label with a minimal reproduction</li>
<li><strong>Feature requests?</strong> Use the <code>enhancement</code> label with use cases</li>
<li><strong>Documentation improvements?</strong> Submit a PR or open an issue</li>
</ul>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<p>For more details, see:</p>
<ul>
<li><strong>Architecture:</strong> <a href="../docs/ARCHITECTURE.html">/docs/ARCHITECTURE.md</a></li>
<li><strong>Implementation:</strong> <a href="../docs/IMPLEMENTATION.html">/docs/IMPLEMENTATION.md</a></li>
<li><strong>Development Setup:</strong> <a href="../docs/DEVELOPMENT_SETUP.html">/docs/DEVELOPMENT_SETUP.md</a></li>
<li><strong>Testing Guide:</strong> <a href="../docs/TESTING.html">/docs/TESTING.md</a></li>
<li><strong>Contributing Guidelines:</strong> <a href="../CONTRIBUTING.html">CONTRIBUTING.md</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-api-documentation"><a class="header" href="#rust-api-documentation">Rust API Documentation</a></h1>
<p>LuaNext provides comprehensive API documentation for Rust developers integrating the compiler into their projects.</p>
<h2 id="available-crates"><a class="header" href="#available-crates">Available Crates</a></h2>
<h3 id="core-compiler"><a class="header" href="#core-compiler">Core Compiler</a></h3>
<h4 id="luanext-core"><a class="header" href="#luanext-core"><a href="api/luanext_core">luanext-core</a></a></h4>
<p>The main compiler implementation including:</p>
<ul>
<li><strong>Lexer</strong> — Tokenization and scanning</li>
<li><strong>Parser</strong> — Syntax parsing and AST generation</li>
<li><strong>Type Checker</strong> — Type inference and validation</li>
<li><strong>Code Generator</strong> — Lua code generation</li>
</ul>
<p>Use this crate when building tools that need full compilation capabilities.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luanext_core::{Lexer, Parser, TypeChecker, CodeGenerator};

let source = "local x: number = 42";
let tokens = Lexer::new(source).tokenize()?;
let ast = Parser::new(tokens).parse()?;
let checked = TypeChecker::new().check(&amp;ast)?;
let lua_code = CodeGenerator::new().generate(&amp;checked)?;
<span class="boring">}</span></code></pre>
<h4 id="luanext-parser"><a class="header" href="#luanext-parser"><a href="api/luanext_parser">luanext-parser</a></a></h4>
<p>Standalone parser for parsing LuaNext syntax without type checking.</p>
<p>Use this for:</p>
<ul>
<li>Syntax validation without compilation</li>
<li>Building IDE features</li>
<li>Creating custom analyses</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luanext_parser::{Lexer, Parser};

let source = "function greet(name: string): string
    return 'Hello, ' .. name
end";
let ast = Parser::parse(source)?;
<span class="boring">}</span></code></pre>
<h4 id="luanext-typechecker"><a class="header" href="#luanext-typechecker"><a href="api/luanext_typechecker">luanext-typechecker</a></a></h4>
<p>Standalone type checker for analyzing LuaNext types independently.</p>
<p>Use this for:</p>
<ul>
<li>Type analysis tools</li>
<li>LSP type information</li>
<li>Static analysis</li>
</ul>
<h3 id="command-line-interface"><a class="header" href="#command-line-interface">Command-Line Interface</a></h3>
<h4 id="luanext-cli"><a class="header" href="#luanext-cli"><a href="api/luanext_cli">luanext-cli</a></a></h4>
<p>The <code>luanext</code> command-line compiler tool.</p>
<p>For end users, prefer using the CLI directly. For library integration, use <code>luanext-core</code>.</p>
<h3 id="language-server-protocol"><a class="header" href="#language-server-protocol">Language Server Protocol</a></h3>
<h4 id="luanext-lsp"><a class="header" href="#luanext-lsp"><a href="api/luanext_lsp">luanext-lsp</a></a></h4>
<p>Complete LSP implementation providing:</p>
<ul>
<li>Code completion</li>
<li>Type information on hover</li>
<li>Diagnostics and error reporting</li>
<li>Go to definition</li>
<li>References finding</li>
<li>Symbol renaming</li>
</ul>
<p>Use this to integrate LuaNext support into any editor via LSP.</p>
<h3 id="utilities"><a class="header" href="#utilities">Utilities</a></h3>
<h4 id="luanext-sourcemap"><a class="header" href="#luanext-sourcemap"><a href="api/luanext_sourcemap">luanext-sourcemap</a></a></h4>
<p>Source map generation and management for debugging compiled Lua code.</p>
<p>Use this to map stack traces back to original LuaNext source lines.</p>
<h4 id="luanext-test-helpers"><a class="header" href="#luanext-test-helpers"><a href="api/luanext_test_helpers">luanext-test-helpers</a></a></h4>
<p>Testing utilities for LuaNext development.</p>
<p>This crate is primarily for internal use in LuaNext development.</p>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="using-the-compiler-as-a-library"><a class="header" href="#using-the-compiler-as-a-library">Using the Compiler as a Library</a></h3>
<pre class="playground"><code class="language-rust">use luanext_core::{Lexer, Parser, TypeChecker, CodeGenerator, Config};

fn compile_luanext(source: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    // Tokenize
    let tokens = Lexer::new(source).tokenize()?;

    // Parse
    let ast = Parser::new(tokens).parse()?;

    // Type check
    let checked = TypeChecker::new().check(&amp;ast)?;

    // Generate Lua code
    let lua_code = CodeGenerator::new().generate(&amp;checked)?;

    Ok(lua_code)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let luanext_code = r#"
        interface User {
            name: string,
            age: number
        }

        function createUser(name: string, age: number): User
            return { name = name, age = age }
        end
    "#;

    let lua_code = compile_luanext(luanext_code)?;
    println!("{}", lua_code);
    Ok(())
}</code></pre>
<h3 id="parsing-without-type-checking"><a class="header" href="#parsing-without-type-checking">Parsing Without Type Checking</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use luanext_parser::{Lexer, Parser};

fn check_syntax(source: &amp;str) -&gt; bool {
    match Lexer::new(source).tokenize() {
        Ok(tokens) =&gt; Parser::new(tokens).parse().is_ok(),
        Err(_) =&gt; false,
    }
}
<span class="boring">}</span></code></pre>
<h3 id="using-the-lsp-server"><a class="header" href="#using-the-lsp-server">Using the LSP Server</a></h3>
<p>For editor integration, use the LSP server directly:</p>
<pre><code class="language-bash">luanext-lsp --stdio
</code></pre>
<p>The LSP server communicates via stdin/stdout and is compatible with any editor that supports the Language Server Protocol.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Each crate has detailed documentation accessible via:</p>
<pre><code class="language-bash">cargo doc --open
</code></pre>
<p>This opens the full API documentation in your browser.</p>
<h2 id="feature-flags-1"><a class="header" href="#feature-flags-1">Feature Flags</a></h2>
<p>Some crates support optional features:</p>
<pre><code class="language-toml">[dependencies]
luanext-core = { version = "0.1", features = ["sourcemaps", "optimizations"] }
</code></pre>
<p>Check individual crate documentation for available features.</p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>LuaNext follows semantic versioning (MAJOR.MINOR.PATCH):</p>
<ul>
<li><strong>MAJOR</strong> — Breaking API changes</li>
<li><strong>MINOR</strong> — New features (backward compatible)</li>
<li><strong>PATCH</strong> — Bug fixes</li>
</ul>
<p>Check crate-specific documentation for deprecation notices.</p>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<ul>
<li><strong>API Questions?</strong> Check crate documentation via <code>cargo doc</code></li>
<li><strong>Issues?</strong> Report on <a href="https://github.com/forge18/luanext/issues">GitHub</a></li>
<li><strong>Contributing?</strong> See <a href="../CONTRIBUTING.html">CONTRIBUTING.md</a></li>
</ul>

                </section>

                </div><!-- page-inner -->

            </div><!-- page-wrapper -->

            </div><!-- book-inner -->

            <!-- Version Selector -->
            <nav class="nav-wide-wrapper" aria-label="More">
                <a href="javascript:void(0)" id="menu-bar-wide" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </a>
            </nav>

            <!-- Version selector dropdown -->
            <div id="version-selector" class="version-selector">
                <select id="version-picker" onchange="switchVersion(this.value)" aria-label="Documentation version">
                    <option value="latest">Latest</option>
                </select>
            </div>

        </div><!-- book -->

        <!-- Custom scripts -->
        <script>
            // Version selector functionality
            function switchVersion(version) {
                const base = window.location.origin + '/luanext/';
                if (version === 'latest') {
                    window.location.href = base;
                } else {
                    window.location.href = base + version + '/';
                }
            }

            // Load versions.json and populate selector if it exists
            fetch('/luanext/versions.json')
                .then(response => response.json())
                .then(data => {
                    if (data.versions && data.versions.length > 1) {
                        const selector = document.getElementById('version-picker');
                        data.versions.forEach(v => {
                            if (v.version !== 'latest') {
                                const option = document.createElement('option');
                                option.value = 'v' + v.version;
                                option.textContent = 'v' + v.version;
                                selector.appendChild(option);
                            }
                        });
                    }
                })
                .catch(() => {
                    // versions.json not found (expected during initial setup)
                    // Selector will only show "Latest"
                });
        </script>

        <!-- mdBook scripts and content scripts -->
        <script src="js/clipboard.min.js" type="text/javascript"></script>
        <script src="js/highlight.js" type="text/javascript"></script>
        <script src="js/book.js" type="text/javascript"></script>

        <!-- Custom theme script -->
        <script src="js/custom-theme.js" type="text/javascript"></script>

        <script src="js/elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="js/mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="js/lunr-en.js" type="text/javascript" charset="utf-8"></script>
        <script src="js/search.js" type="text/javascript" charset="utf-8"></script>

    </body>
</html>
